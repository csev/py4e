
Object-oriented programming
===========================

Managing larger programs
------------------------

\index{object-oriented}

Sa simula ng libro na ito, nakabuo tayo ng apat na basic programming
patterns na ginagamit natin para gumawa ng programs:

* Sequential code
* Conditional code (if statements)
* Repetitive code (loops)
* Store and reuse (functions)

Sa mga susunod na chapters, nag-explore tayo ng simple variables pati na rin ng collection
data structures tulad ng lists, tuples, at dictionaries.

Habang gumagawa tayo ng programs, nagde-design tayo ng data structures at sumusulat ng code
para manipulahin ang mga data structures na iyon. Mayroong maraming paraan para sumulat ng programs
at sa ngayon, malamang nakasulat ka na ng ilang programs na "hindi masyadong elegant"
at iba pang programs na "mas elegant". Kahit na ang programs mo
ay maaaring maliit, nagsisimula ka nang makita kung paano mayroong kaunting sining at
aesthetic sa pagsusulat ng code.

Habang ang programs ay nagiging milyun-milyong linya ang haba, nagiging mas mahalaga
na sumulat ng code na madaling maintindihan. Kung nagtatrabaho ka sa million-line
program, hindi mo kailanman maaaring panatilihin ang buong program sa isip mo nang sabay.
Kailangan natin ng mga paraan para hatiin ang malalaking programs sa maraming mas maliliit na piraso para
mas kaunti ang dapat tingnan kapag nagso-solve ng problema, nagfi-fix ng bug, o nagdaragdag ng bagong feature.

Sa isang paraan, ang object oriented programming ay paraan para ayusin ang code mo
para maaari mong i-zoom ang 50 lines ng code at maintindihan ito
habang hindi pinapansin ang iba pang 999,950 lines ng code sa sandaling iyon.

Getting started
---------------

Tulad ng maraming aspeto ng programming, kailangan na matutunan ang mga konsepto ng
object oriented programming bago mo magamit ang mga ito nang epektibo.
Dapat mong lapitan ang chapter na ito bilang paraan para matuto ng ilang terms at concepts at magtrabaho
sa ilang simpleng halimbawa para maglagay ng pundasyon para sa pag-aaral sa hinaharap.

Ang pangunahing resulta ng chapter na ito ay magkaroon ng basic na pag-unawa kung paano
ginagawa ang objects at kung paano sila gumagana at pinakamahalaga kung paano
ginagamit natin ang capabilities ng objects na ibinigay sa atin ng Python
at Python libraries.

Using objects
-------------

Tulad ng lumalabas, gumagamit na tayo ng objects sa buong libro na ito. Ang Python
ay nagbibigay sa atin ng maraming built-in objects. Narito ang ilang simpleng code
kung saan ang unang ilang linya ay dapat pakiramdam na napakasimple at natural sa iyo.

\index{list object}

\VerbatimInput{../code3/objects.py}

Sa halip na tumuon sa kung ano ang nagagawa ng mga linyang ito, tingnan natin kung ano ang
talagang nangyayari mula sa punto de vista ng object-oriented programming.
Huwag mag-alala kung ang sumusunod na paragraphs ay hindi makakasensya sa
unang pagkakataon na binabasa mo sila dahil hindi pa natin tinukoy ang lahat ng terms na ito.

Ang unang linya ay *gumagawa* ng object ng type na `list`, ang pangalawa at pangatlong
linya ay *tumatawag* sa `append()` *method*, ang ikaapat na linya ay tumatawag sa
`sort()` method, at ang ikalimang linya ay *kumukuha* ng item sa posisyon 0.

Ang ikaanim na linya ay tumatawag sa `__getitem__()` method sa `stuff` list
na may parameter na zero.

~~~~ {.python}
print (stuff.__getitem__(0))
~~~~

Ang ikapitong linya ay mas verbose na paraan ng pagkuha ng 0th item
sa list.

~~~~ {.python}
print (list.__getitem__(stuff,0))
~~~~

Sa code na ito, tumatawag tayo sa `__getitem__` method sa `list` class
at *nagpapasa* ng list at item na gusto nating kunin mula sa list
bilang parameters.

Ang huling tatlong linya ng program ay katumbas, pero mas
maginhawa na simpleng gamitin ang square bracket syntax para maghanap ng item sa
partikular na posisyon sa list.

Maaari tayong tumingin sa capabilities ng object sa pamamagitan ng
pagtingin sa output ng `dir()` function:

    >>> stuff = list()
    >>> dir(stuff)
    ['__add__', '__class__', '__contains__', '__delattr__',
    '__delitem__', '__dir__', '__doc__', '__eq__',
    '__format__', '__ge__', '__getattribute__', '__getitem__',
    '__gt__', '__hash__', '__iadd__', '__imul__', '__init__',
    '__iter__', '__le__', '__len__', '__lt__', '__mul__',
    '__ne__', '__new__', '__reduce__', '__reduce_ex__',
    '__repr__', '__reversed__', '__rmul__', '__setattr__',
    '__setitem__', '__sizeof__', '__str__', '__subclasshook__',
    'append', 'clear', 'copy', 'count', 'extend', 'index',
    'insert', 'pop', 'remove', 'reverse', 'sort']
    >>>

Ang natitirang parte ng chapter na ito ay tutukuyin ang lahat ng terms sa itaas kaya siguraduhing
bumalik pagkatapos mong tapusin ang chapter at basahin ulit ang paragraphs sa itaas para
suriin ang iyong pag-unawa.

Starting with programs
----------------------

Ang program sa pinakabasic na form nito ay tumatanggap ng ilang input, gumagawa ng ilang processing, at
gumagawa ng ilang output. Ang elevator conversion program natin ay nagpapakita ng napakaikli
pero kumpletong program na nagpapakita ng lahat ng tatlong hakbang na ito.

\VerbatimInput{../code3/elev.py}

Kung mag-iisip tayo nang kaunti tungkol sa program na ito, mayroong "outside world" at
ang program. Ang input at output aspects ay kung saan nakikipag-ugnayan ang program
sa outside world. Sa loob ng program mayroon tayong code at data para makamit
ang gawain na idinisenyo ng program na solusyonan.

![A Program](height=1.20in@../images/program)

Ang isang paraan para isipin ang object-oriented programming ay hinihiwalay nito
ang program natin sa maraming "zones." Ang bawat zone ay naglalaman ng ilang code at data
(tulad ng program) at may well defined interactions sa outside world
at iba pang zones sa loob ng program.

Kung titingnan natin ang link extraction application kung saan ginamit natin ang
BeautifulSoup library, makikita natin ang program na ginawa sa pamamagitan ng pagkokonekta
ng iba't ibang objects nang magkasama para makamit ang gawain:

\index{BeautifulSoup}
\index{HTML}
\index{parsing!HTML}

\VerbatimInput{../code3/urllinks.py}

Binabasa natin ang URL sa string at pagkatapos ipinapasa iyon sa `urllib` para kunin
ang data mula sa web. Ang `urllib` library ay gumagamit ng `socket` library para
gumawa ng aktwal na network connection para kunin ang data. Kinukuha natin ang string
na ibinabalik ng `urllib` at ibinibigay sa BeautifulSoup para i-parse.
Ang BeautifulSoup ay gumagamit ng object na
`html.parser`^[https://docs.python.org/3/library/html.parser.html] at nagre-return ng object.
Tumatawag tayo sa `tags()` method sa returned object na nagre-return ng dictionary ng tag
objects. Naglo-loop tayo sa tags at tumatawag sa `get()` method para sa bawat tag
para mag-print ng `href` attribute.

Maaari tayong gumuhit ng larawan ng program na ito at kung paano gumagana nang magkasama ang objects.

![A Program as Network of Objects](height=1.50in@../images/program-oo)

Ang susi dito ay hindi maintindihan nang perpekto kung paano gumagana ang program na ito pero makita
kung paano gumagawa tayo ng network ng interacting objects at nag-o-orchestrate ng paggalaw
ng impormasyon sa pagitan ng objects para gumawa ng program. Mahalaga rin
na tandaan na kapag tiningnan mo ang program na iyon ilang chapters pabalik, maaari mong
ganap na maintindihan kung ano ang nangyayari sa program nang hindi man lang napagtanto
na ang program ay "nag-o-orchestrate ng paggalaw ng data sa pagitan ng objects."
Ito ay simpleng mga linya ng code na gumagawa ng trabaho.

Subdividing a problem
---------------------

Isa sa mga advantages ng object-oriented approach ay maaari nitong
itago ang complexity. Halimbawa, habang kailangan nating malaman kung paano gamitin ang
`urllib` at BeautifulSoup code, hindi natin kailangang malaman kung paano gumagana ang mga libraries na iyon
internally. Nagpapahintulot ito sa atin na tumuon sa parte ng problema na kailangan nating
solusyonan at huwag pansinin ang iba pang parte ng program.

![Ignoring Detail When Using an Object](height=1.50in@../images/program-oo-code)

Ang kakayahang ito na tumuon eksklusibo sa parte ng program na pinapahalagahan natin
at huwag pansinin ang natitira ay kapaki-pakinabang din sa mga developers ng objects na ginagamit natin.
Halimbawa, ang mga programmers na gumagawa ng BeautifulSoup ay hindi kailangang
malaman o mag-alala tungkol sa kung paano natin kinukuha ang HTML page natin, kung ano ang mga parte na gusto nating
basahin, o kung ano ang plano nating gawin sa data na kinukuha natin mula sa web page.

![Ignoring Detail When Building an Object](height=1.50in@../images/program-oo-bs4)

Our first Python object
-----------------------

Sa basic level, ang object ay simpleng ilang code kasama ang data structures na
mas maliit kaysa sa buong program. Ang pagtukoy ng function ay nagpapahintulot sa atin na mag-store
ng kaunting code at bigyan ito ng pangalan at pagkatapos tawagin ang code na iyon gamit ang
pangalan ng function.

Ang object ay maaaring maglalaman ng ilang functions (na tinatawag nating *methods*) pati na rin
ng data na ginagamit ng mga functions na iyon. Tinatawag natin ang data items na
parte ng object na *attributes*.

\index{class keyword}

Ginagamit natin ang `class` keyword para tukuyin ang data at code na gagawin ng bawat
isa sa objects. Ang class keyword ay kasama ang pangalan ng class at nagsisimula ng
indented block ng code kung saan isinasama natin ang attributes (data)
at methods (code).

\VerbatimInput{../code3/party2.py}

Ang bawat method ay mukhang function, nagsisimula sa `def` keyword at
binubuo ng indented block ng code.

Ang unang method ay specially-named method na tinatawag na `__init__()`.
Ang method na ito ay tinatawag para gumawa ng anumang initial setup ng data na gusto nating
i-store sa object. Sa class na ito nag-a-allocate tayo ng `x` attribute
gamit ang dot notation at ini-initialize ito sa zero.

~~~~ {.python}
    self.x = 0
~~~~

Ang iba pang method na pinangalanang `party`. Ang lahat ng methods ay may espesyal na unang
parameter na pinangalanan natin ayon sa convention na `self`. Ang unang parameter
ay nagbibigay sa atin ng access sa object instance para maaari tayong mag-set ng attributes
at tumawag ng methods gamit ang dot notation.

Tulad ng `def` keyword ay hindi nagdudulot na ma-execute ang function code, ang
`class` keyword ay hindi gumagawa ng object. Sa halip, ang `class`
keyword ay nagde-define ng template na nagpapahiwatig kung ano ang data at code na maglalaman
sa bawat object ng type na `PartyAnimal`. Ang class ay parang cookie cutter
at ang objects na ginawa gamit ang class ay ang
cookies^[Cookie image copyright CC-BY
https://www.flickr.com/photos/dinnerseries/23570475099].
Hindi mo nilalagay ang frosting sa cookie cutter;
nilalagay mo ang frosting sa cookies, at maaari kang maglagay ng iba't ibang frosting
sa bawat cookie.

![A Class and Two Objects](height=2.0in@../photos/cookie_cutter_flickr_Didriks)

Kung magpapatuloy tayo sa sample program na ito, makikita natin ang unang executable line ng
code:

~~~~ {.python}
an = PartyAnimal()
~~~~

\index{construct}
\index{object}
\index{instance}
\index{class}

Dito natin ini-instruct ang Python na gumawa (i.e., create) ng *object* o
*instance* ng class na `PartyAnimal`. Mukha itong function call sa
class mismo. Ang Python ay gumagawa ng object na may tamang data at methods
at nagre-return ng object na pagkatapos ay na-a-assign sa variable na `an`.
Sa isang paraan ito ay medyo katulad ng sumusunod na linya na ginagamit natin
sa buong panahon:

~~~~ {.python}
counts = dict()
~~~~

Dito ini-instruct natin ang Python na gumawa ng object gamit ang `dict` template
(nandito na sa Python), ibalik ang instance ng dictionary,
at i-assign ito sa variable na `counts`.

Kapag ang `PartyAnimal` class ay ginagamit para gumawa ng object, ang variable na `an`
ay ginagamit para tumuro sa object na iyon. Ginagamit natin ang `an` para ma-access ang code at data para sa
partikular na instance ng `PartyAnimal` class.

Ang bawat Partyanimal object/instance ay naglalaman sa loob nito ng variable na `x`
at method/function na pinangalanang `party`. Tumatawag tayo sa `party` method sa linyang ito:

~~~~ {.python}
an.party()
~~~~

Kapag ang `party` method ay tinatawag, ang unang parameter (na tinatawag natin ayon sa convention na `self`)
ay tumuturo sa partikular na instance ng PartyAnimal object na tinatawag ang `party`.
Sa loob ng `party` method, nakikita natin ang linya:

~~~~ {.python}
self.x = self.x + 1
~~~~

Ang syntax na ito gamit ang *dot* operator ay nagsasabing 'ang x sa loob ng self.' Sa bawat pagkakataon na tinatawag ang `party()`,
ang internal `x` value ay na-i-increment ng 1 at ang value ay na-pi-print.

Ang sumusunod na linya ay isa pang paraan para tawagin ang `party` method sa loob ng `an`
object:

~~~~ {.python}
PartyAnimal.party(an)
~~~~

Sa variation na ito, na-a-access natin ang code mula sa loob ng class at tahasang
ipinapasa ang object pointer na `an` bilang unang parameter (i.e., `self` sa loob ng method).
Maaari mong isipin ang `an.party()` bilang shorthand para sa linya sa itaas.

Kapag nag-e-execute ang program, gumagawa ito ng sumusunod na output:

~~~~
So far 1
So far 2
So far 3
So far 4
~~~~

Ang object ay ginawa, at ang `party` method ay tinawag nang apat na beses, parehong
nag-i-increment at nagpi-print ng value para sa `x` sa loob ng `an` object.

Classes as types
----------------

\index{dir}
\index{type}

Tulad ng nakita natin, sa Python lahat ng variables ay may type. Maaari nating gamitin ang built-in
`dir` function para suriin ang capabilities ng variable. Maaari din nating gamitin ang `type` at
`dir` sa mga classes na ginagawa natin.

\VerbatimInput{../code3/party3.py}

Kapag nag-e-execute ang program na ito, gumagawa ito ng sumusunod na output:

~~~~
Type <class '__main__.PartyAnimal'>
Dir  ['__class__', '__delattr__', ...
'__sizeof__', '__str__', '__subclasshook__',
'__weakref__', 'party', 'x']
Type <class 'int'>
Type <class 'method'>
~~~~

Makikita mo na gamit ang `class` keyword, gumawa tayo ng bagong type.
Mula sa `dir` output, makikita mo na parehong `x` integer attribute at `party`
method ay available sa object.

Object lifecycle
----------------

\index{constructor}
\index{destructor}
\index{object lifecycle}

Sa naunang mga halimbawa, nagde-define tayo ng class (template), gumagamit ng class na iyon
para gumawa ng instance ng class na iyon (object), at pagkatapos gumagamit ng instance. Kapag
natapos ang program, lahat ng variables ay itinatapon. Karaniwan, hindi natin masyadong iniisip
ang paggawa at pagkasira ng variables, pero kadalasan habang ang objects natin
ay nagiging mas kumplikado, kailangan nating gumawa ng ilang aksyon sa loob ng object para mag-set up ng mga bagay
habang ginagawa ang object at posibleng linisin ang mga bagay kapag ang object ay
itinapon.

Kung gusto nating malaman ng object natin ang mga sandaling ito ng construction at destruction,
nagdaragdag tayo ng specially named methods sa object natin:

\VerbatimInput{../code3/party4.py}

Kapag nag-e-execute ang program na ito, gumagawa ito ng sumusunod na output:

~~~~
I am constructed
So far 1
So far 2
I am destructed 2
an contains 42
~~~~

Habang gumagawa ang Python ng object natin, tinatawag nito ang `__init__` method natin para
bigyan tayo ng pagkakataon na mag-set up ng ilang default o initial values para sa object.
Kapag nakakita ang Python ng linya:

~~~~
an = 42
~~~~

Talagang "itinatapon ang object natin" para maaari nitong muling gamitin ang variable na `an`
para mag-store ng value na `42`. Sa sandaling ang `an` object natin ay
"sinisira" ang destructor code natin (`__del__`) ay tinatawag. Hindi natin
mapipigilan ang variable natin na masira, pero maaari tayong gumawa ng anumang kailangan
cleanup bago lang mawala ang object natin.

Kapag gumagawa ng objects, napakakaraniwan na magdagdag ng constructor sa object
para mag-set up ng initial values para sa object. Relatively bihira na kailangan ng
destructor para sa object.

Multiple instances
------------------

Hanggang ngayon, nagde-define tayo ng class, gumawa ng isang object, gumamit ng
object na iyon, at pagkatapos itinapon ang object. Gayunpaman, ang tunay na kapangyarihan
sa object-oriented programming ay nangyayari kapag gumagawa tayo ng maraming instances
ng class natin.

Kapag gumagawa tayo ng maraming objects mula sa class natin, maaaring gusto nating mag-set
up ng iba't ibang initial values para sa bawat isa sa objects. Maaari tayong
magpasa ng data sa constructors para bigyan ang bawat object ng iba't ibang initial
value:

\VerbatimInput{../code3/party5.py}

Ang constructor ay may parehong `self` parameter na tumuturo sa object instance
at karagdagang parameters na ipinapasa sa constructor habang
ginagawa ang object:

~~~~
s = PartyAnimal('Sally')
~~~~

Sa loob ng constructor, ang pangalawang linya ay kumokopya ng parameter (`nam`) na
ipinapasa sa `name` attribute sa loob ng object instance.

~~~~
self.name = nam
~~~~

Ang output ng program ay nagpapakita na ang bawat isa sa objects (`s` at `j`) ay naglalaman ng kanilang sariling
independent copies ng `x` at `nam`:

~~~~
Sally constructed
Sally party count 1
Jim constructed
Jim party count 1
Sally party count 2
~~~~

Inheritance
-----------

\index{object!inheritance}
Ang isa pang makapangyarihang feature ng object-oriented programming ay ang kakayahang
gumawa ng bagong class sa pamamagitan ng pag-extend ng existing class. Kapag nag-e-extend ng class,
tinatawag natin ang original class na *parent class* at ang bagong class na
*child class*.

Para sa halimbawang ito, inililipat natin ang `PartyAnimal` class natin sa sarili nitong file.
Pagkatapos, maaari nating 'i-import' ang `PartyAnimal` class sa bagong file at i-extend ito, tulad ng sumusunod:

\VerbatimInput{../code3/party6.py}

Kapag nagde-define tayo ng `CricketFan` class, ipinapahiwatig natin na nag-e-extend tayo
sa `PartyAnimal` class. Nangangahulugan ito na lahat ng variables (`x`) at methods
(`party`) mula sa `PartyAnimal` class ay *na-inherit* ng `CricketFan` class.
Halimbawa, sa loob ng `six` method sa `CricketFan` class, 
tumatawag tayo sa `party` method mula sa `PartyAnimal` class.

Gumagamit tayo ng espesyal na syntax sa `__init__()` method sa `CricketFan` class para siguraduhin
na tinatawag natin ang `__init__()` method sa `PartyAnimal` para ang anumang setup
na kailangan ng `PartyAnimal` ay ginagawa bilang karagdagan sa setup na kailangan para sa `CricketFan`
extensions.

~~~~ {.python}
   def __init__(self, nam) :
       super().__init__(nam)
       self.points = 0
~~~~

\index{super class}
Ang `super()` syntax ay nagsasabi sa Python na tawagin ang `__init__` method sa class na
ine-extend natin. Ang `PartyAnimal` ay ang super (o parent) class at ang `CricketFan`
ay ang sub (o child) class.

Habang nag-e-execute ang program, gumagawa tayo ng `s` at `j` bilang independent instances
ng `PartyAnimal` at `CricketFan`. Ang `j` object ay may karagdagang capabilities lampas sa
`s` object.

~~~~
Sally constructed
Sally party count 1
Jim constructed
Jim party count 1
Jim party count 2
Jim points 6
['__class__', '__delattr__', ... '__weakref__',
'name', 'party', 'points', 'six', 'x']
~~~~

Sa `dir` output para sa `j` object (instance ng `CricketFan` class), nakikita natin
na mayroon itong attributes at methods ng parent class, pati na rin ang attributes
at methods na idinagdag kapag ang class ay na-extend para gumawa ng `CricketFan` class.

Summary
-------

Ito ay napakabilis na pagpapakilala sa object-oriented programming na nakatuon mainly
sa terminology at syntax ng pagtukoy at paggamit ng objects.
Mabilis nating suriin ang code na tiningnan natin sa simula ng chapter.
Sa puntong ito dapat mong ganap na maintindihan kung ano ang nangyayari.

\VerbatimInput{../code3/objects.py}

Ang unang linya ay gumagawa ng `list` *object*. Kapag gumagawa ang Python ng `list` object,
tinatawag nito ang *constructor* method (pinangalanang `__init__`) para mag-set up ng internal
data attributes na gagamitin para mag-store ng list data. Hindi tayo nagpasa ng anumang
parameters sa *constructor*. Kapag nagre-return ang constructor, ginagamit natin ang variable
na `stuff` para tumuro sa returned instance ng `list` class.

Ang pangalawa at pangatlong linya ay tumatawag sa `append` method
na may isang parameter para magdagdag ng bagong item sa dulo ng list sa pamamagitan ng pag-update ng
attributes sa loob ng `stuff`. Pagkatapos sa ikaapat na linya,
tumatawag tayo sa `sort` method na walang parameters para i-sort ang data sa loob ng `stuff`
object.

Pagkatapos nagpi-print tayo ng unang item sa list gamit ang square brackets na
shortcut para tawagin ang `__getitem__` method sa loob ng `stuff`. Ito ay
katumbas ng pagtawag sa `__getitem__` method sa `list` *class*
at pagpasa ng `stuff` object bilang unang parameter at ang posisyon
na hinahanap natin bilang pangalawang parameter.

Sa dulo ng program, ang `stuff` object ay itinatapon pero hindi bago
tawagin ang *destructor* (pinangalanang `__del__`) para ang object ay makapaglinis ng anumang
loose ends kung kinakailangan.

Iyon ang basics ng object-oriented programming. Mayroong maraming karagdagang detalye
tungkol sa kung paano pinakamahusay na gamitin ang object-oriented approaches kapag gumagawa ng malalaking applications
at libraries na lampas sa saklaw ng chapter na ito.^[Kung
curious ka tungkol sa kung saan tinukoy ang `list` class, tingnan
(inaasahan na hindi magbabago ang URL)
https://github.com/python/cpython/blob/master/Objects/listobject.c -
ang list class ay isinulat sa language
na tinatawag na "C". Kung titingnan mo ang source code na iyon at makita mo itong curious
maaaring gusto mong i-explore ang C programming na may pagtingin sa paggawa ng objects
sa https://www.cc4e.com/.]

Glossary
--------

attribute
:   Variable na parte ng class.
\index{attribute}

class
:   Template na maaaring gamitin para gumawa ng object. Nagde-define ng
    attributes at methods na gagawin ng object.
\index{class}

child class
:   Bagong class na ginawa kapag ang parent class ay na-extend. Ang child class
    ay nag-i-inherit ng lahat ng attributes at methods ng parent class.
\index{child class}

constructor
:   Opsiyonal na specially named method (`__init__`) na tinatawag sa
    sandaling ang class ay ginagamit para gumawa ng object.
    Karaniwang ginagamit ito para mag-set up ng initial values para sa object.
\index{constructor}

destructor
:   Opsiyonal na specially named method (`__del__`) na tinatawag sa
    sandaling bago masira ang object. Ang destructors ay bihirang
    ginagamit.
\index{destructor}

inheritance
:   Kapag gumagawa tayo ng bagong class (child) sa pamamagitan ng pag-extend ng
    existing class (parent). Ang child class ay may lahat ng attributes
    at methods ng parent class kasama ang karagdagang attributes at
    methods na tinukoy ng child class.
\index{inheritance}

method
:   Function na nakapaloob sa class at objects
    na ginawa mula sa class. Ang ilang object-oriented
    patterns ay gumagamit ng 'message' sa halip na 'method' para ilarawan ang konseptong ito.
\index{method}
\index{message}

object
:   Constructed instance ng class. Ang object ay naglalaman ng lahat ng
    attributes at methods na tinukoy ng class.
    Ang ilang object-oriented documentation ay gumagamit ng term na 'instance'
    nang magkakapalit sa 'object'.
\index{object}

parent class
:   Ang class na ine-extend para gumawa ng bagong child class.
    Ang parent class ay nag-a-ambag ng lahat ng methods at attributes nito
    sa bagong child class.
\index{parent class}

Regular expressions
===================

Hanggang ngayon, nagbabasa tayo sa mga files, naghahanap ng patterns at
kumukuha ng iba't ibang bits ng lines na nakakainteresante sa atin. Gumagamit tayo ng
string methods tulad ng `split` at `find` at
gumagamit ng lists at string slicing para kunin ang mga parte ng lines.

\index{regular expressions}
\index{regex}
\index{re module}

Ang gawaing ito ng paghahanap at pagkuha ay napakakaraniwan na ang Python ay may
napakamakapangyarihang module na tinatawag na *regular expressions* na
naghahandle ng marami sa mga gawaing ito nang elegante. Ang dahilan kung bakit hindi namin
ipinakilala ang regular expressions mas maaga sa libro ay dahil habang sila ay
napakamakapangyarihan, medyo kumplikado sila at ang syntax nila ay nangangailangan ng
ilang paggamit para masanay.

Ang regular expressions ay halos sarili nilang maliit na programming language para sa
paghahanap at pag-parse ng strings. Sa katunayan, buong mga libro ang
nasusulat tungkol sa paksa ng regular expressions. Sa chapter na ito,
tatalakayin lang natin ang basics ng regular expressions. Para sa mas detalyado tungkol sa
regular expressions, tingnan:

<https://en.wikipedia.org/wiki/Regular_expression>

<https://docs.python.org/library/re.html>

Maaari mo ring i-bookmark ang sumusunod na page para mag-eksperimento sa regular 
expressions habang natututo ka:

<https://regex101.com/>

Ang regular expression module na `re` ay dapat i-import sa
program mo bago mo ito magamit. Ang pinakasimpleng paggamit ng regular
expression module ay ang `search()` function. Ang sumusunod
na program ay nagpapakita ng trivial na paggamit ng search function.

\index{regex!search}

\VerbatimInput{../code3/re01.py} 
\begin{trinketfiles}
../code3/mbox-short.txt
\end{trinketfiles}

Binubuksan natin ang file, naglo-loop sa bawat linya, at gumagamit ng regular expression na
`search()` para lang mag-print ng lines na naglalaman ng string
"From:". Ang program na ito ay hindi gumagamit ng tunay na kapangyarihan ng regular
expressions, dahil maaari lang nating gamitin ang
`line.find()` para makamit ang parehong result.

\index{string!find}

Ang kapangyarihan ng regular expressions ay dumarating kapag nagdadagdag tayo ng espesyal na
characters sa search string na nagpapahintulot sa atin na mas tumpak na kontrolin
kung aling lines ang tumugma sa string. Ang pagdaragdag ng espesyal na characters na ito sa aming
regular expression ay nagpapahintulot sa atin na gumawa ng sophisticated matching at extraction
habang sumusulat ng napakakaunting code.

Halimbawa, ang caret character ay ginagamit sa regular expressions para tumugma sa
"simula" ng linya. Maaari nating baguhin ang program natin para lang tumugma sa
lines kung saan ang "From:" ay nasa simula ng linya tulad ng sumusunod:

\VerbatimInput{../code3/re02.py} 
\begin{trinketfiles}
../code3/mbox-short.txt
\end{trinketfiles}

Ngayon ay tumutugma lang tayo sa lines na *nagsisimula sa* string
"From:". Ito ay napakasimpleng halimbawa pa rin na maaari nating gawin
nang katumbas gamit ang `startswith()` method mula sa string
module. Pero nagsisilbi ito para ipakilala ang konsepto na ang regular expressions
ay naglalaman ng espesyal na action characters na nagbibigay sa atin ng mas maraming kontrol kung ano
ang tutugma sa regular expression.

\index{string!startswith}

Character matching in regular expressions
-----------------------------------------

Mayroong ilang iba pang espesyal na characters na nagpapahintulot sa atin na gumawa ng mas
makapangyarihang regular expressions. Ang pinakakaraniwang ginagamit na espesyal
character ay ang period o full stop, na tumutugma sa anumang character.

\index{wild card}
\index{regex!wild card}

Sa sumusunod na halimbawa, ang regular expression na `F..m:` ay tutugma sa anumang
sa mga strings na "From:", "Fxxm:", "F12m:", o "F!@m:" dahil ang period
characters sa regular expression ay tumutugma sa anumang character.

\VerbatimInput{../code3/re03.py} 
\begin{trinketfiles}
../code3/mbox-short.txt
\end{trinketfiles}

Ito ay partikular na makapangyarihan kapag pinagsama sa kakayahang ipahiwatig
na ang character ay maaaring ulitin ng anumang bilang ng beses gamit ang `*` o
`+` characters sa regular expression mo. Ang espesyal na characters na ito ay nangangahulugang
sa halip na tumugma sa isang character sa search string, tumutugma sila sa
zero-or-more characters (sa kaso ng asterisk) o
one-or-more ng characters (sa kaso ng plus sign).

Maaari pa nating paliitin ang lines na tinutugma natin gamit ang paulit-ulit na
*wild card* character sa sumusunod na halimbawa:

\VerbatimInput{../code3/re04.py} 
\begin{trinketfiles}
../code3/mbox-short.txt
\end{trinketfiles}

Ang search string na `^From:.+@` ay matagumpay na tutugma sa lines na nagsisimula
sa "From:", na sinusundan ng isa o higit pang characters (`.+`), na sinusundan ng
at-sign. Kaya tutugma ito sa sumusunod na linya:

~~~~
From: stephen.marquard@uct.ac.za
~~~~

Maaari mong isipin ang `.+` wildcard bilang pagpapalawak para tumugma sa lahat ng
characters sa pagitan ng colon character at at-sign.

~~~~
From:.+@
~~~~

Magandang isipin ang plus at asterisk characters bilang "pushy" o "greedy."
Halimbawa, ang sumusunod na string ay tutugma sa huling at-sign sa string
habang ang `.+` ay nagpu-push palabas, ang nasa `cwen@iupui.edu`.

~~~~
From: stephen.marquard@uct.ac.za, csev@umich.edu, and cwen@iupui.edu
~~~~

Posibleng sabihin sa asterisk o plus sign na huwag maging masyadong "greedy."
Kung mag-a-append ka ng `?`, para gawin itong `.*?` o `.+?`, ang regex mo ay tutugma sa 
pinakaunang instance imbes na huling instance. Sa halimbawa sa itaas, 
ang paggamit ng `.+?@` ay tutugma sa unang at-sign, ang nasa 
`stephen.marquard@uct.ac.za`. Para sa mas maraming detalye, tingnan ang [Python documentation on greedy vs non-greedy quantifiers](https://docs.python.org/3/library/re.html).

\index{greedy}

Extracting data using regular expressions
-----------------------------------------

Kung gusto nating kunin ang data mula sa string sa Python maaari nating gamitin ang
`findall()` method para kunin ang lahat ng substrings na
tumutugma sa regular expression. Gamitin natin ang halimbawa ng pagkuha ng
anumang bagay na mukhang email address mula sa anumang linya anuman ang
format. Halimbawa, gusto nating kunin ang email addresses mula sa bawat isa sa
sumusunod na lines:

~~~~
From stephen.marquard@uct.ac.za Sat Jan  5 09:14:16 2008
Return-Path: <postmaster@collab.sakaiproject.org>
          for <source@collab.sakaiproject.org>;
Received: (from apache@localhost)
Author: stephen.marquard@uct.ac.za
~~~~

Hindi natin gusto na sumulat ng code para sa bawat uri ng lines, na nagha-hati
at nag-slice nang iba para sa bawat linya. Ang sumusunod na program ay gumagamit ng
`findall()` para hanapin ang lines na may email addresses sa kanila
at kunin ang isa o higit pang addresses mula sa bawat isa sa mga lines na iyon.

\index{findall}
\index{regex!findall}

\VerbatimInput{../code3/re05.py} 
\begin{trinketfiles}
../code3/mbox-short.txt
\end{trinketfiles}

Ang `findall()` method ay naghahanap sa string sa pangalawang
argument at nagre-return ng list ng lahat ng strings na mukhang email
addresses. Gumagamit tayo ng two-character sequence na tumutugma sa
non-whitespace character (`\S`). Mapapansin mo na nag-append din tayo ng 
letrang `r` bago lang ang regular expression natin; sinasabi nito sa Python 
na bigyang-kahulugan ang regular expression natin bilang raw string, at huwag tratuhin ang 
backslashes bilang escape characters (tulad ng ginagamit natin sa `\n`).

Ang output ng program ay magiging:

~~~~
['csev@umich.edu', 'cwen@iupui.edu']
~~~~

Sa pag-translate ng regular expression, naghahanap tayo ng substrings na
may hindi bababa sa isang non-whitespace character, na sinusundan ng at-sign,
na sinusundan ng hindi bababa sa isa pang non-whitespace character. Ang
`\S+` ay tumutugma sa kasing dami ng non-whitespace characters na
posible.

Ang regular expression ay tutugma nang dalawang beses (csev@umich.edu at
cwen@iupui.edu), pero hindi ito tutugma sa string na "@2PM" dahil walang
non-blank characters *bago* ang at-sign. Maaari nating
gamitin ang regular expression na ito sa program para basahin ang lahat ng lines sa file
at mag-print ng anumang bagay na mukhang email address tulad ng sumusunod:

\VerbatimInput{../code3/re06.py} 
\begin{trinketfiles}
../code3/mbox-short.txt
\end{trinketfiles}

Binabasa natin ang bawat linya at pagkatapos kinukuha ang lahat ng substrings na tumutugma sa aming
regular expression. Dahil ang `findall()` ay nagre-return ng list, 
simpleng sinusuri natin kung ang bilang ng elements sa returned list natin ay higit sa
zero para mag-print lang ng lines kung saan nakakita tayo ng hindi bababa sa isang substring na
mukhang email address.

Kung patakbuhin natin ang program sa *mbox-short.txt* makukuha natin ang sumusunod
na output:

~~~~
...
['<source@collab.sakaiproject.org>;']
['<source@collab.sakaiproject.org>;']
['apache@localhost)']
['source@collab.sakaiproject.org;']
['cwen@iupui.edu']
['source@collab.sakaiproject.org']
['cwen@iupui.edu']
['cwen@iupui.edu']
['wagnermr@iupui.edu']
~~~~

Ang ilan sa aming email addresses ay may maling characters tulad ng "<" o ";"
sa simula o dulo. Sabihin natin na interesado lang tayo sa
parte ng string na nagsisimula at nagtatapos sa letra o
numero.

Para gawin ito, gumagamit tayo ng iba pang feature ng regular expressions. Ang square
brackets ay ginagamit para ipahiwatig ang set ng maraming acceptable characters na
handa nating isaalang-alang na tumugma. Sa isang diwa, ang `\S` ay
naghihingi na tumugma sa set ng "non-whitespace characters". Ngayon ay magiging mas
eksplisito tayo sa mga characters na tutugma natin.

Narito ang bagong regular expression natin:

~~~~
[a-zA-Z0-9]\S*@\S*[a-zA-Z]
~~~~

Ito ay nagiging medyo kumplikado at maaari mong simulan na makita kung bakit
ang regular expressions ay sarili nilang maliit na language.
Sa pag-translate ng regular expression na ito, naghahanap tayo ng substrings na
nagsisimula sa *isang* lowercase letter, uppercase letter,
o numero "[a-zA-Z0-9]", na sinusundan ng zero o higit pang non-blank characters
(`\S*`), na sinusundan ng at-sign, na sinusundan ng zero o higit pang
non-blank characters (`\S*`), na sinusundan ng uppercase o
lowercase letter. Tandaan na lumipat tayo mula sa `+` patungo sa `*` para ipahiwatig ang
zero o higit pang non-blank characters dahil ang `[a-zA-Z0-9]` ay isa nang
non-blank character. Tandaan na ang `*` o `+` ay nalalapat sa isang
character na agad nasa kaliwa ng plus o asterisk.

\index{regex!character sets(brackets)}

Kung gagamitin natin ang expression na ito sa program natin, mas malinis ang data natin:

\VerbatimInput{../code3/re07.py} 
\begin{trinketfiles}
../code3/mbox-short.txt
\end{trinketfiles}

~~~~
...
['wagnermr@iupui.edu']
['cwen@iupui.edu']
['postmaster@collab.sakaiproject.org']
['200801032122.m03LMFo4005148@nakamura.uits.iupui.edu']
['source@collab.sakaiproject.org']
['source@collab.sakaiproject.org']
['source@collab.sakaiproject.org']
['apache@localhost']
~~~~

Mapansin na sa `source@collab.sakaiproject.org` lines, ang regular
expression natin ay nagtanggal ng dalawang letra sa dulo ng string (">;").
Ito ay dahil kapag nag-a-append tayo ng `[a-zA-Z]` sa dulo ng regular
expression natin, hinihingi natin na anumang string na makikita ng regular expression
parser ay dapat magtapos sa letra. Kaya kapag nakikita nito ang ">" sa dulo ng
"sakaiproject.org>;" simpleng humihinto ito sa huling "matching" na letra na
nakita nito (i.e., ang "g" ay ang huling magandang match).

Tandaan din na ang output ng program ay Python list na may
string bilang isang element sa list.

Combining searching and extracting
----------------------------------

Kung gusto nating hanapin ang mga numero sa lines na nagsisimula sa string "X-" tulad
ng:

~~~~
X-DSPAM-Confidence: 0.8475
X-DSPAM-Probability: 0.0000
~~~~

hindi lang natin gusto ang anumang floating-point numbers mula sa anumang lines. Gusto lang nating
kunin ang mga numero mula sa lines na may syntax sa itaas.

Maaari nating gawin ang sumusunod na regular expression para pumili ng lines:

~~~~
^X-.*: [0-9.]+
~~~~

Sa pag-translate nito, sinasabi natin, gusto natin ng lines na nagsisimula sa `X-`,
na sinusundan ng zero o higit pang characters (`.*`), na sinusundan ng colon (`:`)
at pagkatapos ng space. Pagkatapos ng space naghahanap tayo ng isa o higit pang
characters na alinman sa digit (0-9) o period `[0-9.]+`. Tandaan
na sa loob ng square brackets, ang period ay tumutugma sa aktwal na period
(i.e., hindi ito wildcard sa pagitan ng square brackets).

Ito ay napakapinid na expression na halos tutugma lang sa
lines na interesado tayo tulad ng sumusunod:

\VerbatimInput{../code3/re10.py} 
\begin{trinketfiles}
../code3/mbox-short.txt
\end{trinketfiles}

Kapag pinatakbo natin ang program, nakikita natin ang data na maganda ang filter para ipakita lang
ang lines na hinahanap natin.

~~~~
X-DSPAM-Confidence: 0.8475
X-DSPAM-Probability: 0.0000
X-DSPAM-Confidence: 0.6178
X-DSPAM-Probability: 0.0000
...
~~~~

Pero ngayon kailangan nating solusyonan ang problema ng pagkuha ng mga numero. Habang
sapat na simple ang paggamit ng `split`, maaari tayong gumamit ng iba pang
feature ng regular expressions para parehong maghanap at mag-parse ng linya sa
parehong pagkakataon.

\index{string!split}

Ang parentheses ay isa pang espesyal na character sa regular expressions. Kapag
nagdaragdag ka ng parentheses sa regular expression, hindi sila pinapansin kapag
tumutugma sa string. Pero kapag gumagamit ka ng `findall()`,
ang parentheses ay nagpapahiwatig na habang gusto mo na tumugma ang buong expression,
interesado ka lang na kunin ang parte ng substring na
tumutugma sa regular expression.

\index{regex!parentheses}
\index{parentheses!regular expression}

Kaya ginagawa natin ang sumusunod na pagbabago sa program natin:

\VerbatimInput{../code3/re11.py} 
\begin{trinketfiles}
../code3/mbox-short.txt
\end{trinketfiles}

Sa halip na tawagin ang `search()`, nagdaragdag tayo ng parentheses sa paligid ng
parte ng regular expression na kumakatawan sa floating-point number
para ipahiwatig na gusto lang natin na ibigay sa atin ng `findall()` ang
floating-point number na parte ng matching string.

Ang output mula sa program na ito ay ganito:

~~~~
['0.8475']
['0.0000']
['0.6178']
['0.0000']
['0.6961']
['0.0000']
...
~~~~

Ang mga numero ay nasa list pa rin at kailangang i-convert mula sa strings patungo sa
floating point, pero ginamit na natin ang kapangyarihan ng regular expressions para
parehong maghanap at kunin ang impormasyon na nakakainteresante sa atin.

Bilang isa pang halimbawa ng technique na ito, kung titingnan mo ang file mayroong
ilang lines ng form:

~~~~
Details: http://source.sakaiproject.org/viewsvn/?view=rev&rev=39772
~~~~

Kung gusto nating kunin ang lahat ng revision numbers (ang integer number
sa dulo ng mga lines na ito) gamit ang parehong technique sa itaas, maaari tayong
sumulat ng sumusunod na program:

\VerbatimInput{../code3/re12.py} 
\begin{trinketfiles}
../code3/mbox-short.txt
\end{trinketfiles}

Sa pag-translate ng regular expression natin, naghahanap tayo ng lines na nagsisimula
sa `Details:`, na sinusundan ng anumang bilang ng characters (`.*`), na sinusundan
ng `rev=`, at pagkatapos ng isa o higit pang digits. Gusto nating hanapin ang lines na
tumutugma sa buong expression pero gusto lang nating kunin ang integer
number sa dulo ng linya, kaya pinalilibutan natin ang `[0-9]+` ng parentheses,
at nagdaragdag tayo ng `$` para ipahiwatig na tumutugma partikular sa dulo ng linya.

Kapag pinatakbo natin ang program, makukuha natin ang sumusunod na output:

~~~~
['39772']
['39771']
['39770']
['39769']
...
~~~~

Tandaan na ang `[0-9]+` ay "greedy" at sinusubukan nitong gawing mas malaki ang
string ng digits hangga't maaari bago kunin ang mga digits na iyon. Ang
"greedy" behavior na ito ang dahilan kung bakit nakukuha natin ang lahat ng limang digits para sa bawat numero. Ang
regular expression module ay lumalawak sa parehong direksyon hanggang
makakita ng non-digit, o simula o dulo ng linya.

Ngayon maaari nating gamitin ang regular expressions para gawin ulit ang exercise mula sa mas maaga sa
libro kung saan interesado tayo sa oras ng araw ng bawat mail
message. Naghanap tayo ng lines ng form:

~~~~
From stephen.marquard@uct.ac.za Sat Jan  5 09:14:16 2008
~~~~

at gusto nating kunin ang oras ng araw para sa bawat linya. Dati ginawa natin ito
gamit ang dalawang tawag sa `split`. Una hinati ang linya
sa mga salita at pagkatapos kinuha natin ang ikalimang salita at hinati ulit sa
colon character para kunin ang dalawang characters na interesado tayo.

Habang gumagana ito, nagreresulta ito sa medyo brittle code na
nag-a-assume na ang lines ay maganda ang format. Kung magdaragdag ka ng sapat na error
checking (o malaking try/except block) para siguraduhin na ang program mo ay hindi kailanman
mabibigo kapag binigyan ng maling format na lines, ang code ay
lalaki sa 10-15 lines ng code na medyo mahirap basahin.

Maaari nating gawin ito sa mas simpleng paraan gamit ang sumusunod na regular
expression:

~~~~
^From .* [0-9][0-9]:
~~~~

Ang translation ng regular expression na ito ay naghahanap tayo ng
lines na nagsisimula sa `From ` (tandaan ang space), na sinusundan ng anumang bilang
ng characters (`.*`), na sinusundan ng space, na sinusundan ng dalawang digits
`[0-9][0-9]`, na sinusundan ng colon character. Ito ang definition ng
mga uri ng lines na hinahanap natin.

Para kunin lang ang oras gamit ang `findall()`, nagdaragdag tayo ng
parentheses sa paligid ng dalawang digits tulad ng sumusunod:

~~~~
^From .* ([0-9][0-9]):
~~~~

Ito ay nagreresulta sa sumusunod na program:

\VerbatimInput{../code3/re13.py} 
\begin{trinketfiles}
../code3/mbox-short.txt
\end{trinketfiles}

Kapag tumatakbo ang program, gumagawa ito ng sumusunod na output:

~~~~
['09']
['18']
['16']
['15']
...
~~~~

Escape character
----------------

Ang regular expressions ay gumagamit ng espesyal na characters tulad ng `^` para tumugma sa 
simula ng linya, `$` para sa dulo ng linya, at `.` bilang wildcard; 
gayunpaman, minsan gusto nating tumugma sa mga characters na iyon nang literal. Kailangan natin ng 
paraan para ipahiwatig na gusto nating tumugma sa aktwal na character tulad
ng caret symbol, dollar sign, o period.

Maaari nating ipahiwatig na gusto lang nating tumugma sa character sa pamamagitan ng pag-prefix
ng character na iyon ng backslash. Halimbawa, maaari nating hanapin ang money amounts
gamit ang sumusunod na regular expression.

~~~~ {.python}
import re
x = 'We just received $10.00 for cookies.'
y = re.findall('\$[0-9.]+',x)
~~~~

Dahil nag-prefix tayo ng dollar sign ng backslash, aktwal na tumutugma ito sa
dollar sign sa input string sa halip na tumugma sa "dulo ng
linya", at ang natitirang parte ng regular expression ay tumutugma sa isa o higit pang digits
o period character. Tandaan, tulad ng nakita natin sa itaas, sa loob ng square brackets,
ang characters ay hindi "espesyal". Kaya kapag sinasabi natin ang `[0-9.]`, nangangahulugan ito ng
digits o period. Sa labas ng square brackets, ang period ay ang
"wild-card" character at tumutugma sa anumang character. Sa loob ng square brackets,
ang period ay period.

Summary
-------

Habang ito ay sumasayad lang sa ibabaw ng regular expressions, natutunan natin ang kaunti tungkol sa
language ng regular expressions. Sila ay search
strings na may espesyal na characters sa kanila na nagko-communicate ng iyong mga nais sa
regular expression system tungkol sa kung ano ang nagde-define ng "matching" at kung ano ang
kinukuha mula sa matched strings. Narito ang ilan sa mga espesyal na
characters at character sequences:

`^` Tumutugma sa simula ng linya.

`$` Tumutugma sa dulo ng linya.

`.` Tumutugma sa anumang character (wildcard).

`\s` Tumutugma sa whitespace character.

`\S` Tumutugma sa non-whitespace character (kabaligtaran ng \\s).

`*` Nalalapat sa agad na nauunang character(s) at nagpapahiwatig na tumugma
zero o higit pang beses.

`*?` Nalalapat sa agad na nauunang character(s) at nagpapahiwatig na
tumugma zero o higit pang beses sa "non-greedy mode".

`+` Nalalapat sa agad na nauunang character(s) at nagpapahiwatig na tumugma
isa o higit pang beses.

`+?` Nalalapat sa agad na nauunang character(s) at nagpapahiwatig na
tumugma isa o higit pang beses sa "non-greedy mode".

`?` Nalalapat sa agad na nauunang character(s) at nagpapahiwatig na tumugma
zero o isang beses.

`??` Nalalapat sa agad na nauunang character(s) at nagpapahiwatig na
tumugma zero o isang beses sa "non-greedy mode".

`[aeiou]` Tumutugma sa isang character hangga't ang character na iyon ay nasa
tinukoy na set. Sa halimbawang ito, tutugma ito sa "a", "e", "i", "o", o
"u", pero walang iba pang characters.

`[a-z0-9]` Maaari mong tukuyin ang ranges ng characters gamit ang minus sign. Ang
halimbawang ito ay isang character na dapat lowercase letter o
digit.

`[^A-Za-z]` Kapag ang unang character sa set notation ay caret, ito ay
binabaligtad ang logic. Ang halimbawang ito ay tumutugma sa isang character na
anumang bagay *maliban sa* uppercase o lowercase letter.

`( )` Kapag ang parentheses ay idinagdag sa regular expression, hindi sila pinapansin
para sa layunin ng matching, pero nagpapahintulot sa iyo na kunin ang partikular na
subset ng matched string sa halip na buong string kapag gumagamit ng
`findall()`.

`\b` Tumutugma sa empty string, pero lang sa simula o dulo ng salita.

`\B` Tumutugma sa empty string, pero hindi sa simula o dulo ng salita.

`\d` Tumutugma sa anumang decimal digit; katumbas ng set [0-9].

`\D` Tumutugma sa anumang non-digit character; katumbas ng set [^0-9].

Bonus section for Unix / Linux users
------------------------------------

Ang suporta para sa paghahanap ng files gamit ang regular expressions ay naka-build sa
Unix operating system mula noong 1960s at available ito sa halos lahat ng
programming languages sa isang form o iba pa.

\index{grep}

Sa katunayan, mayroong command-line program na naka-build sa Unix
na tinatawag na *grep* (Generalized Regular Expression Parser)
na gumagawa ng halos pareho sa `search()` examples sa
chapter na ito. Kaya kung mayroon kang Macintosh o Linux system, maaari mong subukan
ang sumusunod na commands sa command-line window mo.

~~~~ {.bash}
$ grep '^From:' mbox-short.txt
From: stephen.marquard@uct.ac.za
From: louis@media.berkeley.edu
From: zqian@umich.edu
From: rjlowe@iupui.edu
~~~~

Sinasabi nito sa `grep` na ipakita sa iyo ang lines na nagsisimula sa
string "From:" sa file na *mbox-short.txt*. Kung
mag-eksperimento ka sa `grep` command ng kaunti at basahin ang
documentation para sa `grep`, makikita mo ang ilang subtle
differences sa pagitan ng regular expression support sa Python at ang
regular expression support sa `grep`. Bilang halimbawa,
ang `grep` ay hindi sumusuporta sa non-blank character na
`\S` kaya kailangan mong gamitin ang medyo mas kumplikadong set
notation na `[^ ]`, na simpleng nangangahulugang tumugma sa character na anumang bagay
maliban sa space.

Debugging
---------

Ang Python ay may ilang simple at rudimentary built-in documentation na maaaring
maging kapaki-pakinabang kung kailangan mo ng mabilis na refresher para ma-trigger ang memory mo
tungkol sa eksaktong pangalan ng partikular na method. Ang documentation na ito ay maaaring
tingnan sa Python interpreter sa interactive mode.

Maaari mong buksan ang interactive help system gamit ang `help()`.

~~~~ {.python}
>>> help()

help> modules
~~~~

Kung alam mo kung anong module ang gusto mong gamitin, maaari mong gamitin ang
`dir()` command para hanapin ang methods sa module tulad ng sumusunod:

~~~~ {.python .trinket}
>>> import re
>>> dir(re)
[.. 'compile', 'copy_reg', 'error', 'escape', 'findall',
'finditer', 'match', 'purge', 'search', 'split', 'sre_compile',
'sre_parse', 'sub', 'subn', 'sys', 'template']
~~~~

Maaari mo ring makuha ang kaunting documentation tungkol sa partikular na method
gamit ang help command na pinagsama sa gustong method.

~~~~ {.python .trinket}
>>> help (re.search)
Help on function search in module re:

search(pattern, string, flags=0)
    Scan through string looking for a match to the pattern, returning
    a match object, or None if no match was found.
>>>
~~~~

Ang built-in documentation ay hindi masyadong malawak, pero maaari itong maging kapaki-pakinabang
kapag nagmamadali ka o walang access sa web browser o search
engine.

Glossary
--------

brittle code
:   Code na gumagana kapag ang input data ay nasa partikular na format pero
    madaling masira kung may deviation mula sa tamang
    format. Tinatawag natin itong "brittle code" dahil madali itong masira.

greedy matching
:   Ang konsepto na ang `+` at `*` characters sa regular expression
    ay lumalawak palabas para tumugma sa pinakamalaking posibleng string.
\index{greedy}
\index{greedy matching}

grep
:   Command na available sa karamihan ng Unix systems na naghahanap sa text
    files na naghahanap ng lines na tumutugma sa regular expressions. Ang command
    name ay nangangahulugang "Generalized Regular Expression Parser".
\index{grep}

regular expression
:   Language para ipahayag ang mas kumplikadong search strings. Ang regular
    expression ay maaaring maglalaman ng espesyal na characters na nagpapahiwatig na ang
    search ay tumutugma lang sa simula o dulo ng linya o marami pang iba
    na katulad na capabilities.

wild card
:   Espesyal na character na tumutugma sa anumang character. Sa regular
    expressions ang wild-card character ay ang period.
\index{wild card}

Exercises
---------

**Exercise 1:** Sumulat ng simpleng program para i-simulate ang operation ng
`grep` command sa Unix. Magtanong sa user na mag-enter ng regular
expression at bilangin ang bilang ng lines na tumugma sa regular
expression:

~~~~
$ python grep.py
Enter a regular expression: ^Author
mbox.txt had 1798 lines that matched ^Author

$ python grep.py
Enter a regular expression: ^X-
mbox.txt had 14368 lines that matched ^X-

$ python grep.py
Enter a regular expression: java$
mbox.txt had 4175 lines that matched java$
~~~~

**Exercise 2:** Sumulat ng program para hanapin ang lines ng form:

~~~~
New Revision: 39772
~~~~

**Kunin ang numero mula sa bawat isa sa lines gamit ang regular expression
at ang `findall()` method. I-compute ang average ng
mga numero at mag-print ng average bilang integer.**

~~~~
Enter file:mbox.txt
38549

Enter file:mbox-short.txt
39756
~~~~

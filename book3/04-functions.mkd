
Funções
=========

Chamada de Função
--------------

\index{chamada de função}

No contexto da programação, uma *função* é a denominação dada à um
conjunto de instruções que realiza uma computação. Quando se define uma
função, você especifica o nome dela e a sequência de instruções. 
Posteriormente, você poderá "chamar" a função pelo seu nome. 
Neste livro, já haviamos visto um exemplo de *chamada de função*:

~~~~ {.python}
>>> type(32)
<class 'int'>
~~~~

O nome da função é `type`. A expressão em
parênteses é chamada de *argumento* da função. 
O argumento é um valor ou variável que estamos passando
para a função como entrada. 
O resultado, para a função `type`, é o tipo do argumento.

\index{parentheses!argumento entrada}

É comum dizer que uma função "leva" um argumento e "retorna" um
resultado. O resultado é chamado de *valor de retorno*.

\index{argumento}
\index{valor de retorno}

Funções internas
------------------

O Python fornece um bom número de funções internas importantes que nós 
podemos usar sem precisar defini-las. Os criadores do Python escreveram 
um conjunto de funções para alguns problemas comuns e as incluíram na 
própria linguagem para nosso uso.

A funções `max` e `min` nos dão o maior e o menor 
valores de uma lista, respectivamente:

~~~~ {.python}
>>> max('Alô mundo')
'ô'
>>> min('Alô mundo')
' '
>>>
~~~~

A função `max` nos diz qual é o "maior caractere" da string (que acaba sendo 
a letra "ô") e a função `min` nos mostra o menor caractere (que acaba sendo 
o espaço).

Outra função interna muito comum é a `len`, que diz quantos itens há em seu 
argumento. Caso este seja uma string, a função retorna o número de caracteres 
que a compõem.

~~~~ {.python}
>>> len('Alô mundo')
9
>>>
~~~~

Essas funções não são limitadas a analisar apenas strings. Elas podem
operar em qualquer conjunto de valores, assim como veremos em capítulos
posteriores.

Você deve encarar os nomes das funções internas como palavras reservadas 
(i.e., evite usar "max" como nome de variável).

Type conversion functions
-------------------------

\index{conversion!type}
\index{type conversion}

Python also provides built-in functions that convert values from one
type to another. The `int` function takes any value and
converts it to an integer, if it can, or complains otherwise:

\index{int function}
\index{function!int}

~~~~ {.python}
>>> int('32')
32
>>> int('Hello')
ValueError: invalid literal for int() with base 10: 'Hello'
~~~~

`int` can convert floating-point values to integers, but it
doesn't round off; it chops off the fraction part:

~~~~ {.python}
>>> int(3.99999)
3
>>> int(-2.3)
-2
~~~~

`float` converts integers and strings to floating-point
numbers:

\index{float function}
\index{function!float}

~~~~ {.python}
>>> float(32)
32.0
>>> float('3.14159')
3.14159
~~~~

Finally, `str` converts its argument to a string:

\index{str function}
\index{function!str}

~~~~ {.python}
>>> str(32)
'32'
>>> str(3.14159)
'3.14159'
~~~~

Math functions
--------------

\index{math function}
\index{function, math}
\index{module}
\index{module object}

Python has a `math` module that provides most of the familiar
mathematical functions. Before we can use the module, we have to import
it:

~~~~ {.python}
>>> import math
~~~~

This statement creates a *module object* named math. If
you print the module object, you get some information about it:

~~~~ {.python}
>>> print(math)
<module 'math' (built-in)>
~~~~

The module object contains the functions and variables defined in the
module. To access one of the functions, you have to specify the name of
the module and the name of the function, separated by a dot (also known
as a period). This format is called *dot notation*.

\index{dot notation}

~~~~ {.python}
>>> ratio = signal_power / noise_power
>>> decibels = 10 * math.log10(ratio)

>>> radians = 0.7
>>> height = math.sin(radians)
~~~~

The first example computes the logarithm base 10 of the signal-to-noise
ratio. The math module also provides a function called `log`
that computes logarithms base e.

\index{log function}
\index{function!log}
\index{sine function}
\index{radian}
\index{trigonometric function}
\index{function, trigonometric}

The second example finds the sine of `radians`. The name of
the variable is a hint that `sin` and the other trigonometric
functions (`cos`, `tan`, etc.) take arguments in
radians. To convert from degrees to radians, divide by 360 and multiply
by $2
\pi$:

~~~~ {.python}
>>> degrees = 45
>>> radians = degrees / 360.0 * 2 * math.pi
>>> math.sin(radians)
0.7071067811865476
~~~~

The expression `math.pi` gets the variable `pi`
from the math module. The value of this variable is an approximation of
$\pi$, accurate to about 15 digits.

\index{pi}

If you know your trigonometry, you can check the previous result by
comparing it to the square root of two divided by two:

\index{sqrt function}
\index{function!sqrt}

~~~~ {.python}
>>> math.sqrt(2) / 2.0
0.7071067811865476
~~~~

Números Aleatórios
--------------

\index{número aleatório}
\index{número, aleatório}
\index{determinístico}
\index{pseudoaleatório}

Dadas as mesmas entradas, a maior parte dos prorgramas geram sempre as mesmas saídas, de forma que eles eles são ditos *determinísticos*. Determinismo é geralmente uma boa coisa, desde que nós esperamos o mesmo cálculo para se obter o mesmo resultado. Para algumas aplicações, porém, nós queremos que o computador seja imprevisível. Jogos são um exemplo óbvio, mas existem outros.

Criar um programa totalmente não determinístico não é tão fácil, mas há formas de que eles apareçam ser não determinísticos. Uma delas é utilizar *algorítmos* que geram *números pseudoaleatórios*. Números pseudoaleatórios não são verdadeiramente aleatórios, pois eles geram computação determinística, mas apenas olhando para os números é impossível distinguí-los deles de números aleatórios.

\index{módulo aleatório}
\index{módulo!aleatório}

The `random` module provides functions that generate
pseudorandom numbers (which I will simply call "random" from here on).

\index{random function}
\index{function!random}

A função `random` retorna um número float entre 0.0 e 1.0 (incluindo 0.0, mas não inclui 1.0). Todas as vezes que se chamar a função `random` você receberá o próximo número de uma série longa. Para ver uma amostra, rode esse loop

~~~~ {.python}
import random

for i in range(10):
    x = random.random()
    print(x)
~~~~
Este programa produz a lista a seguir de 10 números aleatórios entre 
0.0 e números maiores até um número menor do que 1.0.

~~~~
0.11132867921152356
0.5950949227890241
0.04820265884996877
0.841003109276478
0.997914947094958
0.04842330803368111
0.7416295948208405
0.510535245390327
0.27447040171978143
0.028511805472785867
~~~~

**Exercício 1: Rode o programa anterior no seu computador para ver quais números aparecem. 
Rode o programa mais uma vez e veja quais números aparecem.**

A função `random` é apenas uma das funções que utilizam números aleatórios. A função `randint` recebe dois parâmetros, dois números inteiros, e retorna um inteiro, que está pode estar entre ambos os números enviados como parâmetros (incluindo os próprios parâmetros).


\index{função randint }
\index{função!randint}

~~~~ {.python}
>>> random.randint(5, 10)
5
>>> random.randint(5, 10)
9
~~~~
Para escolher um elementeo de uma sequencia aleatoriamente você pode utilizar a função `choice`:

\index{função choice}
\index{função!choice}

~~~~ {.python}
>>> t = [1, 2, 3]
>>> random.choice(t)
2
>>> random.choice(t)
3
~~~~
O módulo `random` também disponibiliza funções para gerar valores aleatórios de acordo com distribuições contínuas, incluindo gaussianas, exponenciais, função gamma e algumas mais.

Adicionando novas funções
--------------------

Até agora, nós temos utilizado apenas as funções que já vêm com o Python, 
mas também é possível adicionar novas funções. Uma *definição de 
função* especifica o nome de uma nova função e a sequência de comandos 
que serão executados quando ela for chamada. Uma vez que nós definimos 
uma função, podemos reutilizá-la repetidas vezes ao longo do nosso 
programa:

\index{função}
\index{definição de função}
\index{definição!função}

Veja aqui um exemplo:

~~~~ {.python}
def print_LetraDaMusica():
    print("Eu sou um lenhador, e eu estou bem.")
    print('Eu durmo a noite toda e trabalho o dia todo.')
~~~~

`def` é uma palavra-chave que indica que isso é uma definição de função. O 
nome da função é `print_LetraDeMusica`. As regras para nomes de funções 
são as mesmas que para nomes de variáveis: letras, números e alguns sinais 
de pontuação são permitidos, mas o primeiro caractere não pode ser um 
número. Você não pode usar uma palavra-chave como nome de função, e 
você deve evitar ter uma variável e uma função com nomes iguais.

\index{palavra-chave def}
\index{palavra-chave!def}
\index{argumento}

Os parênteses vazios após o nome indicam que essa função não aceita 
argumentos. Mais tarde nós construiremos funções que levam argumentos 
como suas entradas. 

\index{parênteses!vazios}
\index{cabeçalho}
\index{corpo}
\index{indentação}
\index{dois pontos}

A primeira linha da definição da função é chamada de 
*cabeçalho*; o restante é o *corpo*.
O cabeçalho tem que encerrar com dois pontos e o
corpo tem que estar indentado. Por convenção, a endentação é sempre de
quatro espaços. O corpo pode conter qualquer número de comandos.


\index{reticências}

Se você fizer uma definição de função no modo interativo, o interpretador
usa reticências (*...*) para te informar que a definição não está completa:

~~~~ {.python}
>>> def print_LetraDeMusica():
...     print("Eu sou um lenhador, e eu estou bem.")
...     print('Eu durmo a noite toda e trabalho o dia todo.')
...
~~~~


Para finalizar a função, você precisa inserir uma linha em branco
(isso não é necessário no modo comum).

Definir uma função cria uma variável com o mesmo nome.

~~~~ {.python}
>>> print(print_LetraDeMusica)
<function print_ LetraDeMusica at 0xb7e99e9c>
>>> print(type(print_ LetraDeMusica))
<class 'function'>
~~~~

O valor da `print_LetraDeMusica` é um *objeto função*, o qual é do tipo
“function”.

\index{objeto função}
\index{objeto!função}

A sintaxe para chamar a nova função é a mesma que para funções internas:

~~~~ {.python}
>>> print_LetraDeMusica()
Eu sou um lenhador, e eu estou bem.
Eu durmo a noite toda e trabalho o dia todo.
~~~~

Uma vez que sua função está definida, você pode usá-la dentro de outra
função. Por exemplo, para repetir o refrão acima, nós poderíamos escrever
uma função chamada `repetir_LetraDeMusica`:

~~~~ {.python}
def repetir_LetraDeMusica():
    print_ LetraDeMusica()
    print_ LetraDeMusica()
~~~~

E depois chamar `repetir_LetraDeMusica`:

~~~~ {.python}
>>> repetir_LetraDeMusica()
Eu sou um lenhador, e eu estou bem.
Eu durmo a noite toda e trabalho o dia todo.
Eu sou um lenhador, e eu estou bem.
Eu durmo a noite toda e trabalho o dia todo.
~~~~

Mas não é bem assim que a música continua.

Definições e usos
--------------------

\index{definição de função}

Colocando junto os fragmentos de código da seção anterior, o programa
inteiro fica assim:

\VerbatimInput{../code3/lyrics.py}

Esse programa contém duas definições de função: `print_lyrics` e
`repeat_lyrics`. Definições de função são executadas assim como outras
declarações, mas o efeito é criar objetos de função. As declarações
dentro da função não são executadas até que a função seja chamada,
e a definição de função não gera saída.

\index{uso antes de def}

Como você deve imaginar, será necessário criar a função antes de poder
executá-la. Em outras palavras, a definição de função será executada
antes da primeira vez que seja chamada.

**Exercício 2: Mova a ultima linha desse programa para o início, assim a chamada
de função  aparece antes das definições. Execute o programa e veja
qual mensagem de erro aparece.**

**Exercício 3: Mova a chamada da função de volta ao final e mova a
definição de `print_lyrics` para depois da definição de `repeat_lyrics`.
O que acontece quando você executa esse programa?**

Fluxo de Execução
-----------------

\index{fluxo de execução}

Para garantir que a função é definida antes de seu primeiro uso, você
tem que saber a ordem que cada declaração é executada, o que é chamado
de *fluxo de execução*.

A execução sempre começa na primeira declaração do programa.
Declarações são executadas uma por vez, na ordem de cima para baixo.

*Definições* de função não alteram o fluxo da execução do
programa, mas lembram de que declarações dentro da função não são
executadas até que a função seja chamada.

Uma chamada de função é como um desvio no fluxo da execução. Em vez de
ir para a próxima declaração, o fluxo pula para o corpo da função,
executa todas as declarações ali, e então volta para onde
havia parado.

Isso parece bastante simples, até você lembrar que uma função pode chamar
outra. Enquanto estiver no meio de uma função, o programa pode ter que
executar as instruções em outra função. Então, enquanto estiver executando a nova
função, o programa pode ter que executar ainda outra função!

Felizmente, Python é bom em manter controle de onde está, então cada
vez que uma função é concluída o programa continua de onde parou na
função que o chamou. Quando chega ao fim do programa, se
encerra.

Qual é a moral desse conto sórdido? Quando você lê um programa, você nem
sempre quer lê-lo de cima para baixo. Às vezes faz mais sentido se
você seguir o fluxo de execução.

Parameters and arguments
------------------------

\index{parameter}
\index{function parameter}
\index{argument}
\index{function argument}

Some of the built-in functions we have seen require arguments. For
example, when you call `math.sin` you pass a number as an
argument. Some functions take more than one argument:
`math.pow` takes two, the base and the exponent.

Inside the function, the arguments are assigned to variables called
*parameters*. Here is an example of a user-defined
function that takes an argument:

\index{parentheses!parameters in}

~~~~ {.python}
def print_twice(bruce):
    print(bruce)
    print(bruce)
~~~~

This function assigns the argument to a parameter named
`bruce`. When the function is called, it prints the value of
the parameter (whatever it is) twice.

This function works with any value that can be printed.

~~~~ {.python}
>>> print_twice('Spam')
Spam
Spam
>>> print_twice(17)
17
17
>>> import math
>>> print_twice(math.pi)
3.141592653589793
3.141592653589793
~~~~

The same rules of composition that apply to built-in functions also
apply to user-defined functions, so we can use any kind of expression as
an argument for `print_twice`:

\index{composition}

~~~~ {.python}
>>> print_twice('Spam '*4)
Spam Spam Spam Spam
Spam Spam Spam Spam
>>> print_twice(math.cos(math.pi))
-1.0
-1.0
~~~~

The argument is evaluated before the function is called, so in the
examples the expressions `'Spam '*4` and `math.cos(math.pi)`
are only evaluated once.

\index{argument}

You can also use a variable as an argument:

~~~~ {.python}
>>> michael = 'Eric, the half a bee.'
>>> print_twice(michael)
Eric, the half a bee.
Eric, the half a bee.
~~~~

The name of the variable we pass as an argument (`michael`)
has nothing to do with the name of the parameter (`bruce`).
It doesn't matter what the value was called back home (in the caller);
here in `print_twice`, we call everybody `bruce`.

Fruitful functions and void functions
-------------------------------------

\index{fruitful function}
\index{void function}
\index{function, fruitful}
\index{function, void}

Some of the functions we are using, such as the math functions, yield
results; for lack of a better name, I call them *fruitful
functions*. Other functions, like `print_twice`, perform an
action but don't return a value. They are called *void
functions*.

When you call a fruitful function, you almost always want to do
something with the result; for example, you might assign it to a
variable or use it as part of an expression:

~~~~ {.python}
x = math.cos(radians)
golden = (math.sqrt(5) + 1) / 2
~~~~

When you call a function in interactive mode, Python displays the
result:

~~~~ {.python}
>>> math.sqrt(5)
2.23606797749979
~~~~

But in a script, if you call a fruitful function and do not store the
result of the function in a variable, the return value vanishes into the
mist!

~~~~ {.python}
math.sqrt(5)
~~~~

This script computes the square root of 5, but since it doesn't store
the result in a variable or display the result, it is not very useful.

\index{interactive mode}
\index{script mode}

Void functions might display something on the screen or have some other
effect, but they don't have a return value. If you try to assign the
result to a variable, you get a special value called `None`.

\index{None special value}
\index{special value!None}

~~~~ {.python}
>>> result = print_twice('Bing')
Bing
Bing
>>> print(result)
None
~~~~

The value `None` is not the same as the string "None". It
is a special value that has its own type:

~~~~ {.python}
>>> print(type(None))
<class 'NoneType'>
~~~~

To return a result from a function, we use the `return`
statement in our function. For example, we could make a very simple
function called `addtwo` that adds two numbers together and
returns a result.

\VerbatimInput{../code3/addtwo.py}

When this script executes, the `print` statement will print
out "8" because the `addtwo` function was called with 3 and 5
as arguments. Within the function, the parameters `a` and
`b` were 3 and 5 respectively. The function computed the sum
of the two numbers and placed it in the local function variable named
`added`. Then it used the `return` statement to
send the computed value back to the calling code as the function result,
which was assigned to the variable `x` and printed out.

Why functions?
--------------

\index{function, reasons for}

It may not be clear why it is worth the trouble to divide a program into
functions. There are several reasons:

-   Creating a new function gives you an opportunity to name a group of
    statements, which makes your program easier to read, understand, and
    debug.

-   Functions can make a program smaller by eliminating repetitive code.
    Later, if you make a change, you only have to make it in one place.

-   Dividing a long program into functions allows you to debug the parts
    one at a time and then assemble them into a working whole.

-   Well-designed functions are often useful for many programs. Once you
    write and debug one, you can reuse it.

Throughout the rest of the book, often we will use a function definition
to explain a concept. Part of the skill of creating and using functions
is to have a function properly capture an idea such as "find the
smallest value in a list of values". Later we will show you code that
finds the smallest in a list of values and we will present it to you as
a function named `min` which takes a list of values as its
argument and returns the smallest value in the list.

Debugging
---------

\index{debugging}

If you are using a text editor to write your scripts, you might run into
problems with spaces and tabs. The best way to avoid these problems is
to use spaces exclusively (no tabs). Most text editors that know about
Python do this by default, but some don't.

\index{whitespace}

Tabs and spaces are usually invisible, which makes them hard to debug,
so try to find an editor that manages indentation for you.

Also, don't forget to save your program before you run it. Some
development environments do this automatically, but some don't. In that
case, the program you are looking at in the text editor is not the same
as the program you are running.

Debugging can take a long time if you keep running the same incorrect
program over and over!

Make sure that the code you are looking at is the code you are running.
If you're not sure, put something like `print("hello")` at the beginning
of the program and run it again. If you don't see `hello`, you're not
running the right program!

Glossary
--------

algorithm
:   A general process for solving a category of problems.
\index{algorithm}

argument
:   A value provided to a function when the function is called. This
    value is assigned to the corresponding parameter in the function.
\index{argument}

body
:   The sequence of statements inside a function definition.
\index{body}

composition
:   Using an expression as part of a larger expression, or a statement
    as part of a larger statement.
\index{composition}

deterministic
:   Pertaining to a program that does the same thing each time it runs,
    given the same inputs.
\index{deterministic}

dot notation
:   The syntax for calling a function in another module by specifying
    the module name followed by a dot (period) and the function name.
\index{dot notation}

flow of execution
:   The order in which statements are executed during a program run.
\index{flow of execution}

fruitful function
:   A function that returns a value.
\index{fruitful function}

function
:   A named sequence of statements that performs some useful operation.
    Functions may or may not take arguments and may or may not produce a
    result.
\index{function}

function call
:   A statement that executes a function. It consists of the function
    name followed by an argument list.
\index{function call}

function definition
:   A statement that creates a new function, specifying its name,
    parameters, and the statements it executes.
\index{function definition}

function object
:   A value created by a function definition. The name of the function
    is a variable that refers to a function object.
\index{function definition}

header
:   The first line of a function definition.
\index{header}

import statement
:   A statement that reads a module file and creates a module object.
\index{import statement}
\index{statement!import}

module object
:   A value created by an `import` statement that provides
    access to the data and code defined in a module.
\index{module}

parameter
:   A name used inside a function to refer to the value passed as an
    argument.
\index{parameter}

pseudorandom
:   Pertaining to a sequence of numbers that appear to be random, but
    are generated by a deterministic program.
\index{pseudorandom}

return value
:   The result of a function. If a function call is used as an
    expression, the return value is the value of the expression.
\index{return value}

void function
:   A function that does not return a value.
\index{void function}

Exercícios
---------

**Exercício 4: Qual a finlaidade da palavra-chave "def" em Python**

a\)É uma gíria que significa "o código a seguir é muito maneiro"\
b) Ela indica o começo de uma função\
c) Ela indica que a próxima seção indentada do código será guardada para mais tarde\
d) b e c são verdade\
e) Nenhuma das opções anteriores

**Exercício 5: O que o programa em Python a seguir mostrará em tela?**

~~~~ {.python}
def fred():
   print("Zap")

def jane():
   print("ABC")

jane()
fred()
jane()
~~~~

a\) Zap ABC jane fred jane\
b) Zap ABC Zap\
c) ABC Zap jane\
d) ABC Zap ABC\
e) Zap Zap Zap

**Exercício 6: Reescreve seu programa de cálculo de pagamento com um 1.5 o valor de hora de trabalho por hora extracrie uma função chamada `calculoPagamento` que aceita dois parâmetros(`horas` e `TaxaHora`)**

Rewrite your pay computation with time-and-a-half for
overtime and create a function called `computepay` which
takes two parameters (`hours` and `rate`).**

~~~~
Insira as Horas: 45
Insira o valor da Hora de Trabalho: 10
Pay: 475.0
~~~~

**Exercício 7: Reescreva o programa de notas do capítulo anterior usando a função `computarNotas`que recebe a pontuação como um parâmetro e retorna a nota como uma string.**

~~~~
Pontuação   Nota
>= 0.9       A
>= 0.8       B
>= 0.7       C
>= 0.6       D
 < 0.6       F
~~~~

~~~~
Insira a pontuação: 0.95
A
~~~~

~~~~
Insira a pontuação: perfect
Pontuação Inválida
~~~~

~~~~
Insira a pontuação: 10.0
Pontuação Inválida
~~~~

~~~~
Insira a pontuação: 0.75
C
~~~~

~~~~
Insira a pontuação: 0.5
F
~~~~

Execute o programa repetitivamente para testar vários valores diferentes como entrada.

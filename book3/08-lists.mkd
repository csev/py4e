
Lists
=====

\index{list}
\index{type!list}

A list is a sequence
--------------------

Like a string, a *list* is a sequence of values. In a
string, the values are characters; in a list, they can be any type. The
values in list are called *elements* or sometimes
*items*.

\index{element}
\index{sequence}
\index{item}

There are several ways to create a new list; the simplest is to enclose
the elements in square brackets ("[" and "]"):

~~~~ {.python}
[10, 20, 30, 40]
['crunchy frog', 'ram bladder', 'lark vomit']
~~~~

The first example is a list of four integers. The second is a list of
three strings. The elements of a list don't have to be the same type.
The following list contains a string, a float, an integer, and (lo!)
another list:

~~~~ {.python}
['spam', 2.0, 5, [10, 20]]
~~~~ 

A list within another list is *nested*.

\index{nested list}
\index{list!nested}

A list that contains no elements is called an empty list; you can create
one with empty brackets, `[]`.

\index{empty list}
\index{list!empty}

As you might expect, you can assign list values to variables:

~~~~ {.python .trinket}
>>> cheeses = ['Cheddar', 'Edam', 'Gouda']
>>> numbers = [17, 123]
>>> empty = []
>>> print(cheeses, numbers, empty)
['Cheddar', 'Edam', 'Gouda'] [17, 123] []
~~~~

\index{assignment}

Lists are mutable
-----------------

\index{list!element}
\index{access}
\index{index}
\index{}
\index{bracket operator}
\index{operator!bracket}

The syntax for accessing the elements of a list is the same as for
accessing the characters of a string: the bracket operator. The
expression inside the brackets specifies the index. Remember that the
indices start at 0:

~~~~ {.python}
>>> print(cheeses[0])
Cheddar
~~~~

Unlike strings, lists are mutable because you can change the order of
items in a list or reassign an item in a list. When the bracket operator
appears on the left side of an assignment, it identifies the element of
the list that will be assigned.

\index{mutability}

~~~~ {.python .trinket}
>>> numbers = [17, 123]
>>> numbers[1] = 5
>>> print(numbers)
[17, 5]
~~~~

The one-th element of `numbers`, which used to be 123, is
now 5.

\index{index!starting at zero}
\index{zero, index starting at}

You can think of a list as a relationship between indices and elements.
This relationship is called a *mapping*; each index "maps
to" one of the elements.

\index{item assignment}
\index{assignment!item}

List indices work the same way as string indices:

-   Any integer expression can be used as an index.

-   If you try to read or write an element that does not exist, you get
    an `IndexError`.

\index{exception!IndexError}
\index{IndexError}

-   If an index has a negative value, it counts backward from the end of
    the list.

\index{list!index}
\index{list!membership}
\index{membership!list}
\index{in operator}
\index{operator!in}

The `in` operator also works on lists.

~~~~ {.python .trinket}
>>> cheeses = ['Cheddar', 'Edam', 'Gouda']
>>> 'Edam' in cheeses
True
>>> 'Brie' in cheeses
False
~~~~

Traversing a list
-----------------

\index{list!traversal}
\index{traversal!list}
\index{for loop}
\index{loop!for}
\index{statement!for}

The most common way to traverse the elements of a list is with a
`for` loop. The syntax is the same as for strings:

~~~~ {.python}
for cheese in cheeses:
    print(cheese)
~~~~

This works well if you only need to read the elements of the list. But
if you want to write or update the elements, you need the indices. A
common way to do that is to combine the functions `range` and
`len`:

\index{looping!with indices}
\index{index!looping with}

~~~~ {.python}
for i in range(len(numbers)):
    numbers[i] = numbers[i] * 2
~~~~

This loop traverses the list and updates each element. `len`
returns the number of elements in the list. `range` returns a
list of indices from 0 to $n-1$, where $n$ is the length of the list.
Each time through the loop, `i` gets the index of the next
element. The assignment statement in the body uses `i` to
read the old value of the element and to assign the new value.

\index{item update}
\index{update!item}

A `for` loop over an empty list never executes the body:

~~~~ {.python}
for x in empty:
    print('This never happens.')
~~~~

Although a list can contain another list, the nested list still counts
as a single element. The length of this list is four:

\index{nested list}
\index{list!nested}

~~~~ {.python}
['spam', 1, ['Brie', 'Roquefort', 'Pol le Veq'], [1, 2, 3]]
~~~~

Operações com Listas
---------------

\index{lista!operações}

O operador  `+` concatena listas:

\index{concatenação!lista}
\index{lista!concatenação}

~~~~ {.python .trinket}
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> c = a + b
>>> print(c)
[1, 2, 3, 4, 5, 6]
~~~~

Similarmente, o operador `*` repete uma lista um dado número de vezes:

\index{repetição!lista}
\index{lista!repetição}

~~~~ {.python .trinket}
>>> [0] * 4
[0, 0, 0, 0]
>>> [1, 2, 3] * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
~~~~

O primeiro exemplo repete quatro vezes. O segundo exemplo repete a lista três vezes.

Fatiamento de listas
-----------

\index{operador fatia}
\index{operador!fatia}
\index{índice!fatia}
\index{lista!fatia}
\index{fatia!lista}

O operador de fatiamento também funciona em listas:

~~~~ {.python .trinket}
>>> t = ['a', 'b', 'c', 'd', 'e', 'f']
>>> t[1:3]
['b', 'c']
>>> t[:4]
['a', 'b', 'c', 'd']
>>> t[3:]
['d', 'e', 'f']
~~~~

Se você omitir o primeiro índice, a fatia começará no início. Se você
omitir o segundo, a fatia vai até o final. Então se você omitir as duas, a
fatia é uma copia da lista inteira.

\index{lista!cópia}
\index{fatia!cópia}
\index{cópia!fatia}

~~~~ {.python}
>>> t[:]
['a', 'b', 'c', 'd', 'e', 'f']
~~~~

Como as listas são mutáveis, geralmente é útil fazer uma cópia antes
de realizar operações que dobram, spindle, ou mutila listas.

-----------------------------------
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*Não achei tradução para spindle*
-----------------------------------

\index{mutabilidade}

O operador de fatiamento no lado esquerdo de uma atribuição pode atualizar múltiplos
elementos:

\index{fatiamento!atualizar}
\index{atualizar!fatiamento}

~~~~ {.python .trinket}
>>> t = ['a', 'b', 'c', 'd', 'e', 'f']
>>> t[1:3] = ['x', 'y']
>>> print(t)
['a', 'x', 'y', 'd', 'e', 'f']
~~~~

Listar métodos 
------------

\index{lista!métodos}
\index{métodos, lista}

Python fornece metódos que operam em listas. Por exemplo,
`append` adiciona um novo element ao fim de uma lista:

\index{append método}
\index{método!append}

~~~~ {.python .trinket}
>>> t = ['a', 'b', 'c']
>>> t.append('d')
>>> print(t)
['a', 'b', 'c', 'd']
~~~~

`extend` leva uma lista como um argument e adiciona todos os
elementos:

\index{extend método}
\index{método!extend}

~~~~ {.python .trinket}
>>> t1 = ['a', 'b', 'c']
>>> t2 = ['d', 'e']
>>> t1.extend(t2)
>>> print(t1)
['a', 'b', 'c', 'd', 'e']
~~~~

Este exemplo deixa `t2` sem modificações.

`sort` organiza os elementos da lista de baixo para cima:

\index{sort método}
\index{método!sort}

~~~~ {.python .trinket}
>>> t = ['d', 'c', 'e', 'b', 'a']
>>> t.sort()
>>> print(t)
['a', 'b', 'c', 'd', 'e']
~~~~

A maioria de lista de métodos é vazia; elas modificam a lista e retornam
`None`. Se você acidentalmente escrever `t = t.sort()`,
você se desapontará com o resultado.

\index{vazio método}
\index{método!vazio}
\index{None valor especial}
\index{valor especial!None}

Apagando elementos
-----------------

\index{element deletion}
\index{deletion, element of list}

Existem vários jeitos de excluir elementos de uma lista. Se você sabe o
índice do elemento que você quer, você pode usar `pop`:

\index{pop method}
\index{method!pop}

~~~~ {.python .trinket}
>>> t = ['a', 'b', 'c']
>>> x = t.pop(1)
>>> print(t)
['a', 'c']
>>> print(x)
b
~~~~

`pop` modifica a lista e retorna o elemento que foi
removido. Se você não possui o índice, ele apaga e retorna o último
elemento.

Se você não precisa do valor removido, você pode usar o operador `del`:

\index{del operator}
\index{operator!del}

~~~~ {.python .trinket}
>>> t = ['a', 'b', 'c']
>>> del t[1]
>>> print(t)
['a', 'c']
~~~~

Se você sabe o elemento que quer remover (mas não o índice), você pode usar `remove`:

\index{remove method}
\index{method!remove}

~~~~ {.python .trinket}
>>> t = ['a', 'b', 'c']
>>> t.remove('b')
>>> print(t)
['a', 'c']
~~~~

O valor retornado de `remove` é `None`.

\index{None special value}
\index{special value!None}

Para remover mais de um elemento, você pode usar `del` com um
índice de fatia:

~~~~ {.python .trinket}
>>> t = ['a', 'b', 'c', 'd', 'e', 'f']
>>> del t[1:5]
>>> print(t)
['a', 'f']
~~~~

Como sempre, a fatia seleciona todos os elementos até, mas não inclui,
o segundo índice.

Listas e Funções
-------------------

Há várias funções que podem ser usadas em listas que permitem
que você examine rapidamente uma lista sem escrever seus próprios loops:

~~~~ {.python .trinket}
>>> nums = [3, 41, 12, 9, 74, 15]
>>> print(len(nums))
6
>>> print(max(nums))
74
>>> print(min(nums))
3
>>> print(sum(nums))
154
>>> print(sum(nums)/len(nums))
25
~~~~

A função `sum()` só funciona quando a lista de elementos são números. 
As outras funções (`max()`, `len()`,etc.)
funcionam com listas de strings e outros tipos que podem ser comparados.

Poderíamos  reescrever um programa anterior que calculasse a 
média de uma lista de números inseridos pelo usuário usando uma lista. 

Primeiramente, o programa calcula a média sem uma lista: 

\VerbatimInput{../code3/avenum.py}

Nesse programa, nós temos as variáveis `count` e `total`
para manter o número e a quantidade total de números de usuários, 
conforme solicitamos repetidamente ao usuário um número.

Nós podemos simplesmente lembrar cada número quando o usuário o inserisse 
e usar  funções internas para calcular a soma e contar no final.

\VerbatimInput{../code3/avelist.py}

Fazemos uma lista vazia antes  do  inicio do loop, e 
a cada vez que  tivermos um número,  o acrescentamos na lista.
No final do programa, nós simplesmente calculamos a soma dos 
números na lista e os dividimos pela contagem dos números na 
lista para chegar à média. 

Listas e Strings
-----------------

\index{list}
\index{string}
\index{sequence}

Uma string é uma sequência de caracteres e uma lista é uma sequência
de valores, mas uma lista de caracteres não é o mesmo que uma string. 
Para converter de uma string para uma lista de caracteres, você pode usar`list`:

\index{list!function}
\index{function!list}

~~~~ {.python .trinket}
>>> s = 'spam'
>>> t = list(s)
>>> print(t)
['s', 'p', 'a', 'm']
~~~~

Porque `list` é o nome de uma função interna, você deve evitar 
usá-la como nome de uma variável. Eu além disso evito usar “I” porque 
parece muito com o número “1”. Então é por isso que eu uso a letra "t".

A função `list` quebra uma string em letras individuais. 
Se você quer quebrar uma string em palavras, você pode usar o método 
`split`:

\index{split method}
\index{method!split}

~~~~ {.python .trinket}
>>> s = 'pining for the fjords'
>>> t = s.split()
>>> print(t)
['pining', 'for', 'the', 'fjords']
>>> print(t[2])
the
~~~~

Depois de você ter usado `split` para dividir a string em uma lista 
de palavras, você pode usar o operador de índices (colchete) para ver 
uma palavra particular da lista. 
Você pode chamar `split` com um argumento opcional chamado um
*delimiter* que especifica qual caractere usar como limites de palavras. 

\index{optional argument}
\index{argument!optional}
\index{delimiter}

~~~~ {.python .trinket}
>>> s = 'spam-spam-spam'
>>> delimiter = '-'
>>> s.split(delimiter)
['spam', 'spam', 'spam']
~~~~

`join` é o inverso de `split`. Ele pega uma lista de strings 
e concatena os elementos. `join`  é um método de string, então 
você tem que invocar isso no delimitador 
e passar a lista como um parâmetro. 

\index{join method}
\index{method!join}
\index{concatenation}

~~~~ {.python .trinket}
>>> t = ['pining', 'for', 'the', 'fjords']
>>> delimiter = ' '
>>> delimiter.join(t)
'pining for the fjords'
~~~~

 Nesse caso, o delimitador é um caractere de espaço, então `join`
 coloca um espaço entre as palavras. Para concatenar, strings sem espaços,
 você pode usar a  string, "",  como um delimitador.

\index{empty string}
\index{string!empty}

Linhas aliadas
-------------
Normalmente, quando estamos lendo um arquivo, queremos fazer algo com as linhas, além de apenas imprimir a linha inteira. Muitas vezes queremos encontrar as “linhas interessantes” e depois analisá-la para encontrar algo que seja interessante. E se quiséssemos imprimir o dia da semana a partir das linhas que começam com "De"?

~~~~
De stephen.marquard@uct.ac.za Sáb Jan  5 09:14:16 2008
~~~~

O método `split` é muito eficaz quando confrontado com este tipo de problema. Podemos escrever um pequeno programa que procura linhas que começam com "De", divide essas linhas e depois imprime as três primeiras letras:

\VerbatimInput{../code3/search5.py}
\begin{trinketfiles}
../code3/mbox-short.txt
\end{trinketfiles}

O programa produz a seguinte saída:

    Sáb
    Sex
    Sex
    Sex
    ...

Mais tarde, aprenderemos técnicas cada vez mais sofisticadas para escolher as linhas para trabalhar e como separá-las para encontrar a informação exata que estamos procurando.

Objetos e valores
------------------

\index{object}
\index{value}

Se nós executarmos estas instruções de atribuição:

~~~~ {.python}
a = 'banana'
b = 'banana'
~~~~

Sabemos que `a` e `a` se referem a uma string, mas não sabemos se eles se referem à *mesma* string. Existem dois estados possíveis:

\index{aliasing}

![Variables and Objects](height=0.5in@../images/list1)

Em um caso, `a` e `b` referem-se a dois objetos diferentes que possuem o mesmo valor. No segundo caso, eles se referem ao mesmo objeto.

\index{is operator}
\index{operator!is}

Para verificar se duas variáveis se referem ao mesmo objeto, você pode usar o operador `is`.


~~~~ {.python .trinket}
>>> a = 'banana'
>>> b = 'banana'
>>> a is b
True
~~~~

Neste exemplo, o Python criou apenas uma string objeto, e tanto `a` quanto `b` se referem a ele.

Mas quando você cria duas listas, você obtém dois objetos:

~~~~ {.python .trinket}
>>> a = [1, 2, 3]
>>> b = [1, 2, 3]
>>> a is b
False
~~~~

Nesse caso, diríamos que as duas listas são equivalentes, porque elas têm os mesmos elementos, mas não são idênticas, porque não são o mesmo objeto. Se dois objetos são idênticos, eles também são *equivalentes*, mas se forem equivalentes, eles não são necessariamente *idênticos*.

\index{equivalence}
\index{identity}

Até agora, temos usado “objeto” e “valor” de forma intercambiável, mas é mais preciso dizer que um objeto tem um valor. Se você executar `a = [1,2,3]`, onde `a`refere-se a uma lista de objetos cujo valor é uma sequência particular de elementos. Se outra lista tiver os mesmos elementos, diremos que ela tem o mesmo valor.

\index{object}
\index{value}

Aliado
--------

\index{aliasing}
\index{reference!aliasing}

Se `a` refere-se a um objeto e você atribui `b = a`, então ambas as variáveis referem-se ao mesmo objeto:

~~~~ {.python .trinket}
>>> a = [1, 2, 3]
>>> b = a
>>> b is a
True
~~~~

A associação de uma variável a um objeto é chamada de *referência*. Neste exemplo, existem duas referências ao mesmo objeto.

\index{reference}

Um objeto com mais de uma referência possui mais de um nome, então dizemos que o objeto é *aliado*.

\index{mutability}

Se o objeto aliado for mutável, as alterações feitas com um pseudônimo afetam o outro: 

~~~~ {.python}
>>> b[0] = 17
>>> print(a)
[17, 2, 3]
~~~~

Embora esse comportamento possa ser útil, é propenso a erros. Em geral, é mais seguro evitar o aliado quando você está trabalhando com objetos mutáveis.

\index{immutability}

Para objetos imutáveis como strings, o aliado não é um problema tão grande. Neste exemplo:

~~~~ {.python}
a = 'banana'
b = 'banana'
~~~~

quase nunca tem diferença se `a` e `b` irão se referir à mesma string ou não.


Listas como argumento
--------------

\index{list!as argument}
\index{argument}
\index{argument!list}
\index{reference}
\index{parameter}

Quando você passa uma lista como argumento de uma função, a função recebe uma referência dessa lista. Se a função modificar o parâmtro desta lista, o chamador verá a alteração. Por exemplo, remove_primeiro_elemento remove o primeiro elemento de uma lista:

~~~~ {.python}
def remove_primeiro_elemento(t)
	del t[0]
~~~~

Abaixo, é mostrado como ela é usada:

~~~~ {.python .trinket}
>>> letras = ['a', 'b', 'c']
>>> remove_primeiro_elemento(letras)
>>> print(letras)
['b', 'c']
~~~~

O parâmetro `t` e a variável `letras` são aliases para o mesmo objeto.

É importante distinguir entre operações que modificam listas e operações que criam novas listas. Por exemplo, o método `append` modifica a lista, porém o operador `+` cria uma nova lista:

\index{append method}
\index{method!append}
\index{list!concatenation}
\index{concatenation!list}

~~~~ {.python .trinket}
>>> t1 = [1, 2]
>>> t2 = t1.append(3)
>>> print(t1)
[1, 2, 3]
>>> print(t2)
None

>>> t3 = t1 + [3]
>>> print(t3)
[1, 2, 3]
>>> t2 is t3
False
~~~~

A diferença é importante quando você escreve funções que supostamente modificam listas. Por exemplo, a função *does not* remove o início de uma lista:

~~~~ {.python}
def errado_remove_primeiro_elemento(t)
	t = t[1:]               #ERRADO!
~~~~

O operador 'slice' cria uma nova lista e a atribuição faz com que `t` se refira a essa, mas nenhuma dessas atribuições tem qualquer efeito sobre a lista passada como referência.

\index{slice operator}
\index{operator!slice}

Uma alternativa é escrever uma função que cria e retorna uma nova lista. Por exemplo, `calda` retorna todos, menos o primeiro elemento da lista:

~~~~ {.python}
def calda(t):
    return t[1:]
~~~~

A função não modifica a lista original. Aqui é mostrado como é usada:

~~~~ {.python .trinket}
>>> letras = ['a', 'b', 'c']
>>> resto = tail(letras)
>>> print(resto)
['b', 'c']
~~~~

**Exercício 1: Escreva uma função chamada `corte` que recebe uma lista e a modifica, removendo o primeiro e o último elemento, e retorna `None`. Depois escreva uma função chamada `meio` que recebe uma lista e retorna uma nova lista que contém todos, menos o primeiro e o último elemento.**


Depuração
---------

\index{debugging}

Descuido com o uso de listas (e outros objetos mutáveis) pode levar a longa horas de depuração. Abaixo mostra algumas deslizes comuns e formas de evitá-las:

1. Não esqueça que a maioria do métodos de listas modifica o argumento e retorna  `None`. Isso é o oposto dos métodos das strings, que    retornam uma nova string e não modifica a string original. 

   Se você está acostumado a escrever código de string como este: 

    ~~~~ {.python}
    palavra.palavra.strip()
    ~~~~

   É tentador escrever um código de lista desta forma:

    ~~~~ {.python}
    t = t.sort()           # ERRADO!
    ~~~~

    \index{sort method}
    \index{method!sort}
    
   Como sort retorna None, a próxima operação que você executar com 't' provavelmente irá falhar.
    
    Antes de usar métodos de listas e operadores, você deve ler a documentação com cuidado e depois testar elas em um modo interativo. Os métodos e os operadores que as listas compartilham com outras sequência (como strings) são documentadas em:
    
    [docs.python.org/library/stdtypes.html#common-sequence-operations](https://docs.python.org/library/stdtypes.html#common-sequence-operations)
    
    Os métodos e operadores que são apenas aplicadas em sequências mutáveis são documentadas em:

    [docs.python.org/library/stdtypes.html#mutable-sequence-types](https://docs.python.org/library/stdtypes.html#mutable-sequence-types)

2.  Escolha um "idioma" e fique com ele.

    \index{idiom}
    Parte dos problemas, envolvendo listas, é que existem muitas maneiras para fazer coisas. Por exemplo, para remover um elemento de   uma lista, você pode usar o método `pop`, `remove`, `del`, ou simplesmente, utilizando a função `slice`.
    
    Para adicionar um elemento, você pode usar o método `append` ou o operador `+`. Porém, não esqueça que estas são as formas corretas de se fazer estes procedimentos:
    
    ~~~~ {.python}
    t.append(x)
    t = t + [x]
    ~~~~

    E essas, são as erradas:

    ~~~~ {.python}
    t.append([x])          # ERRADO!
    t = t.append(x)        # ERRADO!
    t + [x]                # ERRADO!
    t = t + x              # ERRADO!
    ~~~~
    
    Tente implementar esses exemplos em um modo interativo para ter certeza que você entende o que eles fazem. Note que apenas o último causa erro na compilação, os outros três são permitidos, porém não faz aquilo que é desejado.

3.  Faça cópias para evitar aliases.

    \index{aliasing!copying to avoid}
    \index{copy!to avoid aliasing}
    
    Se você quer usar o método 'sort' que modifica o argumento, porém também precisa manter a lista original intacta, você pode criar uma cópia.
 
    ~~~~ {.python}
    orig = t[:]
    t.sort()
    ~~~~
    Nesse exemplo, você também pode usar uma função existente chamada `sorted`, que retorna uma nova lista organizada e também mantém a  original intacta. Porém, nesse caso, você deve evitar usar `sorted` como um nome da variável!
   
4.  Listas, `split`, e arquivos
    
    Quando nós lemos e analisamos um arquivo, existem várias ocasiões em que a entrada pode causar falhas em nosso programa, então é uma boa ideia revisitar o padrão *guardião* quando se trata de escrever programas que lêem um arquivo e procuram por uma 'agulha no palheiro'.
    
    Vamos revisitar nosso programa que procura pelo dia da semana nas linhas de nosso arquivo:

    ~~~~
    From stephen.marquard@uct.ac.za Sat Jan  5 09:14:16 2008
    ~~~~
    
    Como estamos quebrando essa linha em palavras, nós podemos dispensar o uso do método `startswith` e simplesmente procurar pela primeira palavra que determina se estamos interessados, de fato, nessa linha. Nós podemos usar `continue` para pular linhas que não têm "From" como sua primeira palavra:
    
    ~~~~ {.python}
    fhand = open('mbox-short.txt')
    for linha in fhand:
        palavras = line.split()
        if palavras[0] != 'From' : continue
        print(palavras[2])
    ~~~~
    Isso parece ser bem mais simples, além que não precisamos do método `rstrip` para remover a quebra de linha no final do arquivo. Porém, qual o melhor?
   
    ~~~~
    python search8.py
    Sat
    Traceback (most recent call last):
        File "search8.py", line 5, in <module>
            if palavras[0] != 'From' : continue
    IndexError: list index out of range
    ~~~~
    Isso funciona e vemos o dia a partir da primeira linha (Sat), mas o programa falha com `traceback error`. Então, o que deu errado? Por quê o nosso elegante, inteligente e "Phytonic" programa falhou?
   
    Você poderia encarar seu programa por um longo tempo, quebrar a cabeça tentando decifrá-lo, ou simplesmente pode pedir a ajuda de alguém. Porém a abordagem mais rápida e inteligente é adicionar uma linha de código `print`. O melhor lugar para adicionar essa instrução é logo antes da linha em que o programa falhou e pôr para imprimir na tela o dado que está causando falha.

    Essa abordagem pode gerar várias linha na saída, pelo menos, você terá, imediatamente, várias pistas sobre o problema em questão. Então, adicionamos um `print` da variável `letras` logo depois da linha cinco. Nós até adicionamos o prefixo "Depuração:" na linha, para podermos manter nossa saída regular separadas de nossa saída depurada.
    
    ~~~~ {.python}
    for linha in fhand:
        palavras = linha.split()
        print('Depuração:', palavras)
        if palavras[0] != 'From' : continue
        print(palavras[2])
    ~~~~
    
    Quando compilamos o programa, várias saídas são impressas na tela, porém, no final, vemos nossa saída de depuração e o erro para sabermos o que aconteceu logo antes da mensagem de erro.
    
    ~~~~
    Debug: ['X-DSPAM-Confidence:', '0.8475']
    Debug: ['X-DSPAM-Probability:', '0.0000']
    Debug: []
    Traceback (most recent call last):
      File "search9.py", line 6, in <module>
        if words[0] != 'From' : continue
    IndexError: list index out of range
    ~~~~
    
    Cada linha de depuração imprime uma lista de palavras que obtemos quando dividimos a linha em palavras. Se o programa der erro, a lista de palavras é vazia `[]`. Se abrimos o arquivo em um editor de texto e olharmos o mesmo, ele será exibido da seguinte maneira:

    ~~~~
    X-DSPAM-Result: Innocent
    X-DSPAM-Processed: Sat Jan  5 09:14:16 2008
    X-DSPAM-Confidence: 0.8475
    X-DSPAM-Probability: 0.0000

    Details: http://source.sakaiproject.org/viewsvn/?view=rev&rev=39772
    ~~~~
    
    O erro ocorre quando nosso programa encontra uma linha em branco. Claro que não existem palavras em uma linha em branco. Por quê não pensamos nisso quando estávamos escrevendo o código? Quando o código procura pela primeira palavra (`palavras[0]`) para checar se bate com "From", nós temos um erro de índice fora de alcance ("index out of range").
    
    Obviamente, esse é um local perfeito para adicionarmos algum código *guardião* para evitar a checagem da primeira palavra caso a mesma não esteja lá. Existem várias formas de proteger nosso código; nós iremos escolher checar o número de palavras que temos antes de olhar para a primeira palavra:

    ~~~~ {.python}
    fhand = open('mbox-short.txt')
    contador = 0
    for linha in fhand:
        palavras = line.split()
        # print 'Debug:', words
        if len(palavras) == 0 : continue
        if palavras[0] != 'From' : continue
        print(palavras[2])

    ~~~~ 
    
    Primeiro, comentamos as linhas que imprimem a depuração, em vez de removê-las (caso nossa modificação falhe, e precisemos da depuração novamente). Depois, adicionamos uma declaração guardiã que checa se temos zero palavras, se sim, nós usamos "continue" para pular para próxima linha do arquivo.
    
    Podemos pensar nas duas declarações `continue` como um jeito de nos ajudar a refinar o conjunto de linhas que são interessantes para nós, e quais que queremos processar um pouco mais. Uma linha que não tem "From" como sua primeira palavra não é interessante para nós, então a pulamos.

    O programa modificado é executado com sucesso, então, talvez ele esteja correto. Nossa declaração guardiã nos dá a certeza que a `palavras[0]` nunca irá falhar, porém, talvez isso não seja suficiente. Quando estamos programando, nós devemos sempre estar pensando, "O que pode acontecer de errado?" 

**Exercício 2: Descubra qual linha do programa acima não está devidamente protegida. Veja se você pode construir um arquivo de texto que causa falha no programa e depois modifique o programa para que a linha seja propriamente protegida e por fim, teste o programa para ter certeza que ele manipula o novo arquivo de texto.**

**Exercício 3: Reescreva o código guardião nos exemplos acima sem duas declarações `if`. Em vez disso, use uma expressão lógica composta usando o operador lógico `and`, com uma única declaração `if`.**

Glossário
--------
aliase
: Circunstância onde duas ou mais variáveis se referem ao mesmo objeto.
\index{aliasing}

delimitador
: Caractere ou string usado para indicar onde a string deve ser dividida
\index{delimiter}

elemento
: Um dos valores em uma lista (ou outra sequência); também chamada de itens.
\index{element}

equivalente
: Ter o mesmo valor 
\index{equivalent}

índice
: Um valor inteiro que indica um elemento da lista
\index{index}\index{}

idêntico
: Ser o mesmo objeto (o que implica em equivalência)
\index{identical}

lista
: Uma sequência de valores
\index{list}

lista de passagem
: O acesso sequencial sobre cada elemento da lista
\index{list!transversal}

lista aninhada
: Uma lista que é um elemento de uma outra lista.
\index{nested list}

objeto
: Algo que uma variável pode se referir. Um objeto tem um tipo e um valor.
\index{object}

referência
: Associação entre variável e seu valor
\index{reference}

Exercícios
---------

\index{Romeo and Juliet}

**Exercicio 4: Baixe a copia do arquivo 
[**www.py4e.com/code3/romeo.txt**](http://www.py4e.com/code3/romeo.txt)**.
Escreva um programa para abrir o arquivo chamado romeo.txt e leia-o linha por linha. Para cada linha, separe-a em uma lista de palavras usando a função `split`. Para cada palavra, cheque se esta palavra já existe na lista. Caso não exista, adicione ela. Quando o programa terminar de verificar, ordene e imprima estas palavras em ordem alfabética.**

~~~~
Digite o nome do arquivo: romeo.txt
['Arise', 'But', 'It', 'Juliet', 'Who', 'already',
'and', 'breaks', 'east', 'envious', 'fair', 'grief',
'is', 'kill', 'light', 'moon', 'pale', 'sick', 'soft',
'sun', 'the', 'through', 'what', 'window',
'with', 'yonder']
~~~~

**Exercício 5: Escreva um programa que leia uma caixa de email, e quando você encontrar uma linha que comece com "From", você vai partir a linha em palavras usando a função `split`. Nós estamos interessados em quem envia a mensagem, o que é a segunda palavra na linha que começa com From.**

~~~~
From stephen.marquard@uct.ac.za Sat Jan 5 09:14:16 2008
~~~~

**Você vai analisar a linha que começa com From e irá pôr para imprimir na tela a segunda palavra (para cada linha do tipo) depois o programa também deverá contar o número de linhas que começam com From e imprimir em tela o valor final desse contador. Esse é um bom exemplo da saída com algumas linhas removidas:**

~~~~
python fromcount.py
Digite o nome do arquivo: mbox-short.txt
stephen.marquard@uct.ac.za
louis@media.berkeley.edu
zqian@umich.edu

[...some output removed...]

ray@media.berkeley.edu
cwen@iupui.edu
cwen@iupui.edu
cwen@iupui.edu
There were 27 lines in the file with From as the first word
~~~~

**Exercício 6: Reescreva o programa que solicita o usuário uma lista de números e que depois imprime em tela o maior número e o menor número quando o usuário digitar a palavra "feito". Escreva um programa para armazenar as entradas do usuário em uma lista e use as funções `max()` e `min()` para computar o número máximo e o mínimo depois que o loop for completo.**

~~~~
Digite um número: 6
Digite um número: 2
Digite um número: 9
Digite um número: 3
Digite um número: 5
Digite um número: feito
Maximo: 9.0
Minimo: 2.0
~~~~

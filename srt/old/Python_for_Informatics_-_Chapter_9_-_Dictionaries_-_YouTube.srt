1
00:00:00,000 --> 00:00:00,500

2
00:00:00,500 --> 00:00:05,020
Hello again, and welcome to
Chapter 9, Python dictionaries.

3
00:00:05,020 --> 00:00:08,520
As always this lecture is
copyright Creative Commons

4
00:00:08,520 --> 00:00:12,990
Attribution, that means the
audio, the video, the slides

5
00:00:12,990 --> 00:00:16,570
and even my scribbles you
can use in any way you like.

6
00:00:16,570 --> 00:00:17,850
As long as you attribute them.

7
00:00:17,850 --> 00:00:20,117
OK so, this is
the second chapter

8
00:00:20,117 --> 00:00:21,450
we're talking about collections.

9
00:00:21,450 --> 00:00:23,741
And the collections are kind
of like a piece of luggage

10
00:00:23,741 --> 00:00:27,890
in that you can put
multiple things in them.

11
00:00:27,890 --> 00:00:29,470
Variables that
we've talked about,

12
00:00:29,470 --> 00:00:32,479
sort of starting in chapter
two and chapter three,

13
00:00:32,479 --> 00:00:34,520
were simple variables.

14
00:00:34,520 --> 00:00:37,580
Scaler, they're just kind of
one thing and soon as you like,

15
00:00:37,580 --> 00:00:40,610
put another thing in there it
overwrites the first thing.

16
00:00:40,610 --> 00:00:46,810
So, if you look at the code
x equals 2 and x equals 4,

17
00:00:46,810 --> 00:00:51,220
the question is you know,
where did the two go?

18
00:00:51,220 --> 00:00:53,230
All right the two was
there, x was there,

19
00:00:53,230 --> 00:00:55,490
there was a two in there,
and then we cross it out

20
00:00:55,490 --> 00:00:56,720
and put four in there.

21
00:00:56,720 --> 00:00:59,180
This is sort of the basic
operation, the assignment

22
00:00:59,180 --> 00:01:01,210
statement it's a replacement.

23
00:01:01,210 --> 00:01:04,060
But a dictionary allows us to
put more than one thing, not

24
00:01:04,060 --> 00:01:06,140
using this syntax,
but it allows us

25
00:01:06,140 --> 00:01:09,380
to have a variable that's really
an aggregate of many values

26
00:01:09,380 --> 00:01:12,460
and the difference between
a list and a dictionary,

27
00:01:12,460 --> 00:01:16,080
is how the values are structured
within that single variable.

28
00:01:16,080 --> 00:01:19,820
The list is a linear collection
indexed by integers, zero, one,

29
00:01:19,820 --> 00:01:21,120
two, three.

30
00:01:21,120 --> 00:01:23,460
If there's five of them,
it's zero through four.

31
00:01:23,460 --> 00:01:25,396
Very much like a
Pringles can here,

32
00:01:25,396 --> 00:01:26,770
where they're just
stacked nicely

33
00:01:26,770 --> 00:01:30,880
on top of each other,
everything's kind of organized.

34
00:01:30,880 --> 00:01:32,730
We talked about in
the last lecture,

35
00:01:32,730 --> 00:01:35,660
this lecture we're talking
about dictionaries.

36
00:01:35,660 --> 00:01:39,220
Dictionaries' very powerful,
and it's power comes from

37
00:01:39,220 --> 00:01:42,170
a different way of
organizing itself internally.

38
00:01:42,170 --> 00:01:44,370
It's a bag of values,
like a, just a, sort of,

39
00:01:44,370 --> 00:01:48,200
just stuffs in it, it's not
in any order, big stuff,

40
00:01:48,200 --> 00:01:50,729
little stuff,
things have labels.

41
00:01:50,729 --> 00:01:53,020
You can also think of it like
a purse, with just things

42
00:01:53,020 --> 00:01:55,480
and it's like, it's
not like stacked,

43
00:01:55,480 --> 00:01:57,690
it's just stuff moves
around as you're going.

44
00:01:57,690 --> 00:02:01,560
And that's a very good
model for dictionaries.

45
00:02:01,560 --> 00:02:05,230
And so dictionaries have to have
a label, because the stuff is

46
00:02:05,230 --> 00:02:05,930
not an order.

47
00:02:05,930 --> 00:02:07,920
There's no such thing
as the third thing.

48
00:02:07,920 --> 00:02:10,066
There is the thing
with a label perfume.

49
00:02:10,066 --> 00:02:11,690
There's the thing
with the label candy,

50
00:02:11,690 --> 00:02:14,080
there's the thing
with the label money.

51
00:02:14,080 --> 00:02:17,520
And so there's the value, the
thing, the money, and then

52
00:02:17,520 --> 00:02:19,410
there's always also the label.

53
00:02:19,410 --> 00:02:24,800
We also call these key value.

54
00:02:24,800 --> 00:02:29,090
The key is the label, and
the value is whatever.

55
00:02:29,090 --> 00:02:31,890
And so these pink things are
all labels for various things

56
00:02:31,890 --> 00:02:35,110
that you could put in the purse,
so you could say to your purse,

57
00:02:35,110 --> 00:02:38,480
hey purse give me my tissues,
hey purse give me my money

58
00:02:38,480 --> 00:02:41,510
and it's in there somewhere
and the purse sort of gives you

59
00:02:41,510 --> 00:02:44,300
back the tissues or the money.

60
00:02:44,300 --> 00:02:48,246
And it's-- Python's most
powerful data collection is

61
00:02:48,246 --> 00:02:48,870
the dictionary.

62
00:02:48,870 --> 00:02:51,827
And when you get used
to wielding them,

63
00:02:51,827 --> 00:02:54,160
you'll say like whoa I can
do so much with these things.

64
00:02:54,160 --> 00:02:56,480
And at the beginning you're
just sort of learning,

65
00:02:56,480 --> 00:02:59,417
sort of how to use them
without hurting yourself.

66
00:02:59,417 --> 00:03:00,500
But they're very powerful.

67
00:03:00,500 --> 00:03:01,870
It's like a database.

68
00:03:01,870 --> 00:03:05,870
It allows you to store very
arbitrary data organized

69
00:03:05,870 --> 00:03:08,020
in however you feel
like organizing it,

70
00:03:08,020 --> 00:03:10,661
in a way that advances the
cause the program that you're

71
00:03:10,661 --> 00:03:11,160
writing.

72
00:03:11,160 --> 00:03:13,160
We're still kind of
at the very beginning,

73
00:03:13,160 --> 00:03:16,790
but as you learn more,
these will become

74
00:03:16,790 --> 00:03:20,770
a very powerful tool for you.

75
00:03:20,770 --> 00:03:24,680
Dictionaries have different
names in different languages.

76
00:03:24,680 --> 00:03:28,920
Perl or Php would call
them Associative Arrays,

77
00:03:28,920 --> 00:03:32,010
Java would call them a
Property Map or a HashMap,

78
00:03:32,010 --> 00:03:34,930
and C# might call them a
Property Bag or an Attribute

79
00:03:34,930 --> 00:03:35,430
Bag.

80
00:03:35,430 --> 00:03:38,100
And so they're just
the same concept,

81
00:03:38,100 --> 00:03:40,620
it's keys and values
is the concept,

82
00:03:40,620 --> 00:03:42,560
that's across all
these languages, just

83
00:03:42,560 --> 00:03:43,657
a very powerful one.

84
00:03:43,657 --> 00:03:45,990
And if you look at the Wikipedia
entry that I have here,

85
00:03:45,990 --> 00:03:48,424
you can see that it's
just, it's a concept

86
00:03:48,424 --> 00:03:50,590
that we give different names
in different languages.

87
00:03:50,590 --> 00:03:54,130
Same concept, different names.

88
00:03:54,130 --> 00:03:56,200
So like I said, the
difference between a list

89
00:03:56,200 --> 00:03:59,560
and a dictionary, they both
can store multiple values.

90
00:03:59,560 --> 00:04:02,030
The question is how we label
them, how we store them,

91
00:04:02,030 --> 00:04:03,250
and how we retrieve them.

92
00:04:03,250 --> 00:04:05,630
So here's an example
use of a dictionary.

93
00:04:05,630 --> 00:04:07,370
I'm going to make a
thing called purse,

94
00:04:07,370 --> 00:04:09,320
and I'm going to
store in purse, this

95
00:04:09,320 --> 00:04:12,830
is an assignment statement,
purse sub money so this isn't

96
00:04:12,830 --> 00:04:15,100
like sub zero, this is money.

97
00:04:15,100 --> 00:04:18,200
So I'm actually using
a string as the place.

98
00:04:18,200 --> 00:04:21,029
And so I'm going to say
stick 12 in my purse,

99
00:04:21,029 --> 00:04:25,630
and stick us posted note,
that's my money, candy is three,

100
00:04:25,630 --> 00:04:27,290
tissues is 75.

101
00:04:27,290 --> 00:04:31,260
And if I look at that, it's not
just the numbers 12, 3 and 75

102
00:04:31,260 --> 00:04:36,460
as it would be in a list, it
is the connection between money

103
00:04:36,460 --> 00:04:40,150
and 12, tissues is
75, candy is three.

104
00:04:40,150 --> 00:04:42,960
And in the key value, that's
the key and that's the value.

105
00:04:42,960 --> 00:04:47,580
So candy is the key,
and three is the value.

106
00:04:47,580 --> 00:04:51,390
Now I can look things up by
their name, print purse sub

107
00:04:51,390 --> 00:04:51,890
candy.

108
00:04:51,890 --> 00:04:56,580
Well goes finds it, asking
hey purse give me that candy,

109
00:04:56,580 --> 00:04:59,690
and it goes and finds the
value which is three and so

110
00:04:59,690 --> 00:05:01,630
outcomes a three.

111
00:05:01,630 --> 00:05:04,480
We can also put it on the right
hand side of an assignment

112
00:05:04,480 --> 00:05:04,980
statement.

113
00:05:04,980 --> 00:05:08,550
So purse of candy says give
me the old version of candy,

114
00:05:08,550 --> 00:05:11,340
and then add two to
it, which gives me 5.

115
00:05:11,340 --> 00:05:15,900
And then store it back in that
purse, under the label candy.

116
00:05:15,900 --> 00:05:18,470
So we see candy
changing to five.

117
00:05:18,470 --> 00:05:22,041
And so, this is a place, and
you could do this with a list

118
00:05:22,041 --> 00:05:23,290
except these would be numbers.

119
00:05:23,290 --> 00:05:26,360
You could say purse sub
2 is equal to purse sub

120
00:05:26,360 --> 00:05:28,500
2 plus 2 or whatever.

121
00:05:28,500 --> 00:05:31,540
But in dictionaries,
there are labels.

122
00:05:31,540 --> 00:05:32,940
Now they're not strings.

123
00:05:32,940 --> 00:05:35,140
Strings is a very common
label in dictionaries,

124
00:05:35,140 --> 00:05:36,310
but it's not always strings.

125
00:05:36,310 --> 00:05:37,510
You can use other things.

126
00:05:37,510 --> 00:05:39,930
In this chapter we'll pretty
much focus on strings.

127
00:05:39,930 --> 00:05:42,100
You could even use
numbers and then you

128
00:05:42,100 --> 00:05:44,940
would get a little
confused, but you can.

129
00:05:44,940 --> 00:05:48,240
So here's sort of a
picture of how this works.

130
00:05:48,240 --> 00:05:53,000
So if we take a look at this
line purse sub money equals 12,

131
00:05:53,000 --> 00:05:56,360
it's like we are putting
a key value connection,

132
00:05:56,360 --> 00:06:00,690
money is the label for 12, and
then we sort of move that n.

133
00:06:00,690 --> 00:06:04,330
And it's up to the purse
to decide m things live.

134
00:06:04,330 --> 00:06:06,800
If we look at the
next line, we're

135
00:06:06,800 --> 00:06:11,290
going to put the value n three
with n with the label candy,

136
00:06:11,290 --> 00:06:14,490
and we're going to put the value
75 in with a label of tissues.

137
00:06:14,490 --> 00:06:17,270
And when we say hey
purse print yourself out,

138
00:06:17,270 --> 00:06:19,630
it just goes and pulls
these things back out

139
00:06:19,630 --> 00:06:20,790
and hands them to her.

140
00:06:20,790 --> 00:06:22,290
And what it's really,
it's giving us

141
00:06:22,290 --> 00:06:23,728
both the label and the value.

142
00:06:23,728 --> 00:06:25,853
And it's necessary to do
that, because there's just

143
00:06:25,853 --> 00:06:29,090
12, 75 and three,
what exactly is that?

144
00:06:29,090 --> 00:06:31,460
And so this syntax
with the curly braces

145
00:06:31,460 --> 00:06:34,880
is what happens when you
print a dictionary out.

146
00:06:34,880 --> 00:06:37,630
The same thing happens when
we're sort of printing purse

147
00:06:37,630 --> 00:06:38,650
sub candy.

148
00:06:38,650 --> 00:06:39,390
Right?

149
00:06:39,390 --> 00:06:43,520
Purse sub candy, it's
like, you're first,

150
00:06:43,520 --> 00:06:45,870
go and find the candy
thing, look at that one,

151
00:06:45,870 --> 00:06:48,340
look at that one, oh
yep yep this is candy.

152
00:06:48,340 --> 00:06:50,200
But what we're looking
for is the value,

153
00:06:50,200 --> 00:06:52,580
and so that's why three
is coming up here.

154
00:06:52,580 --> 00:06:55,080
So go look up under
candy and tell me

155
00:06:55,080 --> 00:06:57,242
what's stored under candy.

156
00:06:57,242 --> 00:06:58,950
These can be actually
more complex things

157
00:06:58,950 --> 00:07:02,880
and I'm just keeping it
simple for this lecture.

158
00:07:02,880 --> 00:07:06,050
And then when we say purse
sub candy equals purse sub

159
00:07:06,050 --> 00:07:08,540
candy plus 2, well
it pulls the three

160
00:07:08,540 --> 00:07:13,650
out looking at the label
candy, then adds 3 plus 2

161
00:07:13,650 --> 00:07:16,940
and makes five, and then
it assigns it back in.

162
00:07:16,940 --> 00:07:19,460
And then that says oh
go go place this number

163
00:07:19,460 --> 00:07:22,930
five in the purse with
the label of candy,

164
00:07:22,930 --> 00:07:26,460
which then replaces
the three with a five.

165
00:07:26,460 --> 00:07:29,570
OK and if we print
it out, we see

166
00:07:29,570 --> 00:07:35,390
that the new variable, or the
new candy entry is now five.

167
00:07:35,390 --> 00:07:36,880
OK?

168
00:07:36,880 --> 00:07:40,470
So if we just sort of put
these things side by side,

169
00:07:40,470 --> 00:07:42,340
we create them sort
of both the same way

170
00:07:42,340 --> 00:07:44,960
and we make an empty
list an empty dictionary.

171
00:07:44,960 --> 00:07:47,670
We call the append method
because we're sort of just

172
00:07:47,670 --> 00:07:48,980
putting these things in order.

173
00:07:48,980 --> 00:07:50,700
You've got to put the
first one in first.

174
00:07:50,700 --> 00:07:53,120
So it's not telling you
where, you kind of know

175
00:07:53,120 --> 00:07:54,300
that this would be the
first one because you're

176
00:07:54,300 --> 00:07:56,800
starting with an empty one, and
this will be the second one.

177
00:07:56,800 --> 00:08:00,120
We put in the values 21 and
183 and then we print it out

178
00:08:00,120 --> 00:08:03,320
and it's like OK, you gave
me the value as 21 and 183.

179
00:08:03,320 --> 00:08:05,600
I will maintain
the order for you,

180
00:08:05,600 --> 00:08:07,700
there's no keys other
than their position.

181
00:08:07,700 --> 00:08:10,330
Position is the key, as it were.

182
00:08:10,330 --> 00:08:12,620
If I want to change
the first one to 23,

183
00:08:12,620 --> 00:08:15,510
well, I say lists of
zero which is this,

184
00:08:15,510 --> 00:08:16,890
and then change that to 23.

185
00:08:16,890 --> 00:08:20,354
So this is sort of used as
a look up to find something.

186
00:08:20,354 --> 00:08:22,770
Can be used on either the right
hand side or the left hand

187
00:08:22,770 --> 00:08:24,370
side of the science statement.

188
00:08:24,370 --> 00:08:27,710
Comparing that to dictionaries,
I want to put a 21 in there

189
00:08:27,710 --> 00:08:30,160
and I'm going to put
it with the label age,

190
00:08:30,160 --> 00:08:33,530
and put 182, put that in
with the label course.

191
00:08:33,530 --> 00:08:36,440
So, so we don't have
to like make an entry.

192
00:08:36,440 --> 00:08:39,850
The fact that the entry doesn't
exist, it creates the age entry

193
00:08:39,850 --> 00:08:41,289
and sticks 21 into it.

194
00:08:41,289 --> 00:08:44,700
Creates the course entry,
sticks 182 into it,

195
00:08:44,700 --> 00:08:48,240
we print it out and says, oh
course is 182 and age is 21.

196
00:08:48,240 --> 00:08:54,720
This emphasizes that order is
not preserved in dictionaries.

197
00:08:54,720 --> 00:08:57,054

198
00:08:57,054 --> 00:08:58,720
I'm won't go in that
I like great detail

199
00:08:58,720 --> 00:08:59,800
as to why that it is.

200
00:08:59,800 --> 00:09:01,570
It turns out that
that's a compromise that

201
00:09:01,570 --> 00:09:03,060
makes them fast.

202
00:09:03,060 --> 00:09:04,530
Using a technique
called hashing.

203
00:09:04,530 --> 00:09:06,740
It's how it's actually
works internally

204
00:09:06,740 --> 00:09:09,600
go to Wikipedia hashing
and take a look,

205
00:09:09,600 --> 00:09:14,040
but the thing that matters to
us as programmers primarily

206
00:09:14,040 --> 00:09:18,640
is that lists maintain
order and dictionaries

207
00:09:18,640 --> 00:09:21,040
do not maintain order.

208
00:09:21,040 --> 00:09:23,090
Dictionaries give
us power that we

209
00:09:23,090 --> 00:09:25,597
don't have unless, I mean
they're very complimentary.

210
00:09:25,597 --> 00:09:27,680
There's not this one that's
better than the other,

211
00:09:27,680 --> 00:09:28,804
they're very complimentary.

212
00:09:28,804 --> 00:09:31,130
Different kinds of data is
either better represented

213
00:09:31,130 --> 00:09:32,980
as a list or as a
dictionary depending

214
00:09:32,980 --> 00:09:34,830
on the problem trying to solve.

215
00:09:34,830 --> 00:09:36,990
And in a moment,
we'll be writing

216
00:09:36,990 --> 00:09:38,840
programs that are using both.

217
00:09:38,840 --> 00:09:42,430
So if we come down here
and I say OK stick 23

218
00:09:42,430 --> 00:09:47,270
into assignment statement,
into ddd sub age,

219
00:09:47,270 --> 00:09:51,190
well that will change this
21 to 23, so we print it out.

220
00:09:51,190 --> 00:09:54,320
So you can, this part where you
look something up and change

221
00:09:54,320 --> 00:09:56,110
the value, you
can do either way,

222
00:09:56,110 --> 00:10:00,040
it's just how you do it here
is a little bit different.

223
00:10:00,040 --> 00:10:01,640
OK.

224
00:10:01,640 --> 00:10:03,840
So let's look through
this code again.

225
00:10:03,840 --> 00:10:07,000
And so, I like to use
the word key and value.

226
00:10:07,000 --> 00:10:09,670
Key is the way we look
the thing up in a list,

227
00:10:09,670 --> 00:10:13,951
keys are numbers starting
at 0 and with no gaps.

228
00:10:13,951 --> 00:10:16,200
In dictionaries, keys are
whatever we want them to be,

229
00:10:16,200 --> 00:10:18,100
in this case I'm using strings.

230
00:10:18,100 --> 00:10:20,410
And then the value is the
number we're storing in it.

231
00:10:20,410 --> 00:10:25,960
So we create this kind of a list
with those kinds of statements,

232
00:10:25,960 --> 00:10:28,530
this statement creates
this kind of a thing.

233
00:10:28,530 --> 00:10:32,340
Now if we think of this
assignment statement

234
00:10:32,340 --> 00:10:36,690
as moving data into a new, into
a place, a new item of data

235
00:10:36,690 --> 00:10:43,550
into a place, it's looking
at this thing right here.

236
00:10:43,550 --> 00:10:45,360
It's like that's where
I want to move it

237
00:10:45,360 --> 00:10:48,240
and so it hunts and
says look the key up

238
00:10:48,240 --> 00:10:50,180
and that's the one that
I'm going to change,

239
00:10:50,180 --> 00:10:52,445
and then once it knows which
it's going to change then

240
00:10:52,445 --> 00:10:54,340
it's going to take
the 23, then it's

241
00:10:54,340 --> 00:10:57,200
going to put the 23
into that location.

242
00:10:57,200 --> 00:11:01,280
And so that's how this
changes from that to that.

243
00:11:01,280 --> 00:11:04,400
Similarly when we
get down to here,

244
00:11:04,400 --> 00:11:06,420
we're going to
stick 23 somewhere

245
00:11:06,420 --> 00:11:09,560
and this expression,
this look up expression,

246
00:11:09,560 --> 00:11:11,980
the index expression,
dd sub age,

247
00:11:11,980 --> 00:11:13,420
is where we're going to put it.

248
00:11:13,420 --> 00:11:16,470
So we're looking here,
where is that thing.

249
00:11:16,470 --> 00:11:21,270
Well that thing is this
entry in the dictionary,

250
00:11:21,270 --> 00:11:23,270
and so now we're
going to store the 23,

251
00:11:23,270 --> 00:11:25,070
we know where the
23 is going to go,

252
00:11:25,070 --> 00:11:27,505
it's going to overwrite
the 21 and so the 21

253
00:11:27,505 --> 00:11:29,070
is going to change to 23.

254
00:11:29,070 --> 00:11:29,570
OK.

255
00:11:29,570 --> 00:11:32,070
So so they're kind
of similar, there

256
00:11:32,070 --> 00:11:34,210
are things that
work similar in them

257
00:11:34,210 --> 00:11:37,560
and then there are things
that work differently in them.

258
00:11:37,560 --> 00:11:42,020
We can make literals,
constants, with the curly braces

259
00:11:42,020 --> 00:11:43,450
and they look just
like the print.

260
00:11:43,450 --> 00:11:44,908
That's one nice
thing about Python,

261
00:11:44,908 --> 00:11:46,410
when you print
something out, it's

262
00:11:46,410 --> 00:11:48,620
showing you how you
can make a literal

263
00:11:48,620 --> 00:11:51,340
and basically you just
open with a curly brace

264
00:11:51,340 --> 00:11:56,150
and say chuck colon
one, Fred 42, Jan 100

265
00:11:56,150 --> 00:11:58,140
and we're making connections.

266
00:11:58,140 --> 00:12:00,580
Key value pair, key value pair.

267
00:12:00,580 --> 00:12:05,782
We print it out and no order,
they don't maintain order.

268
00:12:05,782 --> 00:12:07,490
Now that might come
out in the same order

269
00:12:07,490 --> 00:12:08,760
but that's just lucky.

270
00:12:08,760 --> 00:12:10,120
Right, all the ones
I've shown you so far,

271
00:12:10,120 --> 00:12:11,495
don't come out in
the same order,

272
00:12:11,495 --> 00:12:12,650
which is good demonstrated.

273
00:12:12,650 --> 00:12:15,020
If it one time came out
in the same order, that

274
00:12:15,020 --> 00:12:17,180
wouldn't be broken,
it's not like it doesn't

275
00:12:17,180 --> 00:12:19,550
want to come out in the
same order, it's just,

276
00:12:19,550 --> 00:12:21,690
it's not internally stored.

277
00:12:21,690 --> 00:12:25,129
And you add an element
and it may reorder them.

278
00:12:25,129 --> 00:12:27,670
You can do an empty dictionary
with just a curly brace, curly

279
00:12:27,670 --> 00:12:28,170
brace.

280
00:12:28,170 --> 00:12:33,440

281
00:12:33,440 --> 00:12:37,490
So, I'm going to give
you another example.

282
00:12:37,490 --> 00:12:40,880
And I'm going to show
you a series of names,

283
00:12:40,880 --> 00:12:45,660
and I want you to figure out
what the most common name is,

284
00:12:45,660 --> 00:12:48,270
and how many times
each name appears.

285
00:12:48,270 --> 00:12:49,930
Now these are real
people that actually

286
00:12:49,930 --> 00:12:55,830
work on the Sakai project,
Stephen, Zhen, and Chen,

287
00:12:55,830 --> 00:12:56,660
and me.

288
00:12:56,660 --> 00:12:59,050
So these are people that
are actually in the data

289
00:12:59,050 --> 00:13:00,700
that we use in this course.

290
00:13:00,700 --> 00:13:04,400
OK and so I think I'll
show you about 15 names,

291
00:13:04,400 --> 00:13:06,717
and you're to come
up with a way,

292
00:13:06,717 --> 00:13:08,550
I'm going to show them
to you one at a time.

293
00:13:08,550 --> 00:13:11,350
You need to come up with a
way to keep track of these.

294
00:13:11,350 --> 00:13:12,390
OK?

295
00:13:12,390 --> 00:13:15,370
So I'll just with no further
ado, I will show you the names.

296
00:13:15,370 --> 00:13:53,860

297
00:13:53,860 --> 00:13:56,230
OK so that's all the names.

298
00:13:56,230 --> 00:13:57,630
Did you get it?

299
00:13:57,630 --> 00:14:00,960
You might have to go
back and do it again.

300
00:14:00,960 --> 00:14:05,650
How did you solve the problem,
what kind of a data structure

301
00:14:05,650 --> 00:14:09,340
did you build to solve the
problem or did you just say,

302
00:14:09,340 --> 00:14:12,440
wow that's painful, I think
I will learn Python instead

303
00:14:12,440 --> 00:14:15,530
in solving that problem.

304
00:14:15,530 --> 00:14:20,730
So pause the video if
you want and write down,

305
00:14:20,730 --> 00:14:23,120
or go back write
down what you think

306
00:14:23,120 --> 00:14:30,210
the number of the most common
name is and how many times.

307
00:14:30,210 --> 00:14:32,050
OK now I'll show you.

308
00:14:32,050 --> 00:14:34,460
So here is the whole list.

309
00:14:34,460 --> 00:14:35,670
It's all of them.

310
00:14:35,670 --> 00:14:39,080
And now that we see all of them,
we use our amazing human mind

311
00:14:39,080 --> 00:14:42,750
and we scan around and look at
purpleness and all that stuff,

312
00:14:42,750 --> 00:14:45,390
and then we go like, oh this is
a so much easier problem when

313
00:14:45,390 --> 00:14:48,050
I'm looking at the whole thing.

314
00:14:48,050 --> 00:14:53,885
And I think that the most
common person is Zhen,

315
00:14:53,885 --> 00:15:00,750
and I think we see Zhen, I
think we see Zhen five times,

316
00:15:00,750 --> 00:15:03,740
and I think Csev
is one, two three,

317
00:15:03,740 --> 00:15:07,580
and Cwen is one, two,
and Stephen Marquard

318
00:15:07,580 --> 00:15:09,260
is one, two, three.

319
00:15:09,260 --> 00:15:11,552
So the question is what is
an effective data structure,

320
00:15:11,552 --> 00:15:13,301
if you're going to see
a million of these?

321
00:15:13,301 --> 00:15:15,580
What kind of data structure
would you have to produce,

322
00:15:15,580 --> 00:15:17,205
because you can't
keep it in your head?

323
00:15:17,205 --> 00:15:20,207
Even this number of people,
you can't, even this amount

324
00:15:20,207 --> 00:15:22,040
of data no way you can
keep it in your head.

325
00:15:22,040 --> 00:15:26,070
You have to come up with some
kind of a variable as it were,

326
00:15:26,070 --> 00:15:28,210
just like largest so
far was a variable.

327
00:15:28,210 --> 00:15:29,720
Some kind of variable
that gets you

328
00:15:29,720 --> 00:15:32,290
to the point where you
understand what's going on.

329
00:15:32,290 --> 00:15:34,640
And so this is the
most common technique

330
00:15:34,640 --> 00:15:37,100
to solve this problem,
where you keep a running

331
00:15:37,100 --> 00:15:39,110
total of each of the names.

332
00:15:39,110 --> 00:15:42,500
And if you see a new name,
you add them to the list.

333
00:15:42,500 --> 00:15:46,205
So Csev and then you give him
a one, and then you see Zhen

334
00:15:46,205 --> 00:15:48,170
and you give her a one
and then you see Chen

335
00:15:48,170 --> 00:15:51,080
and you give her a one,
and then you see Csev again

336
00:15:51,080 --> 00:15:54,090
and you give him a two, and
you see and a two, and a two,

337
00:15:54,090 --> 00:15:57,020
and a one right?

338
00:15:57,020 --> 00:15:58,690
And so then when
you're all done,

339
00:15:58,690 --> 00:16:02,790
you have the mapping,
right of these things

340
00:16:02,790 --> 00:16:04,570
and you go OK let
me look through here

341
00:16:04,570 --> 00:16:07,230
and find the largest one,
that's the largest one,

342
00:16:07,230 --> 00:16:09,970
so that must be the
person who is the most.

343
00:16:09,970 --> 00:16:12,720
So you need a scratch
area, a data structure

344
00:16:12,720 --> 00:16:16,580
or a piece of paper as it
were, and so that's what,

345
00:16:16,580 --> 00:16:19,630
exactly what dictionaries
are really good at.

346
00:16:19,630 --> 00:16:23,220
You could think of this
as like a histogram.

347
00:16:23,220 --> 00:16:25,500
You know it's a
bunch of counters,

348
00:16:25,500 --> 00:16:27,850
but counters that are
indexed by a string.

349
00:16:27,850 --> 00:16:29,580
So we use a lot of this.

350
00:16:29,580 --> 00:16:32,610
And so this is a pattern of
many counters with a dictionary.

351
00:16:32,610 --> 00:16:33,660
Simultaneous counters.

352
00:16:33,660 --> 00:16:35,160
Were counting a
bunch of-- they were

353
00:16:35,160 --> 00:16:36,810
looking at a series
of things and we're

354
00:16:36,810 --> 00:16:39,440
going to simultaneously
keep track

355
00:16:39,440 --> 00:16:42,560
of a large number of counters,
rather than just one counter.

356
00:16:42,560 --> 00:16:44,970
How many names you
see total whatever,

357
00:16:44,970 --> 00:16:47,550
12, but how many of
each name did you see

358
00:16:47,550 --> 00:16:48,795
is a bunch of counters.

359
00:16:48,795 --> 00:16:51,840
So it's a bunch of
simultaneous counters.

360
00:16:51,840 --> 00:16:55,030
So a dictionary
is great for this,

361
00:16:55,030 --> 00:16:56,860
dictionary is great for this.

362
00:16:56,860 --> 00:16:58,870
When we see somebody
for the first time,

363
00:16:58,870 --> 00:17:00,490
we can add an entry
to the dictionary,

364
00:17:00,490 --> 00:17:06,280
which is kind of like going
Csev one and then Chen Wen one.

365
00:17:06,280 --> 00:17:08,160
Now these don't
exist yet, all right

366
00:17:08,160 --> 00:17:12,089
so we got Csev one and Chen Wen
one so that creates an entry

367
00:17:12,089 --> 00:17:15,700
and sticks a one in it and new
mapping between the key Csev

368
00:17:15,700 --> 00:17:18,410
and the value one, the key
Chen Wen and value of one,

369
00:17:18,410 --> 00:17:21,890
and we say hey what's in
there, oh we got Csev as one

370
00:17:21,890 --> 00:17:25,869
and Chen Wen is one and then we
see Chen wen second time so we

371
00:17:25,869 --> 00:17:28,670
add another number right
there, so this old number

372
00:17:28,670 --> 00:17:31,490
is one we add one
to it, we get two

373
00:17:31,490 --> 00:17:35,330
and then we stick that back in
and then we do the calculation,

374
00:17:35,330 --> 00:17:38,480
we do a dump and say oh
there's two in Chen Wen

375
00:17:38,480 --> 00:17:40,150
and one in Csev.

376
00:17:40,150 --> 00:17:41,620
OK

377
00:17:41,620 --> 00:17:44,020
So this is a great
data structure

378
00:17:44,020 --> 00:17:46,310
for these simultaneous
counters, like what's

379
00:17:46,310 --> 00:17:51,100
the most common word,
who had the most commits.

380
00:17:51,100 --> 00:17:53,772
Now everything we do,
we have to figure out

381
00:17:53,772 --> 00:17:55,980
like when you're going to
get in trouble with Python,

382
00:17:55,980 --> 00:17:58,770
when Python's going to give
you the old thumbs down and say

383
00:17:58,770 --> 00:18:00,230
yup you went too far.

384
00:18:00,230 --> 00:18:02,430
So one thing Python
does not like ,

385
00:18:02,430 --> 00:18:06,340
is if you reference a
key before it exists.

386
00:18:06,340 --> 00:18:09,089
We'll look at in a second
how to work around this,

387
00:18:09,089 --> 00:18:10,630
but if you simply
create a dictionary

388
00:18:10,630 --> 00:18:13,160
and say oh print out
what's under Csev,

389
00:18:13,160 --> 00:18:16,250
it gives you a trace
back, it's like I'm

390
00:18:16,250 --> 00:18:18,390
going to inform you
that that's not there.

391
00:18:18,390 --> 00:18:20,500
And it's a key error Csev.

392
00:18:20,500 --> 00:18:24,810
Now the thing that allows us to
solve this, is the in operator.

393
00:18:24,810 --> 00:18:27,060
We've used the in operator
to see if a substring was

394
00:18:27,060 --> 00:18:30,410
in a string, or the
number was in a list, so

395
00:18:30,410 --> 00:18:34,340
so there's in operator
says, in operator says, hey

396
00:18:34,340 --> 00:18:37,080
ask a question.

397
00:18:37,080 --> 00:18:43,200
Is the string csev a current
key in the dictionary ccc.

398
00:18:43,200 --> 00:18:46,710
Is the string csev a current
key in the dictionary ccc,

399
00:18:46,710 --> 00:18:49,210
and it says false.

400
00:18:49,210 --> 00:18:51,560
So now we have
something that doesn't

401
00:18:51,560 --> 00:18:53,980
give a trace back that
can tell us whether or not

402
00:18:53,980 --> 00:18:55,046
the key is there.

403
00:18:55,046 --> 00:18:56,420
So if you remember
the algorithm,

404
00:18:56,420 --> 00:18:59,050
the first time you see
it you set them to one,

405
00:18:59,050 --> 00:19:02,620
and every other time
you add one to them.

406
00:19:02,620 --> 00:19:05,120
So this how we do
that in Python.

407
00:19:05,120 --> 00:19:07,380
So here's how we
implement that program

408
00:19:07,380 --> 00:19:09,890
that I just gave you in Python.

409
00:19:09,890 --> 00:19:12,660
So here's our
names, it's shorter

410
00:19:12,660 --> 00:19:14,740
so my slide works better.

411
00:19:14,740 --> 00:19:16,690
Here's variable, our
iteration variable

412
00:19:16,690 --> 00:19:21,240
it's going to go through all
five of these one at a time

413
00:19:21,240 --> 00:19:24,730
and within the body of the
loop, we have an if statement.

414
00:19:24,730 --> 00:19:29,750
If the name is not currently in
the counts dictionary counts is

415
00:19:29,750 --> 00:19:32,170
the name of my dictionary,
if the name is not currently

416
00:19:32,170 --> 00:19:36,450
in counts dictionary, I say
counts of name equals one.

417
00:19:36,450 --> 00:19:38,810
Else, that must
mean it's already

418
00:19:38,810 --> 00:19:41,290
there which means it's
OK to retrieve it,

419
00:19:41,290 --> 00:19:43,840
counts sub name plus 1,
we're going to add a 1 to it

420
00:19:43,840 --> 00:19:45,710
and stick it back in.

421
00:19:45,710 --> 00:19:46,550
OK

422
00:19:46,550 --> 00:19:50,310
And so when this finishes, it's
going to add entries and then

423
00:19:50,310 --> 00:19:52,720
add one to entries today
that already exist,

424
00:19:52,720 --> 00:19:55,110
and not trace back it all,
and when we print it out

425
00:19:55,110 --> 00:19:58,300
we're going to see
accounts and literally this

426
00:19:58,300 --> 00:20:00,750
could have gone a million
times and it would just be fun

427
00:20:00,750 --> 00:20:02,540
and it would just
keep expanding.

428
00:20:02,540 --> 00:20:05,280
OK?

429
00:20:05,280 --> 00:20:06,900
So this pattern
of checking to see

430
00:20:06,900 --> 00:20:10,250
if the key is in a dictionary,
setting it to some number,

431
00:20:10,250 --> 00:20:16,040
or adding one to it, is a
really, really common pattern.

432
00:20:16,040 --> 00:20:18,370
It's so common as
a matter of fact,

433
00:20:18,370 --> 00:20:21,810
that there is a special thing
built into dictionaries,

434
00:20:21,810 --> 00:20:23,730
that does this for us.

435
00:20:23,730 --> 00:20:28,090
OK and there is this
method called get.

436
00:20:28,090 --> 00:20:30,530
And so counts is the
name of the dictionary,

437
00:20:30,530 --> 00:20:34,130
get is a built in
capability of dictionaries

438
00:20:34,130 --> 00:20:35,760
and it takes two parameters.

439
00:20:35,760 --> 00:20:39,000
The first parameter
is a key name,

440
00:20:39,000 --> 00:20:43,090
like a string like
csev, cwen or marquard.

441
00:20:43,090 --> 00:20:45,400
And then the second
parameter is a value

442
00:20:45,400 --> 00:20:50,890
to give back if
this doesn't exist.

443
00:20:50,890 --> 00:20:54,350
It's a default value if
the key does not exist

444
00:20:54,350 --> 00:20:55,860
and there's no trace back.

445
00:20:55,860 --> 00:21:00,720
So this way you can encapsulate
in effect if then else.

446
00:21:00,720 --> 00:21:03,430
If the name parameters
is in the counts,

447
00:21:03,430 --> 00:21:06,330
print the thing out,
otherwise print zero.

448
00:21:06,330 --> 00:21:11,520
So this expression will
either get the number,

449
00:21:11,520 --> 00:21:15,590
if it exists, or it
will give me back a zero

450
00:21:15,590 --> 00:21:16,930
if it doesn't exist.

451
00:21:16,930 --> 00:21:19,100
So this is really
valuable, right?

452
00:21:19,100 --> 00:21:21,110
This is really valuable.

453
00:21:21,110 --> 00:21:23,270
That's a pretty bad Smiley face.

454
00:21:23,270 --> 00:21:26,710
So this is really
valuable because it-- once

455
00:21:26,710 --> 00:21:30,350
we understand the idiom, It
really takes four lines of code

456
00:21:30,350 --> 00:21:32,560
and turns it into
one line of code.

457
00:21:32,560 --> 00:21:35,810
Because we're going to be doing
this if then else all the time.

458
00:21:35,810 --> 00:21:41,080
Now we can reconstruct that
loop a lot easier and a lot more

459
00:21:41,080 --> 00:21:43,090
cleanly using this idiom.

460
00:21:43,090 --> 00:21:44,020
Right?

461
00:21:44,020 --> 00:21:45,910
It's something that
looks kind of complex,

462
00:21:45,910 --> 00:21:49,180
but you'll get used
to it really fast.

463
00:21:49,180 --> 00:21:51,460
So we have everything
here is the same,

464
00:21:51,460 --> 00:21:54,440
we create an empty dictionary we
have five names to go through,

465
00:21:54,440 --> 00:21:56,580
we're going to write
a loop and it's

466
00:21:56,580 --> 00:21:58,300
going to go through
each of those,

467
00:21:58,300 --> 00:22:00,100
and then we're going
to say, counts of name

468
00:22:00,100 --> 00:22:05,450
equals counts dot get
the value stored at name,

469
00:22:05,450 --> 00:22:08,590
and if you don't find
it give me back a zero.

470
00:22:08,590 --> 00:22:11,260
And then whatever comes
back either the old value

471
00:22:11,260 --> 00:22:15,320
or the zero, add one to
that and then take that sum

472
00:22:15,320 --> 00:22:18,310
and stick it in counts name.

473
00:22:18,310 --> 00:22:25,940
So this is either
going to create,

474
00:22:25,940 --> 00:22:29,837
or it's going to update.

475
00:22:29,837 --> 00:22:32,170
If there is no entry, it's
going to create it and set it

476
00:22:32,170 --> 00:22:35,580
to one, if there is an
entry it's going to add one

477
00:22:35,580 --> 00:22:37,560
to the current entry.

478
00:22:37,560 --> 00:22:46,510
OK so this is, this line
is kind of an idiom.

479
00:22:46,510 --> 00:22:48,440
Read about it in the
book, figure it out,

480
00:22:48,440 --> 00:22:50,340
get used to the notion
of what this is doing.

481
00:22:50,340 --> 00:22:53,100
Understand what that is doing.

482
00:22:53,100 --> 00:22:54,430
OK?

483
00:22:54,430 --> 00:22:58,510
Because I'm going to start using
it as if you understand it.

484
00:22:58,510 --> 00:23:03,330
So the next problem
is, a problem

485
00:23:03,330 --> 00:23:05,310
of finding the most common word.

486
00:23:05,310 --> 00:23:09,040
So finding the most
common the top five,

487
00:23:09,040 --> 00:23:13,000
is often a trigger that
says use dictionaries,

488
00:23:13,000 --> 00:23:15,407
because if you're going
to have to count things up

489
00:23:15,407 --> 00:23:17,240
you don't know what the
most common thing is

490
00:23:17,240 --> 00:23:20,310
at the beginning, first you
have to count everything up,

491
00:23:20,310 --> 00:23:22,240
and dictionaries are
a great way to count.

492
00:23:22,240 --> 00:23:24,600
So here's a little
problem and I would

493
00:23:24,600 --> 00:23:26,280
like you to read
this text and find

494
00:23:26,280 --> 00:23:29,470
me the most common
word in the text

495
00:23:29,470 --> 00:23:31,800
and tell me what the
most common word is

496
00:23:31,800 --> 00:23:35,430
and how many times it occurs.

497
00:23:35,430 --> 00:23:36,552
Ready?

498
00:23:36,552 --> 00:23:38,510
I'm going to give you a
thousandth of a second,

499
00:23:38,510 --> 00:23:39,900
just like I would
give a computer.

500
00:23:39,900 --> 00:23:40,920
I would expect that
they'll do this

501
00:23:40,920 --> 00:23:42,450
in a thousandth of a second.

502
00:23:42,450 --> 00:23:43,110
There you go.

503
00:23:43,110 --> 00:23:45,920

504
00:23:45,920 --> 00:23:49,590
OK I gave you five seconds,
times up, did you get it?

505
00:23:49,590 --> 00:23:51,570
Or did you say to
yourself, you know

506
00:23:51,570 --> 00:23:54,030
what I hate that,
it's no good, I

507
00:23:54,030 --> 00:23:56,147
think I'll write a
Python program instead.

508
00:23:56,147 --> 00:23:57,980
And you'll probably
show me a Python program

509
00:23:57,980 --> 00:23:59,240
if I wait long enough.

510
00:23:59,240 --> 00:24:01,220
So here's a slightly
easier problem,

511
00:24:01,220 --> 00:24:02,660
from the first lecture.

512
00:24:02,660 --> 00:24:03,160
Ready?

513
00:24:03,160 --> 00:24:06,180
It's the same problem,
find the most common word

514
00:24:06,180 --> 00:24:07,960
and how many times
the word occurs.

515
00:24:07,960 --> 00:24:35,640

516
00:24:35,640 --> 00:24:38,000
Did you get it?

517
00:24:38,000 --> 00:24:42,000
I believe the answer is, and
I could look really dumb here,

518
00:24:42,000 --> 00:24:45,890
the answer is, the and I
think it's seven times.

519
00:24:45,890 --> 00:24:47,470
So that's the right answer.

520
00:24:47,470 --> 00:24:48,340
OK.

521
00:24:48,340 --> 00:24:51,610
Again things humans
are not so good at.

522
00:24:51,610 --> 00:24:53,772
So here's a piece of
code that's starting

523
00:24:53,772 --> 00:24:55,230
to combine some of
the things we've

524
00:24:55,230 --> 00:24:57,720
been doing in the past
few chapters all together.

525
00:24:57,720 --> 00:25:02,840
We are going to read a line
of text, split it into words,

526
00:25:02,840 --> 00:25:07,350
count the occurrence, how
many times each word occurs

527
00:25:07,350 --> 00:25:10,060
and then print out a map.

528
00:25:10,060 --> 00:25:13,440
So, so here's what
we're going to do.

529
00:25:13,440 --> 00:25:16,870
We're going to say OK start a
dictionary an empty dictionary.

530
00:25:16,870 --> 00:25:17,745
Read a line of input.

531
00:25:17,745 --> 00:25:20,460

532
00:25:20,460 --> 00:25:24,940
Then split it, remember
the split takes a string

533
00:25:24,940 --> 00:25:27,160
and produces a list.

534
00:25:27,160 --> 00:25:30,230
So words is a list,
line is a string,

535
00:25:30,230 --> 00:25:31,910
and then we'll print that out.

536
00:25:31,910 --> 00:25:33,920
Then we're going to
write a for loop that's

537
00:25:33,920 --> 00:25:36,390
going to go through
each of the words,

538
00:25:36,390 --> 00:25:39,040
and then create, use this
idiom, counts of word

539
00:25:39,040 --> 00:25:42,017
equals counts dot get
word comma 0 plus 1.

540
00:25:42,017 --> 00:25:43,600
So this is going to
do exactly what we

541
00:25:43,600 --> 00:25:47,730
talked about in the
previous couple slides back.

542
00:25:47,730 --> 00:25:50,980
Either create the entries
or add to those entries.

543
00:25:50,980 --> 00:25:52,840
OK and then we're going
to print them out.

544
00:25:52,840 --> 00:25:56,650
So here's what that program
does, when it prints out.

545
00:25:56,650 --> 00:25:58,920
Now this is actually
one long line

546
00:25:58,920 --> 00:26:01,060
I'm just cutting it so
you can see it here's

547
00:26:01,060 --> 00:26:05,400
this line we enter and the
words the they're seven of them,

548
00:26:05,400 --> 00:26:08,980
then it takes this line
and splits it into a list

549
00:26:08,980 --> 00:26:11,250
and there is the beginning
and end of the list.

550
00:26:11,250 --> 00:26:14,300
The list maintains the
order, so the list simply

551
00:26:14,300 --> 00:26:18,150
breaks all these words
into separate words

552
00:26:18,150 --> 00:26:25,160
in a list of strings, from
one string too many strings.

553
00:26:25,160 --> 00:26:28,750
This is many strings,
and so the and spaces

554
00:26:28,750 --> 00:26:30,564
are gone and so
here's this list,

555
00:26:30,564 --> 00:26:31,980
and then what we're
going to do is

556
00:26:31,980 --> 00:26:35,440
we are going to run
through the list

557
00:26:35,440 --> 00:26:37,200
and we are going to
keep running totals

558
00:26:37,200 --> 00:26:39,490
of each of the words in
the list and then we're

559
00:26:39,490 --> 00:26:41,990
done with a list, we're
going to print out

560
00:26:41,990 --> 00:26:44,760
the contents of that dictionary
and we can inspect it,

561
00:26:44,760 --> 00:26:47,440
go like let's look
for the biggest one,

562
00:26:47,440 --> 00:26:50,550
it's kind of like looking for
the largest, like oh seven,

563
00:26:50,550 --> 00:26:54,230
that's the largest and
the largest word is the.

564
00:26:54,230 --> 00:26:57,000
OK so that's how
the program runs.

565
00:26:57,000 --> 00:27:01,300
It reads a line, splits
it into a list of words,

566
00:27:01,300 --> 00:27:04,450
and then accumulates a
running total for each word,

567
00:27:04,450 --> 00:27:08,990
and then we hand inspect to see
what the most common word is.

568
00:27:08,990 --> 00:27:10,890
OK

569
00:27:10,890 --> 00:27:13,340
Oh no no, I don't
want that song again.

570
00:27:13,340 --> 00:27:15,540
There we go.

571
00:27:15,540 --> 00:27:19,330
And so here we have the, in
this kind of a smaller fashion,

572
00:27:19,330 --> 00:27:21,620
we make a dictionary.

573
00:27:21,620 --> 00:27:25,160
This entering a line of text
is here, it's all one line,

574
00:27:25,160 --> 00:27:29,150
we do the split and then
we print the words out

575
00:27:29,150 --> 00:27:33,190
and so that split creates a list
of strings from a single string

576
00:27:33,190 --> 00:27:37,080
based on where the blanks are
at chop, chop, chop, chop,

577
00:27:37,080 --> 00:27:41,440
and then here it
counting, we're going

578
00:27:41,440 --> 00:27:44,470
to loop through each of
the words, one at a time

579
00:27:44,470 --> 00:27:46,380
and use this idiom
counts of word

580
00:27:46,380 --> 00:27:50,510
equals counts that get word
comma 0 plus 1, which is going

581
00:27:50,510 --> 00:27:52,690
to create and/or update.

582
00:27:52,690 --> 00:27:56,110
And then we print the counts
out and that comes up there.

583
00:27:56,110 --> 00:27:59,547
OK so again, this is the
new thing we've done.

584
00:27:59,547 --> 00:28:01,505
Everything else here
we've kind of seen before.

585
00:28:01,505 --> 00:28:04,790

586
00:28:04,790 --> 00:28:08,460
Now we can also loop through
dictionaries with for loops.

587
00:28:08,460 --> 00:28:12,560

588
00:28:12,560 --> 00:28:15,340
The for loop we've been put
all kinds of things over here,

589
00:28:15,340 --> 00:28:18,910
we put strings over here, we
put listed numbers over here,

590
00:28:18,910 --> 00:28:21,800
we put files over
here, and basically

591
00:28:21,800 --> 00:28:26,160
what it really says is this
is a collection of things,

592
00:28:26,160 --> 00:28:27,720
run this little
indented code once

593
00:28:27,720 --> 00:28:30,590
for each item in the
collection and key

594
00:28:30,590 --> 00:28:32,830
then becomes our
iteration variable,

595
00:28:32,830 --> 00:28:35,150
and key is very mnemonic here.

596
00:28:35,150 --> 00:28:37,910
It doesn't know
that they're keys.

597
00:28:37,910 --> 00:28:44,050
And so keys, the key here,
is that there's a bit,

598
00:28:44,050 --> 00:28:47,420
the important concept
here is that dictionaries

599
00:28:47,420 --> 00:28:49,100
are key value pairs.

600
00:28:49,100 --> 00:28:51,400
And so this is only
one variable and so

601
00:28:51,400 --> 00:28:53,400
it actually decides
that they've decided

602
00:28:53,400 --> 00:28:56,230
it goes through the keys,
which is actually quite useful.

603
00:28:56,230 --> 00:28:59,340
So key is going to take
on the successive, values

604
00:28:59,340 --> 00:29:02,800
of the labels, not the
successive values of the value

605
00:29:02,800 --> 00:29:04,030
stored at the labels.

606
00:29:04,030 --> 00:29:07,570
But it's really easy for
us to retrieve the contents

607
00:29:07,570 --> 00:29:10,250
at that label, counts sub key.

608
00:29:10,250 --> 00:29:13,750
So we're going to use the key
chuck, fred, jan to look up

609
00:29:13,750 --> 00:29:18,190
the 140 to 100 and so it
prints out the key and then

610
00:29:18,190 --> 00:29:20,700
the value added, the
key and the value added,

611
00:29:20,700 --> 00:29:22,170
and the key and the value.

612
00:29:22,170 --> 00:29:25,780
And so we're able to sort
of go through the dictionary

613
00:29:25,780 --> 00:29:27,530
and look at all the
key value pairs, which

614
00:29:27,530 --> 00:29:30,640
is the common thing that
you really want to do.

615
00:29:30,640 --> 00:29:31,140
OK?

616
00:29:31,140 --> 00:29:35,250

617
00:29:35,250 --> 00:29:37,695
Now there's some methods
inside of dictionaries

618
00:29:37,695 --> 00:29:40,540
that allow us to
convert dictionaries

619
00:29:40,540 --> 00:29:45,520
into lists of things and so if
you simply take a dictionary,

620
00:29:45,520 --> 00:29:49,220
so here's a little dictionary
with three items in it,

621
00:29:49,220 --> 00:29:51,970
and we can say list sub and then
give a dictionary name, right

622
00:29:51,970 --> 00:29:54,880
there, and then that
converts it into a list

623
00:29:54,880 --> 00:29:57,690
but it's just a
list of the keys.

624
00:29:57,690 --> 00:30:01,470
We can also say jjj dot keys,
kind of do the same thing,

625
00:30:01,470 --> 00:30:05,150
say give me a list
consisting of the keys.

626
00:30:05,150 --> 00:30:08,740
And then jjj dot values gives
you a list of the values.

627
00:30:08,740 --> 00:30:10,720
142 and a 100.

628
00:30:10,720 --> 00:30:12,836
Of course they're not
in the same order.

629
00:30:12,836 --> 00:30:14,210
Now interestingly,
as long as you

630
00:30:14,210 --> 00:30:17,690
don't modify the dictionary,
the order of these two things

631
00:30:17,690 --> 00:30:20,180
corresponds, as long
as in between here

632
00:30:20,180 --> 00:30:21,410
you're not changing it.

633
00:30:21,410 --> 00:30:25,010
So the first jan maps to
100, chuck maps to one,

634
00:30:25,010 --> 00:30:26,910
and fred maps to 42.

635
00:30:26,910 --> 00:30:30,051
So the order, you
can't predict the order

636
00:30:30,051 --> 00:30:32,550
they're going to come out but
these two things will come out

637
00:30:32,550 --> 00:30:36,340
in the same order whatever
that order happens to be.

638
00:30:36,340 --> 00:30:39,540
OK and so there's
one more thing.

639
00:30:39,540 --> 00:30:42,060
So we got the keys,
we've got the values,

640
00:30:42,060 --> 00:30:44,230
and we have a
thing called items.

641
00:30:44,230 --> 00:30:47,620
Items also returns a list.

642
00:30:47,620 --> 00:30:52,900
It's a list, but it's a list
of what Python calls, tuples.

643
00:30:52,900 --> 00:30:54,940
That's what the next
chapter is about.

644
00:30:54,940 --> 00:30:57,900
We'll talk more about
tuples in the next chapter.

645
00:30:57,900 --> 00:31:01,180
A tuple is a key value pair.

646
00:31:01,180 --> 00:31:03,550
So this list has
three things in it.

647
00:31:03,550 --> 00:31:06,050
One, two, three.

648
00:31:06,050 --> 00:31:07,800
The first one is
jan maps to a 100,

649
00:31:07,800 --> 00:31:10,220
the second one is
chuck maps to one,

650
00:31:10,220 --> 00:31:12,740
the third one is
fred maps to 42.

651
00:31:12,740 --> 00:31:15,560
So just kind of bear
with me for a second,

652
00:31:15,560 --> 00:31:18,990
we'll hit this a little
harder in the next chapter.

653
00:31:18,990 --> 00:31:21,700
But the place that the city
and more this works really

654
00:31:21,700 --> 00:31:23,901
beautifully is on a for loop.

655
00:31:23,901 --> 00:31:26,400
Now for those of you who have
programmed in other languages,

656
00:31:26,400 --> 00:31:28,070
this will be kind of weird.

657
00:31:28,070 --> 00:31:30,900
Because other languages
have iterations.

658
00:31:30,900 --> 00:31:33,660
But they don't have two
iteration variables.

659
00:31:33,660 --> 00:31:35,460
Python has two
iteration variables.

660
00:31:35,460 --> 00:31:37,276
It can be used for
many things but one

661
00:31:37,276 --> 00:31:38,650
of the things that
it's used for,

662
00:31:38,650 --> 00:31:42,680
that's really quite nice is
we can have two iterations

663
00:31:42,680 --> 00:31:47,070
variables, this jj items
returns pairs of things,

664
00:31:47,070 --> 00:31:50,160
and then aaa and
bb are iteration

665
00:31:50,160 --> 00:31:54,750
variables the sort of
move in, is synchronized,

666
00:31:54,750 --> 00:31:56,630
are synchronized as
they move through.

667
00:31:56,630 --> 00:32:07,290
So aaa takes on the value of
the key, bbb takes on the value.

668
00:32:07,290 --> 00:32:13,090
And then the loop runs ones then
aaa is advance to the next key,

669
00:32:13,090 --> 00:32:16,160
and bbb is advanced to the
next value simultaneously,

670
00:32:16,160 --> 00:32:17,420
synchronized.

671
00:32:17,420 --> 00:32:19,780
Then they print that
out then it advances

672
00:32:19,780 --> 00:32:22,700
to the next one, and the next
one, and they print that out.

673
00:32:22,700 --> 00:32:27,740
So they are moving in
a synchronized way.

674
00:32:27,740 --> 00:32:31,080
Now again the order Jan,
Chuck, Fred is not the same,

675
00:32:31,080 --> 00:32:34,060
but the correspondence
between Jan 100, Chuck one

676
00:32:34,060 --> 00:32:37,070
and Fred, that's going to work.

677
00:32:37,070 --> 00:32:40,230
And so basically
as these things go,

678
00:32:40,230 --> 00:32:42,390
they work their way
through whatever order

679
00:32:42,390 --> 00:32:44,070
they're stored in
the dictionary.

680
00:32:44,070 --> 00:32:45,460
So this is quite nice.

681
00:32:45,460 --> 00:32:48,900
Two iteration variables
going through key value.

682
00:32:48,900 --> 00:32:52,805
Now if I was making
these names mnemonic,

683
00:32:52,805 --> 00:32:54,180
and they made more
sense, I would

684
00:32:54,180 --> 00:32:58,570
call this the key variable and
that be the value variable.

685
00:32:58,570 --> 00:33:00,590
But for now, I'm just
using kind of silly names

686
00:33:00,590 --> 00:33:02,930
to show you that key and
value are not special,

687
00:33:02,930 --> 00:33:05,590
they're not Python
reserved words in any way,

688
00:33:05,590 --> 00:33:09,310
they're just a good way to name
these things key value pairs.

689
00:33:09,310 --> 00:33:12,030
OK.

690
00:33:12,030 --> 00:33:16,160
OK, now we're going to
circle all the way back

691
00:33:16,160 --> 00:33:19,200
to the beginning, all the way
back to the first lecture.

692
00:33:19,200 --> 00:33:24,020
And I gave you this program,
I said don't worry about it,

693
00:33:24,020 --> 00:33:25,740
will learn about it later.

694
00:33:25,740 --> 00:33:27,730
Well now later.

695
00:33:27,730 --> 00:33:30,120
At this point, you should
be able to understand

696
00:33:30,120 --> 00:33:33,520
every line of this program.

697
00:33:33,520 --> 00:33:35,320
This is the program
that's going to count

698
00:33:35,320 --> 00:33:39,110
the most common word in a file.

699
00:33:39,110 --> 00:33:40,720
So let's walk
through what it does

700
00:33:40,720 --> 00:33:45,650
and hopefully by now this
will make a lot of sense.

701
00:33:45,650 --> 00:33:46,154
OK

702
00:33:46,154 --> 00:33:47,570
So we're going to
start out, we're

703
00:33:47,570 --> 00:33:49,570
going to ask for file name.

704
00:33:49,570 --> 00:33:52,150
You're going to open
that file for read,

705
00:33:52,150 --> 00:33:55,280
then because we know it's
not a very large file, we're

706
00:33:55,280 --> 00:33:58,700
going to read it all in one
go, so handle dot read says,

707
00:33:58,700 --> 00:34:01,690
read the whole file new lines
and all, blanks, new lines,

708
00:34:01,690 --> 00:34:05,819
whatever, and put it in
a variable called text.

709
00:34:05,819 --> 00:34:07,360
Just mnemonic,
remember I'm starting,

710
00:34:07,360 --> 00:34:09,920
this one I'm using
mnemonic variable names,

711
00:34:09,920 --> 00:34:13,320
then go through that
whole string, which

712
00:34:13,320 --> 00:34:14,670
was the whole file.

713
00:34:14,670 --> 00:34:16,610
Go through and split it all.

714
00:34:16,610 --> 00:34:19,810
New lines don't hurt it, new
lines are treated like blanks,

715
00:34:19,810 --> 00:34:22,555
and it understands all that,
it throws the new lines away

716
00:34:22,555 --> 00:34:23,929
and the blanks
away and splits it

717
00:34:23,929 --> 00:34:28,540
into a beautiful list of
just words with no blanks.

718
00:34:28,540 --> 00:34:30,520
In the list of the
words in that file

719
00:34:30,520 --> 00:34:33,020
ends up in the variable words.

720
00:34:33,020 --> 00:34:37,070
Words is a list, text is
a string, words is a list.

721
00:34:37,070 --> 00:34:40,340
Then what I do is the pattern
of accumulating counters

722
00:34:40,340 --> 00:34:41,610
in a dictionary.

723
00:34:41,610 --> 00:34:45,850
I make an empty dictionary,
I have the word variable

724
00:34:45,850 --> 00:34:49,350
goes to all the words, and
then I just say counts of word

725
00:34:49,350 --> 00:34:51,370
equals counts word dot get.

726
00:34:51,370 --> 00:34:52,639
Word comma 0 plus 1.

727
00:34:52,639 --> 00:34:55,350
That, like we just
got done saying,

728
00:34:55,350 --> 00:34:59,900
it both creates and or
increments the value

729
00:34:59,900 --> 00:35:02,030
in the dictionary as needed.

730
00:35:02,030 --> 00:35:05,180
So now at this point
in the program,

731
00:35:05,180 --> 00:35:11,690
we have a full dictionary
with the word colon count.

732
00:35:11,690 --> 00:35:13,842
OK, and there's many them.

733
00:35:13,842 --> 00:35:15,050
All the words all the counts.

734
00:35:15,050 --> 00:35:16,395
Not in any particular order.

735
00:35:16,395 --> 00:35:17,770
So now what we're
going to do, is

736
00:35:17,770 --> 00:35:20,070
we're going to write
a largest loop.

737
00:35:20,070 --> 00:35:23,762
Find the largest, which is
another thing we've done.

738
00:35:23,762 --> 00:35:25,220
So not only do I
not need know what

739
00:35:25,220 --> 00:35:27,340
the largest count
I've seen so far,

740
00:35:27,340 --> 00:35:29,317
I need to know
what word that is.

741
00:35:29,317 --> 00:35:31,150
So I am going to set
the largest count we've

742
00:35:31,150 --> 00:35:33,300
seen so far to none,
set the largest

743
00:35:33,300 --> 00:35:35,420
word we've seen so far
to none, and then I'm

744
00:35:35,420 --> 00:35:38,050
going to use this two
iteration variable

745
00:35:38,050 --> 00:35:40,965
pattern to say go through
the key value pairs, word,

746
00:35:40,965 --> 00:35:43,370
and count.

747
00:35:43,370 --> 00:35:47,120
In counts item, so it's going
to just go through all of them

748
00:35:47,120 --> 00:35:50,220
and then I'm going to ask,
if the largest number I've

749
00:35:50,220 --> 00:35:53,697
seen so far is none, or
the current count that I'm

750
00:35:53,697 --> 00:35:55,530
looking at, is greater
than the largest I've

751
00:35:55,530 --> 00:36:01,150
seen so far, keep them.

752
00:36:01,150 --> 00:36:04,270
Take the current word stick
it and biggest word so far,

753
00:36:04,270 --> 00:36:07,170
take the current account stick
it in the biggest count so far.

754
00:36:07,170 --> 00:36:12,010
So this is going to run through
all of the word count pairs,

755
00:36:12,010 --> 00:36:15,700
word count key value pairs,
and then when it comes out,

756
00:36:15,700 --> 00:36:18,420
it's going to print out the
word that's the most common

757
00:36:18,420 --> 00:36:20,800
and how many times.

758
00:36:20,800 --> 00:36:24,080
So if we feed in that context
it will run all this stuff

759
00:36:24,080 --> 00:36:27,050
and print out, Oh the,
is the most common word

760
00:36:27,050 --> 00:36:29,040
and appeared seven times.

761
00:36:29,040 --> 00:36:31,505
Or if I print the stuff
that was two slides back,

762
00:36:31,505 --> 00:36:34,620
words dot txt from
the actual textbook,

763
00:36:34,620 --> 00:36:36,620
then it says the word
two is the most common

764
00:36:36,620 --> 00:36:37,810
and happened 16 times.

765
00:36:37,810 --> 00:36:43,800
So I could easily throw 10
million, 10 million words

766
00:36:43,800 --> 00:36:46,370
through this thing and it
would just be totally happy.

767
00:36:46,370 --> 00:36:47,030
Right?

768
00:36:47,030 --> 00:36:49,740
And so this is not that
complex of a problem,

769
00:36:49,740 --> 00:36:52,710
but it's using a whole bunch of
idioms that we've been using.

770
00:36:52,710 --> 00:36:55,160
The splitting of
words, the accumulation

771
00:36:55,160 --> 00:36:59,200
of multiple counter and a
dictionary, and so it's sort of

772
00:36:59,200 --> 00:37:02,760
is, the beginning of doing
some kind of data analysis

773
00:37:02,760 --> 00:37:04,930
that's hard for humans
to do, and error

774
00:37:04,930 --> 00:37:06,140
prone for humans to do.

775
00:37:06,140 --> 00:37:08,530
And so this is we're
reviewing collections,

776
00:37:08,530 --> 00:37:10,432
we've introduced dictionaries.

777
00:37:10,432 --> 00:37:12,390
We've done the most common
word pattern, talked

778
00:37:12,390 --> 00:37:14,770
about that, a lack
of order, I get

779
00:37:14,770 --> 00:37:17,450
that a bunch of times,
and we've looked ahead

780
00:37:17,450 --> 00:37:20,910
at tuples, which is the next,
the third kind of collection

781
00:37:20,910 --> 00:37:22,890
that we're going to
talk about and they're

782
00:37:22,890 --> 00:37:25,840
actually in some ways a little
simpler than dictionaries,

783
00:37:25,840 --> 00:37:27,220
and simpler than lists.

784
00:37:27,220 --> 00:37:31,240
So see you in the next lecture.

785
00:37:31,240 --> 00:37:33,088
Chapter 10, tuples.

786
00:37:33,088 --> 00:37:33,588
1
00:00:00,000 --> 00:00:00,500

2
00:00:00,500 --> 00:00:03,720
Hello and welcome to chapter
11, regular expressions

3
00:00:03,720 --> 00:00:05,470
from the book Python
for Informatics,

4
00:00:05,470 --> 00:00:07,650
Exploring Information.

5
00:00:07,650 --> 00:00:10,960
As always, these slides are
copyright Creative Commons

6
00:00:10,960 --> 00:00:13,250
attribution as well
as the audio and video

7
00:00:13,250 --> 00:00:15,420
that you're watching or
listening to right now.

8
00:00:15,420 --> 00:00:18,080

9
00:00:18,080 --> 00:00:22,860
So regular expressions
are an interesting thing.

10
00:00:22,860 --> 00:00:25,240
You've seen from the
chapters up til now,

11
00:00:25,240 --> 00:00:29,850
I've had a singular focus
on pulling information out

12
00:00:29,850 --> 00:00:30,520
of data.

13
00:00:30,520 --> 00:00:32,850
Raw data, this mailbox
file that perhaps you're

14
00:00:32,850 --> 00:00:34,150
getting tired of already.

15
00:00:34,150 --> 00:00:35,650
But it's a lot of
fun, because I can

16
00:00:35,650 --> 00:00:37,884
have you go look for
something and pick it out

17
00:00:37,884 --> 00:00:39,550
and you're doing
something that would be

18
00:00:39,550 --> 00:00:42,350
really painful to do by hand.

19
00:00:42,350 --> 00:00:44,892

20
00:00:44,892 --> 00:00:47,100
And while it's not all about
computing, there's games

21
00:00:47,100 --> 00:00:49,420
and there's things like
weather computations

22
00:00:49,420 --> 00:00:54,180
that do calculations,
pulling extracting data out

23
00:00:54,180 --> 00:00:56,700
is a big part of computing.

24
00:00:56,700 --> 00:00:59,090
And so there's actually
a library that's

25
00:00:59,090 --> 00:01:01,340
built specifically do this.

26
00:01:01,340 --> 00:01:05,700
And if you start doing
a few finds and slicing,

27
00:01:05,700 --> 00:01:07,000
it gets long after a while.

28
00:01:07,000 --> 00:01:07,500

29
00:01:07,500 --> 00:01:10,600
Like split, for example,
really saved us a lot of time.

30
00:01:10,600 --> 00:01:13,160
But sometimes, the data
that you're looking for

31
00:01:13,160 --> 00:01:15,550
is a little more
sophisticated than broken

32
00:01:15,550 --> 00:01:18,130
into spaces or colons
or something like that.

33
00:01:18,130 --> 00:01:21,110
And you just want to tell
something to go find,

34
00:01:21,110 --> 00:01:23,260
I see what I want
and I see where

35
00:01:23,260 --> 00:01:25,920
it's embedded in the
string, go get it for me.

36
00:01:25,920 --> 00:01:28,720
And regular expressions are
themselves a programming

37
00:01:28,720 --> 00:01:29,220
language.

38
00:01:29,220 --> 00:01:33,810
They're like a really smart
wild card for searching.

39
00:01:33,810 --> 00:01:36,590
So we've used wild cards in
various things in search.

40
00:01:36,590 --> 00:01:41,960
But they are a really smart
version of a wild card.

41
00:01:41,960 --> 00:01:46,320
And so regular expressions
are quite powerful.

42
00:01:46,320 --> 00:01:47,700
And they're very cryptic.

43
00:01:47,700 --> 00:01:49,325
And as a matter of
fact, you don't even

44
00:01:49,325 --> 00:01:51,870
need to learn them if you
don't feel like it, right?

45
00:01:51,870 --> 00:01:53,470
I've got this little guide.

46
00:01:53,470 --> 00:01:56,070
I need a guide for myself
when I do regular expressions.

47
00:01:56,070 --> 00:01:58,067
It sometimes takes
me a few minutes

48
00:01:58,067 --> 00:02:00,400
to write a regular expression
to do exactly what I want.

49
00:02:00,400 --> 00:02:02,890
So in a way, writing
a regular expression

50
00:02:02,890 --> 00:02:05,370
is like writing a program.

51
00:02:05,370 --> 00:02:08,350
It's highly specialized to
searching and extracting data

52
00:02:08,350 --> 00:02:10,419
from strings, but it's
like writing a program.

53
00:02:10,419 --> 00:02:11,960
And it takes a while
to get it right.

54
00:02:11,960 --> 00:02:16,380
And you have to change this,
what about a slash there.

55
00:02:16,380 --> 00:02:18,130
But they actually are fun.

56
00:02:18,130 --> 00:02:21,750
And they're a great way
to exchange little program

57
00:02:21,750 --> 00:02:23,960
snippets to say, oh yeah,
I'm looking for this.

58
00:02:23,960 --> 00:02:26,230
Oh, here's a little reg
expression you might try.

59
00:02:26,230 --> 00:02:29,650
So they're like
programs themselves.

60
00:02:29,650 --> 00:02:31,970
It is this language
of marker characters.

61
00:02:31,970 --> 00:02:34,650
So when we look for
regular expressions,

62
00:02:34,650 --> 00:02:38,390
some characters like
ABC, have meaning as ABC.

63
00:02:38,390 --> 00:02:40,476
But some characters, like
carrot or dollar sign

64
00:02:40,476 --> 00:02:42,850
mean the beginning of the line
or at the end of the line.

65
00:02:42,850 --> 00:02:48,330
And so we encode, in this
string, a program, basically.

66
00:02:48,330 --> 00:02:50,180
So it's a rather
old school language.

67
00:02:50,180 --> 00:02:51,630
It's from a long time.

68
00:02:51,630 --> 00:02:56,790
It predates Python, which
is over 20 years old.

69
00:02:56,790 --> 00:03:00,630
It also marks you as
a little cool, right?

70
00:03:00,630 --> 00:03:04,810
It's a distinct marking that
makes it so that you know

71
00:03:04,810 --> 00:03:06,510
something other people don't.

72
00:03:06,510 --> 00:03:08,370
So you can know how to program.

73
00:03:08,370 --> 00:03:10,578
But if you know regular
expressions, they'll be like,

74
00:03:10,578 --> 00:03:13,360
whoa, I tried to look at
those and they're tough.

75
00:03:13,360 --> 00:03:17,990
In a way, knowing regular
expressions is like a tattoo.

76
00:03:17,990 --> 00:03:19,450
So it's casual Friday.

77
00:03:19,450 --> 00:03:21,200
And that's why I'm
wearing a t-shirt today

78
00:03:21,200 --> 00:03:23,660
and so I figured I would
come in today in a t-shirt.

79
00:03:23,660 --> 00:03:25,160
But seeing as how
it's the first I'm

80
00:03:25,160 --> 00:03:26,618
wearing a short
sleeved shirt, it's

81
00:03:26,618 --> 00:03:29,580
also first time I can show
you my real tattoo here.

82
00:03:29,580 --> 00:03:31,340
So here's my real tattoo.

83
00:03:31,340 --> 00:03:33,700
And in the middle is the
Sakai, the open source

84
00:03:33,700 --> 00:03:36,150
learning manager system,
always close to my heart.

85
00:03:36,150 --> 00:03:37,810
And then you have
the IMS logo, which

86
00:03:37,810 --> 00:03:40,260
is IMS Learning Tools
and Operability, which

87
00:03:40,260 --> 00:03:42,190
is a standard that
means a lot to me.

88
00:03:42,190 --> 00:03:47,740
Blackboard, OLAT, Learning
Objects, Angel, Moodle,

89
00:03:47,740 --> 00:03:51,920
Instructure, Jenzabar,
and Desire2Learn.

90
00:03:51,920 --> 00:03:53,670
I call this the
ring of compliance.

91
00:03:53,670 --> 00:03:57,280
Because these are all of the
first six or seven learning

92
00:03:57,280 --> 00:04:00,930
management systems that complied
with the IMS Learning Tools

93
00:04:00,930 --> 00:04:03,070
Interoperability Standard
and Specification,

94
00:04:03,070 --> 00:04:06,220
which is something that I spent
a lot of my life making work.

95
00:04:06,220 --> 00:04:09,580
So I figured I'd make
a tattoo and just

96
00:04:09,580 --> 00:04:11,910
a part of my rough, tough image.

97
00:04:11,910 --> 00:04:14,140
And actually,
regular expressions

98
00:04:14,140 --> 00:04:16,370
are indeed part of my
rough, tough image.

99
00:04:16,370 --> 00:04:18,860
Because I'm like, I'm down
with regular expressions.

100
00:04:18,860 --> 00:04:22,050
And people are like, impressed
with my regular expression

101
00:04:22,050 --> 00:04:22,770
knowledge.

102
00:04:22,770 --> 00:04:25,890
But as impressive as I am,
I still need a cheat sheet.

103
00:04:25,890 --> 00:04:28,545
So I'll have a cheat sheet that
you can download, hopefully,

104
00:04:28,545 --> 00:04:31,080
on the Python [INAUDIBLE]
website or whatever.

105
00:04:31,080 --> 00:04:32,790
And it doesn't have to be much.

106
00:04:32,790 --> 00:04:34,840
It's really just a crutch.

107
00:04:34,840 --> 00:04:37,140
And these are the characters
that have special meaning.

108
00:04:37,140 --> 00:04:39,890
Like carrot or dollar sign match
the beginning or end of line,

109
00:04:39,890 --> 00:04:40,935
respectively.

110
00:04:40,935 --> 00:04:42,810
So they're not really
matching a dollar sign,

111
00:04:42,810 --> 00:04:46,400
they match-- they mean something
in our little mini string

112
00:04:46,400 --> 00:04:48,780
like programming language.

113
00:04:48,780 --> 00:04:52,120
So like many things that we
do in Python going forward,

114
00:04:52,120 --> 00:04:54,220
once you want some
sophisticated capability,

115
00:04:54,220 --> 00:04:57,600
it comes with Python, but it
comes in the form of a library.

116
00:04:57,600 --> 00:04:59,460
And so the regular
expression library,

117
00:04:59,460 --> 00:05:02,430
we have to say import RE at
the beginning of our programs

118
00:05:02,430 --> 00:05:04,130
to import to regular
expression library.

119
00:05:04,130 --> 00:05:06,390
Then we call
RE.search to say I'm

120
00:05:06,390 --> 00:05:09,240
looking for search from the
regular expression library.

121
00:05:09,240 --> 00:05:12,740
There's two basic
basic capabilities

122
00:05:12,740 --> 00:05:14,740
inside this library that
we're going to look at.

123
00:05:14,740 --> 00:05:16,900
One is search that
replaces find.

124
00:05:16,900 --> 00:05:18,490
It's like a smart find.

125
00:05:18,490 --> 00:05:22,310
And then find all is a
combination of a smart find

126
00:05:22,310 --> 00:05:24,140
and automatic extraction.

127
00:05:24,140 --> 00:05:26,320
So we'll look at both
of those in turn.

128
00:05:26,320 --> 00:05:29,270
And I'll do it by comparing
them to existing Python

129
00:05:29,270 --> 00:05:31,300
that you already should
know at this point.

130
00:05:31,300 --> 00:05:34,480

131
00:05:34,480 --> 00:05:37,300
So here's some code that's,
say, looking for lines that have

132
00:05:37,300 --> 00:05:40,126
the string from colon in them.

133
00:05:40,126 --> 00:05:41,626
So we're going to
open a file, we're

134
00:05:41,626 --> 00:05:44,490
going to strip the white
space, if we find--

135
00:05:44,490 --> 00:05:47,840
if we hunt within
line for from, if it's

136
00:05:47,840 --> 00:05:51,010
greater than or equal to
zero, then we'll print it.

137
00:05:51,010 --> 00:05:53,220
And so this is just going
to give us a number.

138
00:05:53,220 --> 00:05:54,790
If it's not found,
it's negative 1.

139
00:05:54,790 --> 00:05:58,040
So it's only going to print
the lines that from in them.

140
00:05:58,040 --> 00:06:00,730
Here is the equivalent
using regular expressions.

141
00:06:00,730 --> 00:06:03,240
So these two things
are equivalent.

142
00:06:03,240 --> 00:06:05,994
So we have to import to library,
like I mentioned before.

143
00:06:05,994 --> 00:06:07,410
And all the rest
of it's the same.

144
00:06:07,410 --> 00:06:11,570
The IF test is RE.search that
says, within the library,

145
00:06:11,570 --> 00:06:15,100
RE, called the Search Utility.

146
00:06:15,100 --> 00:06:17,960
And then pass in the
string we're looking for

147
00:06:17,960 --> 00:06:21,080
and the line, the actual
text we're looking in.

148
00:06:21,080 --> 00:06:24,130
So this is like look for from
inside of line and return

149
00:06:24,130 --> 00:06:27,510
me a true or false,
whichever depending on

150
00:06:27,510 --> 00:06:28,635
whether you find it or not.

151
00:06:28,635 --> 00:06:30,720
Now, might say, you
just got done telling me

152
00:06:30,720 --> 00:06:32,500
that it was more dense.

153
00:06:32,500 --> 00:06:34,750
And the answer is, there's
a few more characters here.

154
00:06:34,750 --> 00:06:37,640
But we'll see in a second how
you can quickly add more power

155
00:06:37,640 --> 00:06:39,210
to the regular expression.

156
00:06:39,210 --> 00:06:41,770
Find you have to start adding
more Python lines to make

157
00:06:41,770 --> 00:06:44,180
it more sophisticated where
in the regular expression,

158
00:06:44,180 --> 00:06:49,780
you start changing-- you change
the search string to give more

159
00:06:49,780 --> 00:06:51,640
of the direction of
what you're looking for.

160
00:06:51,640 --> 00:06:52,900
And that's what we'll
be doing pretty much

161
00:06:52,900 --> 00:06:54,570
is changing the search string.

162
00:06:54,570 --> 00:06:58,160
So now, if we want to switch
to, say, wait, wait, wait,

163
00:06:58,160 --> 00:07:00,230
we don't just want the
from anywhere in the line.

164
00:07:00,230 --> 00:07:02,880
We want it to start with from.

165
00:07:02,880 --> 00:07:05,207
So we would change
line.startswith('From').

166
00:07:05,207 --> 00:07:07,540
And that's either going to
be true or false depending on

167
00:07:07,540 --> 00:07:10,520
whether or not the
line starts with from.

168
00:07:10,520 --> 00:07:12,890
Now, we do the same thing
with regular expressions

169
00:07:12,890 --> 00:07:15,791
by changing the search string.

170
00:07:15,791 --> 00:07:17,290
So now we're in
regular expressions.

171
00:07:17,290 --> 00:07:19,120
So this really just
isn't a string.

172
00:07:19,120 --> 00:07:20,750
It's a string plus
characters that

173
00:07:20,750 --> 00:07:24,840
are interpreted as commands by
the regular expression library.

174
00:07:24,840 --> 00:07:29,470
So the caret, which is the first
one on our regular expressions

175
00:07:29,470 --> 00:07:31,870
sheet, matches the
beginning of the line.

176
00:07:31,870 --> 00:07:33,130
It's not actually a caret.

177
00:07:33,130 --> 00:07:35,940
So that says, the first
character, this two character

178
00:07:35,940 --> 00:07:39,640
sequence, caret f means
f but in column one

179
00:07:39,640 --> 00:07:41,470
in the first
character of the line.

180
00:07:41,470 --> 00:07:44,630
So again, this is going
to give us a true or false

181
00:07:44,630 --> 00:07:47,510
if this regular
expression matches.

182
00:07:47,510 --> 00:07:51,230
The beginning of the line from:
and it's the same as this.

183
00:07:51,230 --> 00:07:52,720
It's, does it start with from?

184
00:07:52,720 --> 00:07:54,740
So again, these
two are equivalent.

185
00:07:54,740 --> 00:07:56,730
But you see the
pattern where we're

186
00:07:56,730 --> 00:08:00,560
going to do something to this
string using these characters

187
00:08:00,560 --> 00:08:04,460
that have meaning, OK?

188
00:08:04,460 --> 00:08:06,770
So the next thing
that's most commonly

189
00:08:06,770 --> 00:08:10,580
done other than caret and
dollar sign for the end of line

190
00:08:10,580 --> 00:08:14,780
is the wild card characters.

191
00:08:14,780 --> 00:08:18,580
And so we use cards
possibly in like DOS

192
00:08:18,580 --> 00:08:21,600
where we can use
question mark or star in

193
00:08:21,600 --> 00:08:24,020
like a dir command or
dir dot star dot star

194
00:08:24,020 --> 00:08:27,105
if you're familiar with that
or even a Unix command like ls,

195
00:08:27,105 --> 00:08:29,890
you know, star dot whatever.

196
00:08:29,890 --> 00:08:31,730
This is not how regular
expressions work.

197
00:08:31,730 --> 00:08:34,890
And the problem is
that dot, dot is--

198
00:08:34,890 --> 00:08:38,039
it matches a single character
in regular expressions.

199
00:08:38,039 --> 00:08:41,570
Asterisk means any
number of times.

200
00:08:41,570 --> 00:08:46,280
So if I look at this
and color code this

201
00:08:46,280 --> 00:08:50,970
to make a little
more sense, the caret

202
00:08:50,970 --> 00:08:55,201
is actually kind of part of the
regular expression programming

203
00:08:55,201 --> 00:08:55,700
language.

204
00:08:55,700 --> 00:08:58,930
Says, I'm a virtual character
matching the beginning of line.

205
00:08:58,930 --> 00:09:00,630
The x is a real character.

206
00:09:00,630 --> 00:09:03,040
The dot is part of the
regular programming

207
00:09:03,040 --> 00:09:04,610
language-- any character.

208
00:09:04,610 --> 00:09:06,990
Star is part of the regular
expression programming that

209
00:09:06,990 --> 00:09:10,520
says the immediate previous
character many times s--

210
00:09:10,520 --> 00:09:12,310
0 or more times.

211
00:09:12,310 --> 00:09:14,840
And then colon
matches the colon.

212
00:09:14,840 --> 00:09:16,820
And so if you look
at lines, these

213
00:09:16,820 --> 00:09:20,950
are the kinds of lines that
will give me a true because they

214
00:09:20,950 --> 00:09:24,850
start with an x followed by some
number of characters followed

215
00:09:24,850 --> 00:09:25,860
by colon.

216
00:09:25,860 --> 00:09:26,910
So that's true.

217
00:09:26,910 --> 00:09:29,630
Start with x followed by
some number of characters

218
00:09:29,630 --> 00:09:31,240
followed by colon.

219
00:09:31,240 --> 00:09:35,150
OK, and so that's
basically how this works.

220
00:09:35,150 --> 00:09:40,980
And so this five
character string,

221
00:09:40,980 --> 00:09:43,900
there are-- some of these
things are like instructions

222
00:09:43,900 --> 00:09:46,480
and some of them are the actual
characters were looking for.

223
00:09:46,480 --> 00:09:49,650
So the x and the colon are the
characters we're looking for

224
00:09:49,650 --> 00:09:55,270
and the caret, dot, and
star are programming, right?

225
00:09:55,270 --> 00:10:00,000
They are logic that we're
adding to the string.

226
00:10:00,000 --> 00:10:04,520
OK, so let's say for example
you're-- part of any of these

227
00:10:04,520 --> 00:10:07,910
things and part of the stuff
we've done so far has to assume

228
00:10:07,910 --> 00:10:10,427
that the data is some
level of being clean.

229
00:10:10,427 --> 00:10:12,260
And so the data that
I've been giving you in

230
00:10:12,260 --> 00:10:15,620
boxed up TXT is
not inconsistent.

231
00:10:15,620 --> 00:10:17,930
It doesn't have, like,
too much weirdness in it.

232
00:10:17,930 --> 00:10:20,309
I'm not trying to trick
you and mislead you

233
00:10:20,309 --> 00:10:22,850
although we had situations where
you sort of get a trace back

234
00:10:22,850 --> 00:10:25,710
because you think there's
going to be five words.

235
00:10:25,710 --> 00:10:28,150
You grab a line, you break it,
and there's only two words.

236
00:10:28,150 --> 00:10:29,775
And you get a trace
back because you're

237
00:10:29,775 --> 00:10:32,720
looking at the fifth word
or something like that.

238
00:10:32,720 --> 00:10:36,310
But if your data is less
clean or even if you just

239
00:10:36,310 --> 00:10:39,840
want to be real careful, you
can fine tune your matching.

240
00:10:39,840 --> 00:10:42,570
So here's that same match.

241
00:10:42,570 --> 00:10:45,790
Give me a character x followed
by any number of characters

242
00:10:45,790 --> 00:10:46,857
followed by a colon.

243
00:10:46,857 --> 00:10:48,190
And that's what I'm looking for.

244
00:10:48,190 --> 00:10:50,050
Give me lines that
match that pattern.

245
00:10:50,050 --> 00:10:52,230
So this x starts at any
number of characters.

246
00:10:52,230 --> 00:10:52,970
Colon, great.

247
00:10:52,970 --> 00:10:55,304
That's any number of
characters-- great.

248
00:10:55,304 --> 00:10:56,720
Oh wait, and there's
an email that

249
00:10:56,720 --> 00:11:01,030
says x plane is two weeks
behind schedule colon two weeks.

250
00:11:01,030 --> 00:11:03,240
Well, the regular
expression didn't

251
00:11:03,240 --> 00:11:05,766
know that dash made
sense to you and you just

252
00:11:05,766 --> 00:11:07,890
assumed that everything
that started with a capital

253
00:11:07,890 --> 00:11:09,470
x had a dash after it.

254
00:11:09,470 --> 00:11:14,750
So x is what it starts with--
any number of any character--

255
00:11:14,750 --> 00:11:16,030
and then a colon.

256
00:11:16,030 --> 00:11:17,460
So this becomes true.

257
00:11:17,460 --> 00:11:19,470
This may not make you happy.

258
00:11:19,470 --> 00:11:21,290
It may not be what
you're looking

259
00:11:21,290 --> 00:11:24,640
for because you haven't
been specific enough

260
00:11:24,640 --> 00:11:26,260
in your regular expression.

261
00:11:26,260 --> 00:11:30,540
So we can be more specific
in our regular expression.

262
00:11:30,540 --> 00:11:35,330
So for example, this is a more
specific regular expression.

263
00:11:35,330 --> 00:11:38,820
It still says start with an
x as the first character,

264
00:11:38,820 --> 00:11:41,230
then a dash-- that's
a real character,

265
00:11:41,230 --> 00:11:45,615
not a-- then this next thing,
instead of being a dot,

266
00:11:45,615 --> 00:11:49,526
it's backslash capital
S. It's on the sheet.

267
00:11:49,526 --> 00:11:51,530
Oh, it's not on the sheet.

268
00:11:51,530 --> 00:11:52,370
I lost the sheet.

269
00:11:52,370 --> 00:11:55,974
Come back, sheet.

270
00:11:55,974 --> 00:11:57,125
I lost the sheet.

271
00:11:57,125 --> 00:12:00,850
I can't live without my sheet.

272
00:12:00,850 --> 00:12:06,430
Backslash capital S means
a non-whitespace character.

273
00:12:06,430 --> 00:12:09,010
So that means
spaces won't match.

274
00:12:09,010 --> 00:12:11,910
And then I change
the asterisk zero

275
00:12:11,910 --> 00:12:14,400
or more times thing to a plus.

276
00:12:14,400 --> 00:12:16,350
And that means
one or more times.

277
00:12:16,350 --> 00:12:18,800
Here's a character, a
non-whitespace-- these two

278
00:12:18,800 --> 00:12:22,050
things kind of work together--
a non-whitespace character

279
00:12:22,050 --> 00:12:27,450
at least one time as many
as we like and then a colon.

280
00:12:27,450 --> 00:12:30,710
So if we look here,
it starts with x

281
00:12:30,710 --> 00:12:33,960
dash any number of
non-whitespace characters

282
00:12:33,960 --> 00:12:36,710
and ends in colon--
starts with x dash

283
00:12:36,710 --> 00:12:39,920
any number of caret
characters, ends in a colon.

284
00:12:39,920 --> 00:12:41,540
True, true.

285
00:12:41,540 --> 00:12:45,700
This one starts with an x but
doesn't start with an x dash.

286
00:12:45,700 --> 00:12:48,200
As a matter of fact, these
characters are blanks.

287
00:12:48,200 --> 00:12:49,360
So this becomes a false.

288
00:12:49,360 --> 00:12:51,110
It does have an x
and does have a colon

289
00:12:51,110 --> 00:12:52,850
and matched the previous one.

290
00:12:52,850 --> 00:12:55,120
But this one here
is more specific.

291
00:12:55,120 --> 00:12:59,770

292
00:12:59,770 --> 00:13:01,397
OK, so it's more specific.

293
00:13:01,397 --> 00:13:02,730
And so it matches what you want.

294
00:13:02,730 --> 00:13:04,040
Now, it depends on what
you're looking for.

295
00:13:04,040 --> 00:13:06,373
Maybe you do want this line
and so you're looking for x.

296
00:13:06,373 --> 00:13:07,030
I don't know.

297
00:13:07,030 --> 00:13:10,530
But if you want, you
can be increasingly

298
00:13:10,530 --> 00:13:13,210
sophisticated in
what you're looking

299
00:13:13,210 --> 00:13:15,120
for in a regular expression.

300
00:13:15,120 --> 00:13:19,940
So now let's talk
about extracting data.

301
00:13:19,940 --> 00:13:23,564
So everything we've done so far
is, is it there or is it not?

302
00:13:23,564 --> 00:13:25,480
But it's really common
once you find something

303
00:13:25,480 --> 00:13:27,120
that you want to
break it into pieces.

304
00:13:27,120 --> 00:13:30,450
So we can combine the
searching and the parsing

305
00:13:30,450 --> 00:13:32,580
into one statement.

306
00:13:32,580 --> 00:13:34,260
And instead of
using search, which

307
00:13:34,260 --> 00:13:38,440
returns for us a true false,
we're going to use find all.

308
00:13:38,440 --> 00:13:43,440
So in this example, I'm going
to show you a new syntax.

309
00:13:43,440 --> 00:13:49,750
The square bracket, in
regular expression language,

310
00:13:49,750 --> 00:13:52,960
means a way to list
a set of characters.

311
00:13:52,960 --> 00:13:57,720
So this says-- this is a
single character that says,

312
00:13:57,720 --> 00:14:01,920
I want to match anything in
the range zero through nine.

313
00:14:01,920 --> 00:14:04,730
Plus means one or more of those.

314
00:14:04,730 --> 00:14:08,590
So that says-- so this whole
thing says one or more digits.

315
00:14:08,590 --> 00:14:11,600
That's a regular expression
that says one or more digits.

316
00:14:11,600 --> 00:14:14,840
You can put other
things inside here.

317
00:14:14,840 --> 00:14:19,530
You can put, like-- you could
make a thing that says a, b, c,

318
00:14:19,530 --> 00:14:20,364
d.

319
00:14:20,364 --> 00:14:23,030
And that would say, I'm going to
match a single character that's

320
00:14:23,030 --> 00:14:25,070
a or b or c or d.

321
00:14:25,070 --> 00:14:32,077
Or you could say,
like, 1357 bracket.

322
00:14:32,077 --> 00:14:34,410
That's a single character
that's either a one or a three

323
00:14:34,410 --> 00:14:35,590
or a five or a seven.

324
00:14:35,590 --> 00:14:37,550
So the bracket is a list
of matching characters

325
00:14:37,550 --> 00:14:40,974
in the dash inside the
bracket-- means range.

326
00:14:40,974 --> 00:14:42,390
We'll see in a
second that you can

327
00:14:42,390 --> 00:14:44,280
stick a not inside the bracket.

328
00:14:44,280 --> 00:14:45,206
It's on the sheet.

329
00:14:45,206 --> 00:14:48,560
So again, remember-- in
this little mini language,

330
00:14:48,560 --> 00:14:49,970
we are programming, right?

331
00:14:49,970 --> 00:14:52,820
We are giving instructions
to the regular expression

332
00:14:52,820 --> 00:14:54,770
engine as it were, OK?

333
00:14:54,770 --> 00:14:58,080

334
00:14:58,080 --> 00:15:03,850
So if we do this-- and here
is an expression that says,

335
00:15:03,850 --> 00:15:09,340
I would like to find things
that are one or more digits.

336
00:15:09,340 --> 00:15:15,547
And so it's one or more digits.

337
00:15:15,547 --> 00:15:17,130
And so it's going
to look through here

338
00:15:17,130 --> 00:15:20,550
and it's going to find it
as many times as it can.

339
00:15:20,550 --> 00:15:22,560
So there is one or more digits.

340
00:15:22,560 --> 00:15:24,640
There is one or more digits.

341
00:15:24,640 --> 00:15:26,690
And there is one or more digits.

342
00:15:26,690 --> 00:15:30,510
And so what find all gives
us back is a list of strings.

343
00:15:30,510 --> 00:15:31,800
So it found it.

344
00:15:31,800 --> 00:15:32,580
Where do I match?

345
00:15:32,580 --> 00:15:33,288
Where do I match?

346
00:15:33,288 --> 00:15:35,090
Where-- it's looking
the whole time.

347
00:15:35,090 --> 00:15:39,340
And then it says, oh,
I've got it-- 2, 19, 42.

348
00:15:39,340 --> 00:15:43,370
So it actually extracts
the strings that match

349
00:15:43,370 --> 00:15:47,590
and gives you a Python list
of strings-- Python list

350
00:15:47,590 --> 00:15:49,120
of strings.

351
00:15:49,120 --> 00:15:52,570
Kind of like split except
it's like a super smart split,

352
00:15:52,570 --> 00:15:53,370
right?

353
00:15:53,370 --> 00:15:56,630
It's split, but I've
directed it what to look for.

354
00:15:56,630 --> 00:16:04,560
And if-- so here's an example
of-- that's what I just did.

355
00:16:04,560 --> 00:16:06,910
Find me one or more
digits and then

356
00:16:06,910 --> 00:16:10,290
extract them-- so 2, 19, 42.

357
00:16:10,290 --> 00:16:12,990
Here I'm saying using
the same bracket syntax

358
00:16:12,990 --> 00:16:17,630
to look for a single character,
a capital A, E, I, O,

359
00:16:17,630 --> 00:16:20,880
or U, and one or more of those.

360
00:16:20,880 --> 00:16:24,480
And if you look, there are no
uppercase vowels in my string.

361
00:16:24,480 --> 00:16:26,360
So it says I want to
find all the things that

362
00:16:26,360 --> 00:16:32,500
match A, E, I, O, U. So
things like AA would match

363
00:16:32,500 --> 00:16:36,980
and, you know, OU would match.

364
00:16:36,980 --> 00:16:40,550
And so that's what we would
get if they were in the string.

365
00:16:40,550 --> 00:16:43,705
But because there are none,
we get an empty string.

366
00:16:43,705 --> 00:16:45,830
So even if there are none,
you get an empty string.

367
00:16:45,830 --> 00:16:48,270
So it always returns a string.

368
00:16:48,270 --> 00:16:51,340
It may be a zero length string.

369
00:16:51,340 --> 00:16:55,290
And that's what you
have to check, OK?

370
00:16:55,290 --> 00:17:00,980

371
00:17:00,980 --> 00:17:06,490
OK, now, matching has
this notion of greedy

372
00:17:06,490 --> 00:17:11,510
where when you put one of
these pluses or asterisks,

373
00:17:11,510 --> 00:17:15,630
it kind of has this outward
pushing feeling, right?

374
00:17:15,630 --> 00:17:18,349
And so when you say I'm
looking for something

375
00:17:18,349 --> 00:17:21,540
that starts with an F at the
beginning of the line followed

376
00:17:21,540 --> 00:17:24,730
by one or more characters
followed by a colon,

377
00:17:24,730 --> 00:17:27,220
you can think of this
as pushing outward.

378
00:17:27,220 --> 00:17:31,230
So if we look at a line
here that has from colon

379
00:17:31,230 --> 00:17:36,520
using the colon character,
it will try to expand.

380
00:17:36,520 --> 00:17:41,569
So it certainly has to match the
F. And it's looking for a colon

381
00:17:41,569 --> 00:17:42,610
any number of characters.

382
00:17:42,610 --> 00:17:44,235
But it's trying to
make the string that

383
00:17:44,235 --> 00:17:46,960
matches as big as possible.

384
00:17:46,960 --> 00:17:50,489
So it skips over this colon
and goes to that colon.

385
00:17:50,489 --> 00:17:52,030
And so the thing
that we get is here.

386
00:17:52,030 --> 00:17:55,620
And so it ignored this and said,
I will make as large a string

387
00:17:55,620 --> 00:17:57,220
as I can.

388
00:17:57,220 --> 00:17:59,520
So that's the plus
that's doing it.

389
00:17:59,520 --> 00:18:02,625
Dot plus pushes.

390
00:18:02,625 --> 00:18:06,720
It's like, I got a colon, but is
there another colon out there?

391
00:18:06,720 --> 00:18:08,130
So push it.

392
00:18:08,130 --> 00:18:10,980
OK, so that's a greedy matching.

393
00:18:10,980 --> 00:18:15,510
It can get you in some trouble
like being greedy in general.

394
00:18:15,510 --> 00:18:18,890
And both asterisk and plus
sort of behave in a greedy way

395
00:18:18,890 --> 00:18:21,600
because they're zero or more
or one or more characters.

396
00:18:21,600 --> 00:18:23,920
So they can sort
of push outward.

397
00:18:23,920 --> 00:18:28,044
OK, now you can turn this off.

398
00:18:28,044 --> 00:18:29,210
It's a programming language.

399
00:18:29,210 --> 00:18:31,790
We can tweak it, OK?

400
00:18:31,790 --> 00:18:35,780
And so we add a question mark.

401
00:18:35,780 --> 00:18:38,460
So this is a three
character sequence now.

402
00:18:38,460 --> 00:18:43,400
So if you say dot plus question
mark, that says one or more

403
00:18:43,400 --> 00:18:47,010
of any characters
push-- but instead

404
00:18:47,010 --> 00:18:50,130
of being greedy and
pushing as far as you can,

405
00:18:50,130 --> 00:18:52,760
this means stop at the first.

406
00:18:52,760 --> 00:18:57,490
Stop at the first.

407
00:18:57,490 --> 00:18:59,540
Oops-- stop at the first.

408
00:18:59,540 --> 00:19:01,820
I can never draw on
this thing fast enough.

409
00:19:01,820 --> 00:19:04,010
Stop at the first, OK?

410
00:19:04,010 --> 00:19:04,620
And that's it.

411
00:19:04,620 --> 00:19:05,640
Just don't be greedy.

412
00:19:05,640 --> 00:19:08,290
Don't try to make the
string as large as possible.

413
00:19:08,290 --> 00:19:11,140
Go with the smaller one--
the smaller possible one.

414
00:19:11,140 --> 00:19:14,400
We still need to find an F and
we still need to find a colon.

415
00:19:14,400 --> 00:19:16,620
But when you find the
first colon, stop.

416
00:19:16,620 --> 00:19:18,640
And so what this does
is this changes it

417
00:19:18,640 --> 00:19:20,890
so that what we
match is from colon

418
00:19:20,890 --> 00:19:22,720
instead of going all the way.

419
00:19:22,720 --> 00:19:25,950
So the greedy match
pushes as far as it can.

420
00:19:25,950 --> 00:19:28,220
The non greedy
match is satisfied

421
00:19:28,220 --> 00:19:32,810
with the first thing that meets
the criterion of the string.

422
00:19:32,810 --> 00:19:34,880
So this is a little three
character programming

423
00:19:34,880 --> 00:19:38,890
sequence-- any character one
or more times and not greedy.

424
00:19:38,890 --> 00:19:48,470

425
00:19:48,470 --> 00:19:51,130
If, for example, we were trying
to solve the problem of pulling

426
00:19:51,130 --> 00:19:57,290
the email address
out of a string,

427
00:19:57,290 --> 00:20:00,860
we can make good use of
this non blank character.

428
00:20:00,860 --> 00:20:04,220
And so the at sign
is just a character.

429
00:20:04,220 --> 00:20:07,200
And then we can say,
I want at least one

430
00:20:07,200 --> 00:20:09,450
non blank character
before it and at least

431
00:20:09,450 --> 00:20:11,470
one non blank
character after it.

432
00:20:11,470 --> 00:20:14,070
So the way regular
expressions does, it says, OK.

433
00:20:14,070 --> 00:20:19,434
I find my at sign and I push
in a greedy manner outwards

434
00:20:19,434 --> 00:20:21,100
as long as they're
non blank characters.

435
00:20:21,100 --> 00:20:24,130
Push, push, push, push, push,
push, push, whoops, stop.

436
00:20:24,130 --> 00:20:26,590
Push, push, push,
push, push, stop.

437
00:20:26,590 --> 00:20:31,100
OK, so it's some number of non
blank characters, an at sign,

438
00:20:31,100 --> 00:20:33,100
followed by some number
of non blank characters.

439
00:20:33,100 --> 00:20:37,020
So that's using greedy matching.

440
00:20:37,020 --> 00:20:38,620
Its doing that, OK?

441
00:20:38,620 --> 00:20:41,720
And so this is where we
get Stephen Marquard.

442
00:20:41,720 --> 00:20:45,114
And we would know if it wasn't
there by the empty list, right?

443
00:20:45,114 --> 00:20:46,780
And so we get
stephenmarquard@uct.ac.za.

444
00:20:46,780 --> 00:20:53,080

445
00:20:53,080 --> 00:20:59,360
Now, we can also fine tune
what we extract, right?

446
00:20:59,360 --> 00:21:02,570
In the previous
slide, we extracted

447
00:21:02,570 --> 00:21:06,090
whatever matched, right?

448
00:21:06,090 --> 00:21:09,330
Whatever this matched, it
looked across the whole string

449
00:21:09,330 --> 00:21:09,940
and found it.

450
00:21:09,940 --> 00:21:12,380
It found the thing,
shoved it over,

451
00:21:12,380 --> 00:21:14,650
and gave us what it matched.

452
00:21:14,650 --> 00:21:17,650
But it's possible to
make the match larger

453
00:21:17,650 --> 00:21:20,460
than what's extracted to
extract a subset of the match.

454
00:21:20,460 --> 00:21:23,800
And we'll see that on
this next slide OK?

455
00:21:23,800 --> 00:21:29,630
So here's this same
thing, which is an at

456
00:21:29,630 --> 00:21:32,080
and then with non blank
characters as far as the eye

457
00:21:32,080 --> 00:21:33,910
can see in either direction.

458
00:21:33,910 --> 00:21:38,910
But I'm going to add
to it caret from space.

459
00:21:38,910 --> 00:21:42,940
So this has to start with--
the first character is

460
00:21:42,940 --> 00:21:44,559
to be a caret.

461
00:21:44,559 --> 00:21:45,850
It's got to have the word from.

462
00:21:45,850 --> 00:21:47,720
It's got to have one space.

463
00:21:47,720 --> 00:21:50,600
And then immediately, it's
got to find this, right?

464
00:21:50,600 --> 00:21:53,110
It's got to find a series
of non blanks followed

465
00:21:53,110 --> 00:21:55,590
by an and sign followed
by another series of one

466
00:21:55,590 --> 00:21:57,120
or more non blanks.

467
00:21:57,120 --> 00:21:59,700
And then what we
do-- so if we didn't

468
00:21:59,700 --> 00:22:02,230
put these parentheses
in, it would match

469
00:22:02,230 --> 00:22:03,910
and we would get
all of this data.

470
00:22:03,910 --> 00:22:05,916
It would go to here.

471
00:22:05,916 --> 00:22:08,290
But what we can do with the
parentheses-- the parentheses

472
00:22:08,290 --> 00:22:12,460
are part of the regular
expression language-- saying,

473
00:22:12,460 --> 00:22:14,640
OK, I want to match
the whole thing.

474
00:22:14,640 --> 00:22:17,190
The parentheses aren't
part of the string up here.

475
00:22:17,190 --> 00:22:18,950
I want to match the
whole thing but I only

476
00:22:18,950 --> 00:22:21,800
want to extract this
part in parentheses.

477
00:22:21,800 --> 00:22:24,950
So this whole thing is a regular
expression that's matched.

478
00:22:24,950 --> 00:22:28,640
And then the parentheses part
is what's retrieved for you.

479
00:22:28,640 --> 00:22:31,360
And so this makes it
so that the only time

480
00:22:31,360 --> 00:22:33,375
it's going to look for
at signs are on lines

481
00:22:33,375 --> 00:22:35,130
that start with from space.

482
00:22:35,130 --> 00:22:38,240
It is going to want the
immediate next character

483
00:22:38,240 --> 00:22:41,811
to be a non blank, some number
of non-white characters,

484
00:22:41,811 --> 00:22:44,310
followed by an at sign, some
number of non blank characters.

485
00:22:44,310 --> 00:22:45,850
It's going to stop right there.

486
00:22:45,850 --> 00:22:48,980
And it's only going to
extract from here to here.

487
00:22:48,980 --> 00:22:50,580
So we get out Stephen Marquard.

488
00:22:50,580 --> 00:22:54,970
But this is a pretty
narrowly scoped thing

489
00:22:54,970 --> 00:22:56,870
because the first
four characters

490
00:22:56,870 --> 00:22:58,010
have to be from space.

491
00:22:58,010 --> 00:23:01,070
And so that's a way
to combine a stricter

492
00:23:01,070 --> 00:23:04,030
match even though you don't
actually want all the data.

493
00:23:04,030 --> 00:23:08,410
So you can add those things
all over the place, OK?

494
00:23:08,410 --> 00:23:14,070
OK, then we can compare
the different ways

495
00:23:14,070 --> 00:23:15,570
of extracting data.

496
00:23:15,570 --> 00:23:19,750
So if we look at how we
extract the hostname.

497
00:23:19,750 --> 00:23:23,200
Remember how we did
this many chapters ago.

498
00:23:23,200 --> 00:23:27,040
So we did a data dot find which
says, oh, the first at sign

499
00:23:27,040 --> 00:23:28,870
is a 21.

500
00:23:28,870 --> 00:23:30,710
So the first one is a 21.

501
00:23:30,710 --> 00:23:34,340
Then we say, we want to
find the space after that.

502
00:23:34,340 --> 00:23:35,840
So that's the at position.

503
00:23:35,840 --> 00:23:37,489
That's 31.

504
00:23:37,489 --> 00:23:39,280
And then we want to
extract the data that's

505
00:23:39,280 --> 00:23:45,080
one beyond the at up to but
not including the space.

506
00:23:45,080 --> 00:23:47,580
And that is the variable that
we're going to print out host.

507
00:23:47,580 --> 00:23:50,180
And so we extract this
bit of information

508
00:23:50,180 --> 00:23:53,890
and out comes the
host-- quite nice, OK?

509
00:23:53,890 --> 00:23:55,445
We also saw another technique.

510
00:23:55,445 --> 00:23:58,690
And by the way, all
these techniques are OK.

511
00:23:58,690 --> 00:24:00,310
All these techniques are fine.

512
00:24:00,310 --> 00:24:02,830
Another technique we saw once
we sort of played the split

513
00:24:02,830 --> 00:24:05,150
and lists was what I
call the double split

514
00:24:05,150 --> 00:24:08,580
version of this where
the first thing we do

515
00:24:08,580 --> 00:24:11,900
is we split that line.

516
00:24:11,900 --> 00:24:14,000
The first thing we do
is we split the line.

517
00:24:14,000 --> 00:24:20,540
And then we know-- and blanks--
that the second thing, which

518
00:24:20,540 --> 00:24:26,910
is the sub 1, word sub 1,
is the entire email address.

519
00:24:26,910 --> 00:24:28,740
And then this is
the double split.

520
00:24:28,740 --> 00:24:33,190
We take the email address and
we split it by an at sign.

521
00:24:33,190 --> 00:24:37,010
And then we get a list of the
pieces of the email address--

522
00:24:37,010 --> 00:24:39,260
the email name and
the email host--

523
00:24:39,260 --> 00:24:43,960
and then we grab
the sub 1 of that.

524
00:24:43,960 --> 00:24:47,210
And then we have the host
so that's the double split

525
00:24:47,210 --> 00:24:49,750
way of doing this, right?

526
00:24:49,750 --> 00:24:53,840
Now, in this, we still
haven't done the from yet.

527
00:24:53,840 --> 00:24:57,180
But it is the double
split way to do this.

528
00:24:57,180 --> 00:24:59,570
So if we think
about how we would

529
00:24:59,570 --> 00:25:05,320
do this in a regular
expression, we're

530
00:25:05,320 --> 00:25:11,540
going to say look
through the string.

531
00:25:11,540 --> 00:25:13,540
Find all-- we're going
to-- here's the find all.

532
00:25:13,540 --> 00:25:15,200
And the reg
expression exploded up

533
00:25:15,200 --> 00:25:17,692
says, look through
the string for an and.

534
00:25:17,692 --> 00:25:20,960
Do, do, do, do, got an and.

535
00:25:20,960 --> 00:25:25,620
Then, oh, start
extracting and extracting.

536
00:25:25,620 --> 00:25:28,560
And then this is another
form of the sync--

537
00:25:28,560 --> 00:25:30,941
this is one character.

538
00:25:30,941 --> 00:25:31,940
It's a single character.

539
00:25:31,940 --> 00:25:37,400
Match any non blank character
and zero or more of them, OK?

540
00:25:37,400 --> 00:25:41,760
So find an at sign.

541
00:25:41,760 --> 00:25:45,790
Start extracting and extracting.

542
00:25:45,790 --> 00:25:48,010
Match this is one character.

543
00:25:48,010 --> 00:25:50,940
That is a set of
possible matches.

544
00:25:50,940 --> 00:25:52,990
And that's some character.

545
00:25:52,990 --> 00:25:58,235
This means not-- not a blank.

546
00:25:58,235 --> 00:25:59,360
That's a blank right there.

547
00:25:59,360 --> 00:26:01,130
That's a plane
character right there--

548
00:26:01,130 --> 00:26:03,940
not a blank as many
times as you want.

549
00:26:03,940 --> 00:26:05,800
You might want to
turn that into a plus

550
00:26:05,800 --> 00:26:07,911
to guarantee at least one.

551
00:26:07,911 --> 00:26:09,910
That might be better done
as a plus right there.

552
00:26:09,910 --> 00:26:13,343

553
00:26:13,343 --> 00:26:14,926
So this would probably
make more sense

554
00:26:14,926 --> 00:26:18,190
as a plus to say I want at
least-- after the at sign, I

555
00:26:18,190 --> 00:26:20,805
want at least one
non blank character.

556
00:26:20,805 --> 00:26:26,250

557
00:26:26,250 --> 00:26:30,840
And the parentheses simply
say I don't want the at sign.

558
00:26:30,840 --> 00:26:34,100
So the at sign-- I really want
those non blank characters

559
00:26:34,100 --> 00:26:36,310
after the at sign.

560
00:26:36,310 --> 00:26:38,550
So that's what I
want to extract.

561
00:26:38,550 --> 00:26:41,880
So it's like, go
find the at sign.

562
00:26:41,880 --> 00:26:43,280
OK, great, found the at sign.

563
00:26:43,280 --> 00:26:44,870
Start extracting.

564
00:26:44,870 --> 00:26:47,960
Look for non blank
characters and extracting.

565
00:26:47,960 --> 00:26:52,640
So pull that part out
and put it right there.

566
00:26:52,640 --> 00:26:56,720
Now, an even cooler version
of this that you probably

567
00:26:56,720 --> 00:27:04,190
kind of imagined right away
is we say, you know what?

568
00:27:04,190 --> 00:27:06,709
I would like this
first character

569
00:27:06,709 --> 00:27:08,250
to-- the first part
of the line to be

570
00:27:08,250 --> 00:27:17,190
from with a blank followed
by any number of characters

571
00:27:17,190 --> 00:27:18,870
followed by an at sign.

572
00:27:18,870 --> 00:27:20,420
So the at sign is real.

573
00:27:20,420 --> 00:27:25,070
Then start extracting, then any
number of non blank characters

574
00:27:25,070 --> 00:27:27,350
and extracting.

575
00:27:27,350 --> 00:27:32,420
So this is like eight
or nine lines of Python

576
00:27:32,420 --> 00:27:35,650
all rolled into one thing, OK?

577
00:27:35,650 --> 00:27:38,800

578
00:27:38,800 --> 00:27:41,470
so start at the
beginning of the line.

579
00:27:41,470 --> 00:27:44,210
Look for string
from with a space.

580
00:27:44,210 --> 00:27:49,040
Then skip a bunch of characters
looking for an at sign.

581
00:27:49,040 --> 00:27:52,350
Skip characters until
you encounter an at sign.

582
00:27:52,350 --> 00:27:55,590
Then start extracting.

583
00:27:55,590 --> 00:27:58,230
Match any non blank-- a
single non blank character.

584
00:27:58,230 --> 00:28:02,495
So this is kind of like one
non blank character, one non

585
00:28:02,495 --> 00:28:03,300
blank character.

586
00:28:03,300 --> 00:28:05,780
But once you suffix
it with the asterisk,

587
00:28:05,780 --> 00:28:10,570
that changes it to be
many non blank characters.

588
00:28:10,570 --> 00:28:15,340
And then stop extracting, OK?

589
00:28:15,340 --> 00:28:20,660
So it's like, find from
followed by a space-- great.

590
00:28:20,660 --> 00:28:22,280
That's the first part.

591
00:28:22,280 --> 00:28:26,140
Now throw away until
you find an at sign.

592
00:28:26,140 --> 00:28:28,060
Then start extracting.

593
00:28:28,060 --> 00:28:30,870
Keep going with non
blank characters

594
00:28:30,870 --> 00:28:33,210
until you hit the
first blank characters

595
00:28:33,210 --> 00:28:34,290
and pull that part out.

596
00:28:34,290 --> 00:28:36,620
Now, the result is we
get the exact same data.

597
00:28:36,620 --> 00:28:40,530
But with this added
to it, we're much more

598
00:28:40,530 --> 00:28:43,010
narrow in the kind of things
that we're looking for.

599
00:28:43,010 --> 00:28:46,330
And if we get noisy data that
like-- say something like,

600
00:28:46,330 --> 00:28:52,100
you know, meet at Joe's, right?

601
00:28:52,100 --> 00:28:53,040
We don't want that.

602
00:28:53,040 --> 00:28:54,040
That won't match, right?

603
00:28:54,040 --> 00:28:56,180
We want that to be like a false.

604
00:28:56,180 --> 00:28:58,330
And that allows us
to sort of really

605
00:28:58,330 --> 00:28:59,979
fine tune our matching
and extracting.

606
00:28:59,979 --> 00:29:01,270
And this is just the beginning.

607
00:29:01,270 --> 00:29:03,050
They're very, very powerful.

608
00:29:03,050 --> 00:29:05,620
So the last thing
that I will show you

609
00:29:05,620 --> 00:29:08,830
is sort of a program
that is kind of like one

610
00:29:08,830 --> 00:29:11,860
of the programs that we
did in a previous section.

611
00:29:11,860 --> 00:29:14,550
Except now, we're going to use
regular expressions to do it.

612
00:29:14,550 --> 00:29:16,110
So if you remember,
we had this thing

613
00:29:16,110 --> 00:29:17,985
where we're doing spam
confidence where we're

614
00:29:17,985 --> 00:29:23,330
looking for lines and pulling
this number out and then

615
00:29:23,330 --> 00:29:26,390
calculating you the average
or the maximum or whatever.

616
00:29:26,390 --> 00:29:30,050
And so here is a-- we import
the regular expression library.

617
00:29:30,050 --> 00:29:31,289
We open the file.

618
00:29:31,289 --> 00:29:32,830
We're going to do
this with appending

619
00:29:32,830 --> 00:29:36,340
to a list-- we'll put
the numbers in a list

620
00:29:36,340 --> 00:29:39,190
rather than doing the
calculational loop.

621
00:29:39,190 --> 00:29:40,330
We strip the data.

622
00:29:40,330 --> 00:29:42,170
Now, here's the
key thing, right?

623
00:29:42,170 --> 00:29:44,240
We're going to have a
regular expression that

624
00:29:44,240 --> 00:29:47,750
says, look for the
first character

625
00:29:47,750 --> 00:29:50,900
being x followed by a
dash followed by all this.

626
00:29:50,900 --> 00:29:54,730
All this exactly has to match
literally followed by a colon.

627
00:29:54,730 --> 00:29:56,820
And then there's a space.

628
00:29:56,820 --> 00:29:59,030
And then we begin extracting.

629
00:29:59,030 --> 00:30:03,510
And we're looking for the
digits 0 through 9 or a dot.

630
00:30:03,510 --> 00:30:08,686
And we're looking
for one or more.

631
00:30:08,686 --> 00:30:09,810
And then we end extracting.

632
00:30:09,810 --> 00:30:12,342
So that's-- the parentheses are
telling us what to pull out.

633
00:30:12,342 --> 00:30:13,800
So that just means
that we're going

634
00:30:13,800 --> 00:30:16,860
to pull out those numbers, all
the digits and the numbers,

635
00:30:16,860 --> 00:30:19,610
until we get something-- I mean,
all the digits and the period

636
00:30:19,610 --> 00:30:22,440
and we'll get something other
than a digit and a period.

637
00:30:22,440 --> 00:30:26,130
And then we'll be done, OK?

638
00:30:26,130 --> 00:30:29,260
And so this is going to pull
those numbers out and give us

639
00:30:29,260 --> 00:30:29,904
back a list.

640
00:30:29,904 --> 00:30:31,320
Now, the thing
about it is we have

641
00:30:31,320 --> 00:30:34,640
to realize that sometimes
this is not going to match.

642
00:30:34,640 --> 00:30:37,120
Because we're sending
every line-- not just

643
00:30:37,120 --> 00:30:38,680
the ones that start with x.

644
00:30:38,680 --> 00:30:40,540
We're sending every
line through this.

645
00:30:40,540 --> 00:30:44,270
And so we need to know
when we didn't get a match.

646
00:30:44,270 --> 00:30:47,950
And the way we know we didn't
get a match is if the list

647
00:30:47,950 --> 00:30:51,280
the number of items in the
list that we got back is zero,

648
00:30:51,280 --> 00:30:52,570
then we're going to continue.

649
00:30:52,570 --> 00:30:55,320
So this is kind of
our if we're searching

650
00:30:55,320 --> 00:30:57,010
for the needle in the haystack.

651
00:30:57,010 --> 00:31:00,690
But then once we find
what we're looking for,

652
00:31:00,690 --> 00:31:04,560
the actual number that
we're interested in

653
00:31:04,560 --> 00:31:08,340
is already sitting here
in stuff sub 0, OK?

654
00:31:08,340 --> 00:31:09,680
And then we convert to a float.

655
00:31:09,680 --> 00:31:10,550
We append it.

656
00:31:10,550 --> 00:31:12,110
And then when the
loop is all done,

657
00:31:12,110 --> 00:31:14,900
we print out the maximum, OK?

658
00:31:14,900 --> 00:31:17,150
And so this is sort of
encoding a number of things

659
00:31:17,150 --> 00:31:22,060
and ending up with a very
solid and safe matching.

660
00:31:22,060 --> 00:31:23,850
So we're really--
it's hard for this

661
00:31:23,850 --> 00:31:25,860
to find a line that's wrong.

662
00:31:25,860 --> 00:31:28,020
And you could even
improve this a little bit

663
00:31:28,020 --> 00:31:30,030
to make it even a little
tighter where it would

664
00:31:30,030 --> 00:31:33,440
go find a number like 0.999.

665
00:31:33,440 --> 00:31:41,070
You could say, oh, it's--
all the numbers are 0 dot--

666
00:31:41,070 --> 00:31:48,630
so you could make this a little
more so it would even skip

667
00:31:48,630 --> 00:31:51,530
things that-- you can make it
so it looks exactly the way you

668
00:31:51,530 --> 00:31:52,560
want to look.

669
00:31:52,560 --> 00:31:55,880
So I emphasize that this is
kind of a weird language.

670
00:31:55,880 --> 00:31:57,430
And you need some kind of thing.

671
00:31:57,430 --> 00:31:59,190
We talked about all these.

672
00:31:59,190 --> 00:32:00,815
We have the beginning of a line.

673
00:32:00,815 --> 00:32:03,980
We have the end of the line
matching any character,

674
00:32:03,980 --> 00:32:05,760
matching space
characters, matching

675
00:32:05,760 --> 00:32:07,920
non-whitespace characters.

676
00:32:07,920 --> 00:32:13,150
Star is a modifier that
says zero or more times.

677
00:32:13,150 --> 00:32:16,610
Star question mark is a
modifier that says zero or more

678
00:32:16,610 --> 00:32:18,520
times non greedy.

679
00:32:18,520 --> 00:32:21,010
Plus is one or more times.

680
00:32:21,010 --> 00:32:25,400
Plus question mark is one
or more times non greedy.

681
00:32:25,400 --> 00:32:27,770
When you have bracket
syntax, it's a set.

682
00:32:27,770 --> 00:32:30,640
It's a single character
that's in the listed set.

683
00:32:30,640 --> 00:32:33,671
So that's lowercase vowels.

684
00:32:33,671 --> 00:32:36,170
You can also have the first--
if the first character of this

685
00:32:36,170 --> 00:32:38,680
is a caret, that flips it.

686
00:32:38,680 --> 00:32:40,990
So that means everything
except capital X,

687
00:32:40,990 --> 00:32:43,510
capital Y, capital
Z. So it's everything

688
00:32:43,510 --> 00:32:47,920
that's not in the set capital
X, capital Y, capital Z.

689
00:32:47,920 --> 00:32:51,090
And then you can also put
dashes in to represent ranges.

690
00:32:51,090 --> 00:32:54,200
Bracket a through z and 0
through 9 in lowercase letters

691
00:32:54,200 --> 00:32:55,840
and digits will match.

692
00:32:55,840 --> 00:32:58,550
But again, this is
a single character.

693
00:32:58,550 --> 00:33:01,670
Now, you can put a plus
or a star after these guys

694
00:33:01,670 --> 00:33:04,272
to make them happen
more than one time.

695
00:33:04,272 --> 00:33:05,730
And you can even
put them in twice.

696
00:33:05,730 --> 00:33:12,800
So if I wanted a two digit
number, I could say 0-9, 0-9.

697
00:33:12,800 --> 00:33:15,850
Oops, this is one character.

698
00:33:15,850 --> 00:33:18,350
This is one character and
this is the possible things.

699
00:33:18,350 --> 00:33:23,660
So that's, you know, 000 0
would match, 10 would match,

700
00:33:23,660 --> 00:33:25,970
99 would match, et cetera.

701
00:33:25,970 --> 00:33:28,990

702
00:33:28,990 --> 00:33:31,190
And then the parentheses
are the things

703
00:33:31,190 --> 00:33:33,814
that if you are in the middle
of a big long matching string

704
00:33:33,814 --> 00:33:35,730
and you don't want to
extract the whole thing,

705
00:33:35,730 --> 00:33:39,970
you can limit the things you're
extracting to the stuff that's

706
00:33:39,970 --> 00:33:41,490
just in there.

707
00:33:41,490 --> 00:33:44,000
With all these characters
that have all this meaning,

708
00:33:44,000 --> 00:33:46,460
we have to have a way to
match those characters.

709
00:33:46,460 --> 00:33:49,956
So dollar sign is
the end of a line.

710
00:33:49,956 --> 00:33:52,330
But what if we're looking for
something that actually has

711
00:33:52,330 --> 00:33:54,740
a dollar sign in the string?

712
00:33:54,740 --> 00:33:56,830
And that's what the
backslash is for.

713
00:33:56,830 --> 00:33:58,330
So if you put the
backslash in front

714
00:33:58,330 --> 00:34:02,880
of a otherwise
meaningful character,

715
00:34:02,880 --> 00:34:04,360
it becomes the actual character.

716
00:34:04,360 --> 00:34:06,980
So this is saying
match a dollar sign.

717
00:34:06,980 --> 00:34:09,219
Those two character say
match a dollar sign.

718
00:34:09,219 --> 00:34:13,679
And then this says one character
that's 0 through 9 or a dot.

719
00:34:13,679 --> 00:34:16,020
And then we put
the plus modifier

720
00:34:16,020 --> 00:34:18,810
to say at least
one or more times.

721
00:34:18,810 --> 00:34:21,350
And so that sort of is
a greedy, of course.

722
00:34:21,350 --> 00:34:24,040
So that will get us
this and extract it,

723
00:34:24,040 --> 00:34:25,139
including the dollar sign.

724
00:34:25,139 --> 00:34:29,290
So the escape character
is the backslash.

725
00:34:29,290 --> 00:34:31,044
OK, so there we are.

726
00:34:31,044 --> 00:34:32,440
Now we're done.

727
00:34:32,440 --> 00:34:34,560
So this is a little bit cryptic.

728
00:34:34,560 --> 00:34:38,040
It's kind of a puzzle.

729
00:34:38,040 --> 00:34:41,250
It's kind of fun and
it's extremely powerful.

730
00:34:41,250 --> 00:34:42,860
And you don't have to know it.

731
00:34:42,860 --> 00:34:45,199
You don't have to learn it.

732
00:34:45,199 --> 00:34:47,489
But if you do,
you'll find that it's

733
00:34:47,489 --> 00:34:50,590
very useful as we sort
of dig through data

734
00:34:50,590 --> 00:34:53,150
and are trying to write
things that are pretty quick.

735
00:34:53,150 --> 00:34:57,000
And the thing I like
about regular expressions

736
00:34:57,000 --> 00:35:00,850
is that they tend to be,
if you write them well,

737
00:35:00,850 --> 00:35:04,690
they tend to be less
sensitive to bad data.

738
00:35:04,690 --> 00:35:06,540
They tend to ignore data there.

739
00:35:06,540 --> 00:35:07,750
You can put more detail.

740
00:35:07,750 --> 00:35:09,790
I exactly want this.

741
00:35:09,790 --> 00:35:12,160
Or if you're writing
find and extract,

742
00:35:12,160 --> 00:35:14,310
you're making a lot of
assumptions about the data--

743
00:35:14,310 --> 00:35:17,400
that it's clean and you're not
going to miss hit on something.

744
00:35:17,400 --> 00:35:22,170
So OK, well, good luck in your
use of regular expressions

745
00:35:22,170 --> 00:35:24,610
and we'll see you later.
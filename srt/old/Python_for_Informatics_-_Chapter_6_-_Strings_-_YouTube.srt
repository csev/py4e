1
00:00:00,000 --> 00:00:00,499

2
00:00:00,499 --> 00:00:02,800
Hello and welcome to Chapter 6.

3
00:00:02,800 --> 00:00:05,050
This chapter, we're going
to talk about strings.

4
00:00:05,050 --> 00:00:08,680
And stuff is going to
start to get real now.

5
00:00:08,680 --> 00:00:12,970
So as always, this material,
this video, these slides,

6
00:00:12,970 --> 00:00:15,500
and what are copyright
Creative Commons attribution.

7
00:00:15,500 --> 00:00:18,292
I want you to use
these materials.

8
00:00:18,292 --> 00:00:19,500
I want to make more teachers.

9
00:00:19,500 --> 00:00:21,700
So everyone can
teach this stuff.

10
00:00:21,700 --> 00:00:23,990
Use it however you like.

11
00:00:23,990 --> 00:00:26,740
OK, so we've been playing with
strings from the beginning.

12
00:00:26,740 --> 00:00:28,950
I mean, literally, if we
didn't work with strings,

13
00:00:28,950 --> 00:00:31,390
we could have never
printed "Hello, World."

14
00:00:31,390 --> 00:00:34,470
And Lord knows we need
to print Hello, World

15
00:00:34,470 --> 00:00:35,800
in a programming language.

16
00:00:35,800 --> 00:00:39,640
And so, we've been using
them, especially constants.

17
00:00:39,640 --> 00:00:42,910
Now in this chapter,
we're going to dig in.

18
00:00:42,910 --> 00:00:43,670
Oops.

19
00:00:43,670 --> 00:00:46,980
So a string is a
sequence of characters.

20
00:00:46,980 --> 00:00:50,410
You can either use single quotes
or double quotes in Python

21
00:00:50,410 --> 00:00:51,420
to delimit a string.

22
00:00:51,420 --> 00:00:54,270
And so, here's two string
constants, hello and there,

23
00:00:54,270 --> 00:00:58,210
and stuck into the variables
stir one and stir two.

24
00:00:58,210 --> 00:01:00,560
We can concatenate them
together with a plus sign.

25
00:01:00,560 --> 00:01:03,860
Python is smart enough to look
and say, oh, those are strings.

26
00:01:03,860 --> 00:01:05,922
I know what to do with those.

27
00:01:05,922 --> 00:01:08,380
And you'll notice that the plus
doesn't add any space here.

28
00:01:08,380 --> 00:01:11,750
Because when we print
"Bob" out, hello and there

29
00:01:11,750 --> 00:01:14,870
are right next to one another.

30
00:01:14,870 --> 00:01:18,380
If for example, when
we're, like, reading

31
00:01:18,380 --> 00:01:19,780
pay and rate and
hours and stuff,

32
00:01:19,780 --> 00:01:20,946
we've done some conversions.

33
00:01:20,946 --> 00:01:25,440
So this an example of a string
1-2-3, not 123, but the string,

34
00:01:25,440 --> 00:01:27,630
quote, "123," quote.

35
00:01:27,630 --> 00:01:28,850
And we can't add 1 to this.

36
00:01:28,850 --> 00:01:30,892
We get a traceback.

37
00:01:30,892 --> 00:01:32,725
We're kind of at this
point, as we expected.

38
00:01:32,725 --> 00:01:34,920
And we would convert
that to an integer,

39
00:01:34,920 --> 00:01:36,819
using the INT function
that's built in.

40
00:01:36,819 --> 00:01:38,360
See how much Python
you already know?

41
00:01:38,360 --> 00:01:39,890
I mean, this is awesome, right?

42
00:01:39,890 --> 00:01:42,040
I can just say, oh, you
call the INT function,

43
00:01:42,040 --> 00:01:43,640
and you know what that is.

44
00:01:43,640 --> 00:01:45,855
Sorry, I'm just awesomed out.

45
00:01:45,855 --> 00:01:48,010
So you convert
this to an integer.

46
00:01:48,010 --> 00:01:49,180
And then, you add 1 to it.

47
00:01:49,180 --> 00:01:50,870
And then, we get 124.

48
00:01:50,870 --> 00:01:52,370
So there you go.

49
00:01:52,370 --> 00:01:54,730
We've been doing strings
all along, had to.

50
00:01:54,730 --> 00:01:57,150
I mean, literally,
strings and numeric data

51
00:01:57,150 --> 00:01:59,880
are the two things that
programs deal with.

52
00:01:59,880 --> 00:02:03,220
So we've been reading
and converting.

53
00:02:03,220 --> 00:02:05,880
Again, this is a pattern from
some of the earlier programs

54
00:02:05,880 --> 00:02:08,470
where we do a raw input.

55
00:02:08,470 --> 00:02:10,040
And the raw input
just takes a string

56
00:02:10,040 --> 00:02:11,400
and puts it in a variable.

57
00:02:11,400 --> 00:02:14,020
So if I take "Chuck," then the
variable contains the string

58
00:02:14,020 --> 00:02:20,000
C-H-U-C-K. Even if we type
numbers, that is a string.

59
00:02:20,000 --> 00:02:23,640
Just because I put 1-0-0 in,
I still can't subtract 10.

60
00:02:23,640 --> 00:02:25,180
We get a happy little traceback.

61
00:02:25,180 --> 00:02:27,240
Oh, happy, little,
sad faced traceback.

62
00:02:27,240 --> 00:02:30,560

63
00:02:30,560 --> 00:02:33,470
But of course, if we convert
it INT or Float or something

64
00:02:33,470 --> 00:02:38,040
like that, we can do
that and subtract 10.

65
00:02:38,040 --> 00:02:39,470
And we can do that.

66
00:02:39,470 --> 00:02:41,379
So we've been doing
this for a while.

67
00:02:41,379 --> 00:02:43,420
We've been doing strings
and manipulating strings

68
00:02:43,420 --> 00:02:45,079
and converting
strings all along.

69
00:02:45,079 --> 00:02:46,870
So the thing we're
going to start doing now

70
00:02:46,870 --> 00:02:48,670
is we're going to
dive into strings.

71
00:02:48,670 --> 00:02:52,210
We realize that strings
are addressable at

72
00:02:52,210 --> 00:02:53,620
a character-by-character basis.

73
00:02:53,620 --> 00:02:56,440
And we can do all kind
of cool things with that.

74
00:02:56,440 --> 00:03:00,400
And so, a string is a
sequence of characters.

75
00:03:00,400 --> 00:03:03,280
And we can look inside them,
using what we call the index

76
00:03:03,280 --> 00:03:05,564
operator, the square brackets.

77
00:03:05,564 --> 00:03:07,230
And we've seen square
brackets in lists.

78
00:03:07,230 --> 00:03:08,896
And you'll see that
they're similarities

79
00:03:08,896 --> 00:03:10,930
between lists of numbers.

80
00:03:10,930 --> 00:03:12,900
And in effect, a string
as a special kind of

81
00:03:12,900 --> 00:03:14,340
list of characters.

82
00:03:14,340 --> 00:03:19,220
So we take the string "banana."

83
00:03:19,220 --> 00:03:21,140
The first character starts at 0.

84
00:03:21,140 --> 00:03:24,060
So we call this operator, "sub."

85
00:03:24,060 --> 00:03:26,616
So letter equals fruit sub 1.

86
00:03:26,616 --> 00:03:27,990
And that is the
second character.

87
00:03:27,990 --> 00:03:29,680
Now, this may seem
a little weird

88
00:03:29,680 --> 00:03:32,630
that the first character is
a 0 and the second character

89
00:03:32,630 --> 00:03:34,220
is a 1.

90
00:03:34,220 --> 00:03:36,990
It actually is similar
to the old elevator thing

91
00:03:36,990 --> 00:03:41,020
where, in Europe, the first
floor is zero, and then

92
00:03:41,020 --> 00:03:42,830
negative one, and the
second floor is one.

93
00:03:42,830 --> 00:03:43,480
All right.

94
00:03:43,480 --> 00:03:44,670
It's kind of the same thing.

95
00:03:44,670 --> 00:03:48,620
Actually, it turns out that
internally 0 is a better way

96
00:03:48,620 --> 00:03:51,120
to start than 1.

97
00:03:51,120 --> 00:03:52,430
You'll get used to it.

98
00:03:52,430 --> 00:03:55,000
And then after a while, there's
some little cool advantages

99
00:03:55,000 --> 00:03:55,680
to it.

100
00:03:55,680 --> 00:03:59,855
But for now, just
beginning at 0.

101
00:03:59,855 --> 00:04:01,300
It is the rule.

102
00:04:01,300 --> 00:04:02,960
Just remember it.

103
00:04:02,960 --> 00:04:06,410
OK, so the 0 is B,
the 1 is A, the 2

104
00:04:06,410 --> 00:04:08,820
is N, et cetera, et cetera.

105
00:04:08,820 --> 00:04:11,790
And we call this
syntax "fruit sub 1."

106
00:04:11,790 --> 00:04:16,160
OK, so that is the sub
1 character of fruit.

107
00:04:16,160 --> 00:04:18,220
And then, that is
an A. So that fruit

108
00:04:18,220 --> 00:04:21,990
sub 1 says, look up in
banana, find the 1 position,

109
00:04:21,990 --> 00:04:23,910
and give me what's
in that 1 position.

110
00:04:23,910 --> 00:04:25,870
That's what the sub.

111
00:04:25,870 --> 00:04:29,710
And what's inside these
brackets can be an expression.

112
00:04:29,710 --> 00:04:33,860
So if we set N to 3, N minus
1, well, that'll compute to 2.

113
00:04:33,860 --> 00:04:37,160
And then, fruit sub
2 is the letter N.

114
00:04:37,160 --> 00:04:37,780
All right?

115
00:04:37,780 --> 00:04:39,790
So that's fruit sub 2.

116
00:04:39,790 --> 00:04:42,110
It's the third
character, fruit sub 2.

117
00:04:42,110 --> 00:04:44,330
So the index starts at 0.

118
00:04:44,330 --> 00:04:49,850
We read the brackets as sub,
fruit sub 1, fruit sub 2.

119
00:04:49,850 --> 00:04:56,050
Now, Python will complain to
you if you use this sub operator

120
00:04:56,050 --> 00:04:57,870
too far down the string.

121
00:04:57,870 --> 00:05:01,130
Here is a character with
3, which is 0, 1, and 2.

122
00:05:01,130 --> 00:05:05,430
And if we go to
sub 5, it blows up.

123
00:05:05,430 --> 00:05:08,850
Now you know, by now, I hope
that you're not freaking out

124
00:05:08,850 --> 00:05:10,280
about traceback errors.

125
00:05:10,280 --> 00:05:12,660
Remember, traceback
errors are just

126
00:05:12,660 --> 00:05:14,585
Python trying to inform you.

127
00:05:14,585 --> 00:05:18,800
And if we just stop looking
at that as mean Python face

128
00:05:18,800 --> 00:05:22,010
and instead look at that
as, oh, index error.

129
00:05:22,010 --> 00:05:23,870
String index out of range.

130
00:05:23,870 --> 00:05:25,649
Oh yeah, I stuck a 5 in there.

131
00:05:25,649 --> 00:05:26,440
And there's only 3.

132
00:05:26,440 --> 00:05:29,110
Ugh, my bad, thank you, Python.

133
00:05:29,110 --> 00:05:30,000
Appreciate it.

134
00:05:30,000 --> 00:05:31,370
Thanks for the help.

135
00:05:31,370 --> 00:05:34,890
So think of this like--
it's not a smiley face.

136
00:05:34,890 --> 00:05:37,830
But it's kind of like
a quizzical face.

137
00:05:37,830 --> 00:05:40,100
Right, it's saying, eh, I
don't So Python is confused,

138
00:05:40,100 --> 00:05:41,975
and it's trying to tell
you what is confused.

139
00:05:41,975 --> 00:05:42,940
OK?

140
00:05:42,940 --> 00:05:44,910
So don't look at
these as sad faces.

141
00:05:44,910 --> 00:05:45,910
Python doesn't hate you.

142
00:05:45,910 --> 00:05:50,120
Python loves you,
and loves me too.

143
00:05:50,120 --> 00:05:52,617
So strings have
individual characters

144
00:05:52,617 --> 00:05:54,450
that we can address
with the index operator.

145
00:05:54,450 --> 00:05:56,180
They also have length.

146
00:05:56,180 --> 00:05:58,900
And there is a built-in
function called Len

147
00:05:58,900 --> 00:06:03,040
that we can call and pass in
as a parameter, the variable,

148
00:06:03,040 --> 00:06:03,960
or a constant.

149
00:06:03,960 --> 00:06:06,060
And it will tell us
how many characters.

150
00:06:06,060 --> 00:06:08,990
Now, this banana has
six characters in it

151
00:06:08,990 --> 00:06:09,929
that are 0 through 5.

152
00:06:09,929 --> 00:06:11,220
So don't get a little confused.

153
00:06:11,220 --> 00:06:15,572
The last character is sub 5, but
it's also the sixth character.

154
00:06:15,572 --> 00:06:17,030
So the length is
really the length.

155
00:06:17,030 --> 00:06:20,290
It's not length minus 1.

156
00:06:20,290 --> 00:06:22,150
So Len is like a
built-in function.

157
00:06:22,150 --> 00:06:23,850
It's not a function
we have to write.

158
00:06:23,850 --> 00:06:25,951
As we talk about in
the functions chapter,

159
00:06:25,951 --> 00:06:27,825
there are things that
are part of Python that

160
00:06:27,825 --> 00:06:28,783
are just sitting there.

161
00:06:28,783 --> 00:06:32,530
And so, we are passing
banana, the variable fruit,

162
00:06:32,530 --> 00:06:36,610
into function, and then
into the Len function.

163
00:06:36,610 --> 00:06:39,540
Then, Len-- shhh--
does magic stuff.

164
00:06:39,540 --> 00:06:42,240
And then, out comes the answer.

165
00:06:42,240 --> 00:06:44,260
And that 6 replaces this.

166
00:06:44,260 --> 00:06:48,430
And then, the 6 goes into the
variable X. And so X is 6.

167
00:06:48,430 --> 00:06:51,040
I sure made that a
messy looking slide.

168
00:06:51,040 --> 00:06:53,840
And so, think of inside
the Len function.

169
00:06:53,840 --> 00:06:55,630
There's a Def Len.

170
00:06:55,630 --> 00:06:58,680
It takes a parameter,
does sound loopy things.

171
00:06:58,680 --> 00:07:00,030
And it does its thing.

172
00:07:00,030 --> 00:07:03,120
So it's a function that we might
write, except we don't have to.

173
00:07:03,120 --> 00:07:07,170
Because it's already written
and built into Python.

174
00:07:07,170 --> 00:07:10,764
OK, so that's length
of the string.

175
00:07:10,764 --> 00:07:12,430
That's getting it
individual characters.

176
00:07:12,430 --> 00:07:15,570
We can also loop
through strings.

177
00:07:15,570 --> 00:07:18,490
Obviously, if we can
use the index operator

178
00:07:18,490 --> 00:07:21,990
and we can put a variable in
there, we can write a loop.

179
00:07:21,990 --> 00:07:23,530
This is an indefinite loop.

180
00:07:23,530 --> 00:07:25,020
So we have this variable fruit.

181
00:07:25,020 --> 00:07:27,150
It has the string banana in it.

182
00:07:27,150 --> 00:07:29,600
We set the variable index to 0.

183
00:07:29,600 --> 00:07:31,640
We make a little wild loop.

184
00:07:31,640 --> 00:07:35,580
And we ask, as long as index is
less than the length of fruit--

185
00:07:35,580 --> 00:07:37,706
now remember, the length
of fruit is going to be 6.

186
00:07:37,706 --> 00:07:39,913
But we don't want to make
that less than or equal to,

187
00:07:39,913 --> 00:07:41,250
because then we would crash.

188
00:07:41,250 --> 00:07:43,650
Because the last character is 5.

189
00:07:43,650 --> 00:07:45,680
We can say, letter is
equal to fruits sub index.

190
00:07:45,680 --> 00:07:48,630
So that's going to start
out, index is going to be 0.

191
00:07:48,630 --> 00:07:50,060
So that's fruit sub 0.

192
00:07:50,060 --> 00:07:51,700
Then, we print index and letter.

193
00:07:51,700 --> 00:07:54,330
So that means the first
time through the loop,

194
00:07:54,330 --> 00:07:56,250
we're going to see 0B.

195
00:07:56,250 --> 00:08:01,930
Then, we increment our iteration
operator, and we go up.

196
00:08:01,930 --> 00:08:03,570
And then, we come up with 1A.

197
00:08:03,570 --> 00:08:10,580
And index advances
until index is 6,

198
00:08:10,580 --> 00:08:13,570
but has printed out
each of the letters.

199
00:08:13,570 --> 00:08:16,430
Now, we're not doing this
just to print them out.

200
00:08:16,430 --> 00:08:23,130
We will do something a little
more valuable inside that loop.

201
00:08:23,130 --> 00:08:26,950
But this gives the sense that
we can work through a loop,

202
00:08:26,950 --> 00:08:31,410
just like we can work
through a string,

203
00:08:31,410 --> 00:08:35,169
just like we work through
a list of numbers.

204
00:08:35,169 --> 00:08:38,630
Now, that was how you do
it with an indefinite loop.

205
00:08:38,630 --> 00:08:42,039
In a definite loop, it's
just far more awesome.

206
00:08:42,039 --> 00:08:46,130
OK, just like we did
with the list of numbers,

207
00:08:46,130 --> 00:08:50,050
Python understands strings and
allows us to write four loops,

208
00:08:50,050 --> 00:08:53,390
using 4 and N that go
through the strings.

209
00:08:53,390 --> 00:08:56,230
So basically, for letter
in fruit-- now remember,

210
00:08:56,230 --> 00:08:58,270
I'm using letter as a
pneumatic variable here.

211
00:08:58,270 --> 00:09:01,210
It's just a wise choice
of a variable name.

212
00:09:01,210 --> 00:09:03,760
So that says, run this
little block of text

213
00:09:03,760 --> 00:09:06,560
once for each letter
in the variable fruit.

214
00:09:06,560 --> 00:09:09,060
Which means that letters are
going to take on the successive

215
00:09:09,060 --> 00:09:14,430
B-A-N-A-N-A. When
I look at that,

216
00:09:14,430 --> 00:09:15,930
I always worry that
I misspelled it.

217
00:09:15,930 --> 00:09:18,819
I think I got these right.

218
00:09:18,819 --> 00:09:20,360
If I rewrite this
book, I'm not going

219
00:09:20,360 --> 00:09:21,750
to use banana as the example.

220
00:09:21,750 --> 00:09:24,240
Because I'm terrified
that I misspelled banana.

221
00:09:24,240 --> 00:09:27,210
Because I don't know how
many N's banana has in it.

222
00:09:27,210 --> 00:09:30,760
But be that as it may,
we are abstracting.

223
00:09:30,760 --> 00:09:34,500
We are letting Python say, run
this little block of text once,

224
00:09:34,500 --> 00:09:37,400
in order for each of the
letters in the variable fruit,

225
00:09:37,400 --> 00:09:40,960
which is B-A-N-A. And so, it
prints out each of the letters.

226
00:09:40,960 --> 00:09:46,090
So this is a much prettier
version of the looping.

227
00:09:46,090 --> 00:09:49,630
So using the definite, the
For keyword instead of the

228
00:09:49,630 --> 00:09:50,640
While keyword.

229
00:09:50,640 --> 00:09:54,080
And so, we can just
compare these two things.

230
00:09:54,080 --> 00:09:55,930
They kind of do the
exact same thing.

231
00:09:55,930 --> 00:10:01,120
And it also gives you a sense
of what the For is doing for us.

232
00:10:01,120 --> 00:10:03,190
The For is setting
up this index.

233
00:10:03,190 --> 00:10:06,120
The For is looking
up inside of fruit.

234
00:10:06,120 --> 00:10:08,200
And the For is
advancing the index.

235
00:10:08,200 --> 00:10:10,050
So the For is doing a
bunch of work for us.

236
00:10:10,050 --> 00:10:12,410
And I've characterize that
in the previous lecture,

237
00:10:12,410 --> 00:10:15,300
how the For is doing a
bunch of things for us.

238
00:10:15,300 --> 00:10:20,360
And it allows our code
to be more expressive.

239
00:10:20,360 --> 00:10:25,330
And so, a lot of this is
just got a bookkeeping crap,

240
00:10:25,330 --> 00:10:26,540
that we don't really need.

241
00:10:26,540 --> 00:10:28,450
And so the For loop
helps us by doing

242
00:10:28,450 --> 00:10:31,910
some of the bookkeeping for us.

243
00:10:31,910 --> 00:10:34,970
OK, so we can do all
those loop idioms.

244
00:10:34,970 --> 00:10:37,920
We can find the largest
letter, the smallest letter,

245
00:10:37,920 --> 00:10:44,194
how many times, how
many N's in this,

246
00:10:44,194 --> 00:10:45,360
or how many A's are in this.

247
00:10:45,360 --> 00:10:48,500
And so, this is a simple
counting pattern and a looking

248
00:10:48,500 --> 00:10:49,660
pattern.

249
00:10:49,660 --> 00:10:51,380
And so, our word is "banana."

250
00:10:51,380 --> 00:10:52,690
Our count is 0.

251
00:10:52,690 --> 00:10:55,695
For the letter in word, again--
boop-boop-boop-boop-boop--

252
00:10:55,695 --> 00:10:57,260
that comes out like that.

253
00:10:57,260 --> 00:10:59,030
So it's going to run
this little block.

254
00:10:59,030 --> 00:11:02,350
If the letter is A,
add 1 to the count.

255
00:11:02,350 --> 00:11:04,500
So this is going to
basically print out,

256
00:11:04,500 --> 00:11:07,615
at the end, the number
of A's in banana.

257
00:11:07,615 --> 00:11:10,000
It would probably be more
useful for me to print out

258
00:11:10,000 --> 00:11:11,480
the number of N's in banana.

259
00:11:11,480 --> 00:11:13,585
Because I never know how
many N's are in banana.

260
00:11:13,585 --> 00:11:15,460
But it looks like there's
supposed to be two.

261
00:11:15,460 --> 00:11:18,770
Or otherwise, I have
a typo on this slide.

262
00:11:18,770 --> 00:11:21,320
So that "In," again,
I love that In.

263
00:11:21,320 --> 00:11:23,020
I just absolutely love this In.

264
00:11:23,020 --> 00:11:28,280
I love this syntax, this For
each letter In the word banana.

265
00:11:28,280 --> 00:11:30,750
Just to me, it
reads very smoothly.

266
00:11:30,750 --> 00:11:33,440
Cognitively, it fits in
my mind what's going on.

267
00:11:33,440 --> 00:11:36,420
For each letter in banana,
run this little indented block

268
00:11:36,420 --> 00:11:37,080
of text.

269
00:11:37,080 --> 00:11:38,730
Again, very pretty.

270
00:11:38,730 --> 00:11:40,340
I love In.

271
00:11:40,340 --> 00:11:42,730
It's one of my favorite
little pieces of Python.

272
00:11:42,730 --> 00:11:46,480

273
00:11:46,480 --> 00:11:49,990
So again, with the For, it
takes care of all the iteration

274
00:11:49,990 --> 00:11:51,045
variables for us.

275
00:11:51,045 --> 00:11:52,420
And it goes through
the sequence.

276
00:11:52,420 --> 00:11:54,850
And so, here's an animation.

277
00:11:54,850 --> 00:11:57,900
Remember that the For is going
to do all this work for us.

278
00:11:57,900 --> 00:12:03,370
Letter is going to advance
through the successive letters

279
00:12:03,370 --> 00:12:04,750
in banana.

280
00:12:04,750 --> 00:12:08,170
So letter is being moved
for us by the For statement.

281
00:12:08,170 --> 00:12:10,980

282
00:12:10,980 --> 00:12:12,130
OK?

283
00:12:12,130 --> 00:12:14,310
So that's looping through.

284
00:12:14,310 --> 00:12:16,310
Now, it turns out there's
a lot of common things

285
00:12:16,310 --> 00:12:17,768
that we want to do
that are already

286
00:12:17,768 --> 00:12:19,776
built into Python for us.

287
00:12:19,776 --> 00:12:22,990
Clear the old screen there.

288
00:12:22,990 --> 00:12:24,480
We call these "slicing."

289
00:12:24,480 --> 00:12:28,690
So the index operator looks
up various things in a string.

290
00:12:28,690 --> 00:12:30,400
But we can also
pull substrings out,

291
00:12:30,400 --> 00:12:33,510
using the colon in addition
to the square brackets.

292
00:12:33,510 --> 00:12:36,300
Again, this is called "slicing."

293
00:12:36,300 --> 00:12:39,070
So the colon
operator, basically,

294
00:12:39,070 --> 00:12:43,490
takes a starting position
and, then, an ending position.

295
00:12:43,490 --> 00:12:47,020
But the ending position
is up-to but not including

296
00:12:47,020 --> 00:12:47,780
the second one.

297
00:12:47,780 --> 00:12:50,530
So it's up-to,
but not including.

298
00:12:50,530 --> 00:12:53,040
Up-to but not including,
just like the 0,

299
00:12:53,040 --> 00:12:54,430
you get used up pretty quick.

300
00:12:54,430 --> 00:12:59,240
But the first time you see
it, it's a little bit wonky.

301
00:12:59,240 --> 00:13:02,820
So if we're going 0 through 4,
that's how I read this print.

302
00:13:02,820 --> 00:13:07,540
S sub 0 through 4, or--
better said-- S, 0, up-to

303
00:13:07,540 --> 00:13:08,970
but not including 4.

304
00:13:08,970 --> 00:13:12,310
That is, print me out
the chunk that is up-to

305
00:13:12,310 --> 00:13:14,150
but not including 4.

306
00:13:14,150 --> 00:13:15,610
So it doesn't include 4.

307
00:13:15,610 --> 00:13:17,945
And so, out comes "mont."

308
00:13:17,945 --> 00:13:19,610
All right?

309
00:13:19,610 --> 00:13:22,690
So the next one is 6
up-to but not including 7.

310
00:13:22,690 --> 00:13:26,750
So it starts at 6, up-to
but not including 7.

311
00:13:26,750 --> 00:13:31,820
So out comes the P. And
even though you might expect

312
00:13:31,820 --> 00:13:36,160
that it would traceback
on this, here's

313
00:13:36,160 --> 00:13:38,360
a moment where Python
is a little forgiving,

314
00:13:38,360 --> 00:13:40,170
saying, I'll give
you a break here.

315
00:13:40,170 --> 00:13:43,000
If you go 6 up-to
but not including 20,

316
00:13:43,000 --> 00:13:45,470
I'll just stop at the
end of the string.

317
00:13:45,470 --> 00:13:47,000
So 6 to the end.

318
00:13:47,000 --> 00:13:49,990
So you can over-reference
here, and you

319
00:13:49,990 --> 00:13:51,500
won't get yourself in trouble.

320
00:13:51,500 --> 00:13:53,280
So that comes out "python."

321
00:13:53,280 --> 00:13:57,310
So again, the second character
is up-to but not including.

322
00:13:57,310 --> 00:13:59,310
And that's the kind
of weird thing there.

323
00:13:59,310 --> 00:14:02,330
Of course, once you remember
that the first character is 0,

324
00:14:02,330 --> 00:14:04,140
0 up-to but not including.

325
00:14:04,140 --> 00:14:04,640
Nice.

326
00:14:04,640 --> 00:14:08,560

327
00:14:08,560 --> 00:14:14,110
If we leave off the first or the
last number, and both of them,

328
00:14:14,110 --> 00:14:17,690
they mean the beginning and
end of the string respectively.

329
00:14:17,690 --> 00:14:21,570
And so, up-to but
not including 2,

330
00:14:21,570 --> 00:14:30,640
is M-O. 8 colon means starting
at 8 to the end of the string.

331
00:14:30,640 --> 00:14:32,420
So that's "thon."

332
00:14:32,420 --> 00:14:34,590
And then, that means the
beginning to the end.

333
00:14:34,590 --> 00:14:38,120
And so, it's just the whole
string, "monty python."

334
00:14:38,120 --> 00:14:40,860
Now, we've already played
with string concatenation.

335
00:14:40,860 --> 00:14:45,020
Just the thing to emphasize here
is the concatenation operator

336
00:14:45,020 --> 00:14:48,740
does not add a space.

337
00:14:48,740 --> 00:14:51,920
If you want a space,
you explicitly add it.

338
00:14:51,920 --> 00:14:55,156
So here, there's no space
in between the O and the T.

339
00:14:55,156 --> 00:14:57,280
But here, there is a space
between the O and the T,

340
00:14:57,280 --> 00:14:59,660
because we explicitly added it.

341
00:14:59,660 --> 00:15:02,270
So you can concatenate
more than one thing.

342
00:15:02,270 --> 00:15:04,590
And you add your
spaces as you want.

343
00:15:04,590 --> 00:15:07,789

344
00:15:07,789 --> 00:15:09,830
Another thing you can do
is you can ask questions

345
00:15:09,830 --> 00:15:10,470
about a string.

346
00:15:10,470 --> 00:15:14,610
It's sort of like doing a string
look up, using the In operator.

347
00:15:14,610 --> 00:15:17,820
This a little different than how
we use it inside of a For loop.

348
00:15:17,820 --> 00:15:20,200
This is a logical
operation asking

349
00:15:20,200 --> 00:15:23,190
a question like less-than
or greater-than or whatever.

350
00:15:23,190 --> 00:15:25,120
So here's an expression.

351
00:15:25,120 --> 00:15:26,950
So fruit is banana as always.

352
00:15:26,950 --> 00:15:30,250
Is N in fruit?

353
00:15:30,250 --> 00:15:31,720
And the answer is, yes, it is.

354
00:15:31,720 --> 00:15:32,584
True.

355
00:15:32,584 --> 00:15:33,875
So this is a logical operation.

356
00:15:33,875 --> 00:15:34,780
It's a question.

357
00:15:34,780 --> 00:15:36,620
It's like True or False.

358
00:15:36,620 --> 00:15:38,270
Is M in fruit?

359
00:15:38,270 --> 00:15:39,820
No, False.

360
00:15:39,820 --> 00:15:42,520
And this can be a string,
not just a single character.

361
00:15:42,520 --> 00:15:44,420
Is N-A-N in fruit?

362
00:15:44,420 --> 00:15:46,320
The answer is True.

363
00:15:46,320 --> 00:15:50,730
And you can put parts of
Ifs, et cetera, et cetera.

364
00:15:50,730 --> 00:15:53,860
So this is a logical expression
that can be on an If.

365
00:15:53,860 --> 00:15:57,090
You can have a While,
et cetera, et cetera.

366
00:15:57,090 --> 00:16:00,565
So it's a logical expression
and it returns True or False.

367
00:16:00,565 --> 00:16:03,550

368
00:16:03,550 --> 00:16:05,680
You can also do comparisons.

369
00:16:05,680 --> 00:16:10,940
Now, the comparison operations--
Equals makes a lot of sense.

370
00:16:10,940 --> 00:16:13,790
Less-than and Greater-than
depend on the language

371
00:16:13,790 --> 00:16:15,410
that you're using, Python.

372
00:16:15,410 --> 00:16:17,840
And so, if you're using a
Latin character set, then

373
00:16:17,840 --> 00:16:22,000
alphabetical matters, the
way the Latin character set

374
00:16:22,000 --> 00:16:22,500
would do.

375
00:16:22,500 --> 00:16:24,291
But if you're in a
different character set,

376
00:16:24,291 --> 00:16:26,510
Python is aware of
multiple character sets

377
00:16:26,510 --> 00:16:30,490
and will sort strings based
on the sorting algorithm

378
00:16:30,490 --> 00:16:33,130
of a particular character set.

379
00:16:33,130 --> 00:16:36,572
So you can do comparisons
like Equality, Less-than,

380
00:16:36,572 --> 00:16:37,280
and Greater-than.

381
00:16:37,280 --> 00:16:39,740
And we've seen some things in
previous lectures actually.

382
00:16:39,740 --> 00:16:42,040
We've had to use them.

383
00:16:42,040 --> 00:16:46,310
So in addition to these
fundamental operations that we

384
00:16:46,310 --> 00:16:52,920
can do on strings, there's
an extensive library

385
00:16:52,920 --> 00:16:55,420
of built-in
capabilities in Python.

386
00:16:55,420 --> 00:17:00,190
And so, the way we see these
built-in capabilities are

387
00:17:00,190 --> 00:17:03,410
they're actually
built into strings.

388
00:17:03,410 --> 00:17:05,429
So let's go real slow here.

389
00:17:05,429 --> 00:17:07,095
Here, we have a
variable called "greet,"

390
00:17:07,095 --> 00:17:10,060
and we're sticking the
string "Hello, Bob" into it.

391
00:17:10,060 --> 00:17:13,670
Now Greet is of type
string, as a result of this.

392
00:17:13,670 --> 00:17:16,579
And it contains Hello,
Bob as its value.

393
00:17:16,579 --> 00:17:19,819
But we can actually
access capabilities inside

394
00:17:19,819 --> 00:17:22,050
of this value.

395
00:17:22,050 --> 00:17:26,690
So we can say Greet
dot lower parentheses.

396
00:17:26,690 --> 00:17:29,546
This is calling something
that's part of Greet itself.

397
00:17:29,546 --> 00:17:30,670
It's a part of all strings.

398
00:17:30,670 --> 00:17:33,770
The fact that Greet
contains a string means

399
00:17:33,770 --> 00:17:35,350
that we can ask
for, hey, give me

400
00:17:35,350 --> 00:17:38,090
Greet, which just gives you
back what you're looking for.

401
00:17:38,090 --> 00:17:40,817
Like here, print
Greet as Hello, Bob.

402
00:17:40,817 --> 00:17:42,400
Or you could say,
give me Greet lower.

403
00:17:42,400 --> 00:17:47,460
So this doesn't convert
it to lowercase.

404
00:17:47,460 --> 00:17:51,050
It gives me a lowercase
copy of Hello, Bob.

405
00:17:51,050 --> 00:17:54,690
So Zap is hello,
bob, all lowercase.

406
00:17:54,690 --> 00:17:56,190
Now, it didn't change Greet.

407
00:17:56,190 --> 00:17:57,390
Right?

408
00:17:57,390 --> 00:18:01,157
And you could even put this Dot
Lower on the end of constants.

409
00:18:01,157 --> 00:18:02,490
Why you'd do this, I don't know.

410
00:18:02,490 --> 00:18:06,300
But Hi There, with H and
T capitalized, dot lower

411
00:18:06,300 --> 00:18:07,550
comes out as hi there.

412
00:18:07,550 --> 00:18:11,540
So this bit is part
of all strings.

413
00:18:11,540 --> 00:18:16,690
Both variables and constants
have these string functions

414
00:18:16,690 --> 00:18:17,870
built into them.

415
00:18:17,870 --> 00:18:21,160
And every instance of
a string-- whether it

416
00:18:21,160 --> 00:18:23,760
be a variable or a constant--
has these capabilities.

417
00:18:23,760 --> 00:18:25,400
They don't modify it.

418
00:18:25,400 --> 00:18:28,190
They just give you back a copy.

419
00:18:28,190 --> 00:18:33,220
Now, it turns out there is a
command inside Python called

420
00:18:33,220 --> 00:18:37,505
Dir to ask questions like, hey!

421
00:18:37,505 --> 00:18:38,937
Well, here's stuff.

422
00:18:38,937 --> 00:18:39,770
We got Hello, World.

423
00:18:39,770 --> 00:18:42,740
We can say-- oh, I
want to redo this,

424
00:18:42,740 --> 00:18:46,880
come here-- stuff as a string.

425
00:18:46,880 --> 00:18:48,240
We can ask, hey, what are you?

426
00:18:48,240 --> 00:18:49,660
I am a string.

427
00:18:49,660 --> 00:18:53,049
Dir is another built in Python
that asks the question, hey,

428
00:18:53,049 --> 00:18:55,340
what are all the things that
are built into this that I

429
00:18:55,340 --> 00:18:56,700
can make use of?

430
00:18:56,700 --> 00:18:57,760
And here they are.

431
00:18:57,760 --> 00:18:59,920
That's kind of a
raw dump of them.

432
00:18:59,920 --> 00:19:03,870
You can also go look at the
online documentation of Python.

433
00:19:03,870 --> 00:19:08,441
And at the Python
website, you can see

434
00:19:08,441 --> 00:19:09,690
a whole bunch of these things.

435
00:19:09,690 --> 00:19:11,740
And they have the
calling sequence, what

436
00:19:11,740 --> 00:19:13,770
the parameters are, et cetera.

437
00:19:13,770 --> 00:19:15,600
So when you're looking
these things up,

438
00:19:15,600 --> 00:19:17,900
you can go read about them.

439
00:19:17,900 --> 00:19:19,980
Here's just a few
that I pulled out,

440
00:19:19,980 --> 00:19:23,450
Capitalize-- which upper case
is the first characters--

441
00:19:23,450 --> 00:19:25,870
Center, Endswith, Find.

442
00:19:25,870 --> 00:19:26,655
There's Stripping.

443
00:19:26,655 --> 00:19:29,280
So I'll look through a couple of
these, just the kind of things

444
00:19:29,280 --> 00:19:30,530
to be looking for.

445
00:19:30,530 --> 00:19:32,300
It would be a good
idea to take a look

446
00:19:32,300 --> 00:19:33,800
and read through
some of the things.

447
00:19:33,800 --> 00:19:37,550
Here's a couple that we'll
probably be using early on.

448
00:19:37,550 --> 00:19:41,100
The Find function,
it's similar to In.

449
00:19:41,100 --> 00:19:44,750
But it tells you where it finds
the particular thing that's

450
00:19:44,750 --> 00:19:47,100
looking for.

451
00:19:47,100 --> 00:19:49,552
And so, we'll put
fruit is banana.

452
00:19:49,552 --> 00:19:51,010
And I'm going to
say, Pause-- which

453
00:19:51,010 --> 00:19:52,926
is going to be integer
variable-- equals fruit

454
00:19:52,926 --> 00:19:55,340
dot Find N-A. So
what it's saying is,

455
00:19:55,340 --> 00:19:58,140
go look inside this
variable fruit.

456
00:19:58,140 --> 00:20:01,160
Hunt until you find the first
occurrence of the string N-A.

457
00:20:01,160 --> 00:20:03,000
Hunt-hunt-hunt-hunt, whoop!

458
00:20:03,000 --> 00:20:04,300
Got it.

459
00:20:04,300 --> 00:20:05,680
--and then, return it to me.

460
00:20:05,680 --> 00:20:07,990
So that's going
to give me back 2.

461
00:20:07,990 --> 00:20:10,540
2 is where it found it, right?

462
00:20:10,540 --> 00:20:12,440
So where is it in the string?

463
00:20:12,440 --> 00:20:13,820
That's what Find does.

464
00:20:13,820 --> 00:20:16,930
And if you don't find anything--
like, you're looking for Z.

465
00:20:16,930 --> 00:20:19,530
Nn-nn-nn-nn-na, I
didn't find a Z. Then,

466
00:20:19,530 --> 00:20:21,602
it gives me back negative 1.

467
00:20:21,602 --> 00:20:26,090
So again, this is just one
of many built-in functions

468
00:20:26,090 --> 00:20:30,130
in string, the ability
to find a substring

469
00:20:30,130 --> 00:20:35,440
or find a character or
string within another string.

470
00:20:35,440 --> 00:20:36,560
There's a lowercase.

471
00:20:36,560 --> 00:20:38,030
There's also an uppercase.

472
00:20:38,030 --> 00:20:40,740
This might be better
named "Shouting."

473
00:20:40,740 --> 00:20:43,200
Upper means, give
me an uppercase copy

474
00:20:43,200 --> 00:20:44,020
of this variable.

475
00:20:44,020 --> 00:20:46,830
So Hello Bob, becomes HELLO BOB!

476
00:20:46,830 --> 00:20:49,311
And then lower is hello, bob.

477
00:20:49,311 --> 00:20:49,810
Right?

478
00:20:49,810 --> 00:20:52,970
So these are both
ways to get copies

479
00:20:52,970 --> 00:20:55,644
of uppercase and
lowercase versions.

480
00:20:55,644 --> 00:20:57,310
You might think these
are kind of silly.

481
00:20:57,310 --> 00:20:59,660
But one of the things
we tend to use lower for

482
00:20:59,660 --> 00:21:02,830
is if you're doing searching
and you want to ignore case,

483
00:21:02,830 --> 00:21:04,710
you convert the whole
thing to lowercase.

484
00:21:04,710 --> 00:21:06,543
And then, you switch
for a lowercase string.

485
00:21:06,543 --> 00:21:08,810
So it depends if you want
to ignore case or not.

486
00:21:08,810 --> 00:21:14,270
So that's one of the reasons
that you have things like this.

487
00:21:14,270 --> 00:21:16,280
There is a Replace function.

488
00:21:16,280 --> 00:21:19,370
Again, it doesn't
change the value.

489
00:21:19,370 --> 00:21:21,610
Greet is going to
have Hello, Bob.

490
00:21:21,610 --> 00:21:27,040
And I'm going to say, Greet dot
Replace all occurrences of Bob

491
00:21:27,040 --> 00:21:28,360
with Jane.

492
00:21:28,360 --> 00:21:33,550
That gives me back a copy and
End STIR says, Hello, Jane.

493
00:21:33,550 --> 00:21:35,800
So Greet is unchanged.

494
00:21:35,800 --> 00:21:38,280
This Replace says, make a copy.

495
00:21:38,280 --> 00:21:43,800
And then, make that following
edit that we requested.

496
00:21:43,800 --> 00:21:48,200
Now, the replace is going
to do all occurrences.

497
00:21:48,200 --> 00:21:50,399
So Greet is still Hello, Bob.

498
00:21:50,399 --> 00:21:51,690
This is kind of redundant here.

499
00:21:51,690 --> 00:21:53,990
I'm just doing it so
you remember what it is.

500
00:21:53,990 --> 00:21:55,300
Greet is still Hello, Bob.

501
00:21:55,300 --> 00:21:57,240
I put Hello, Bob back in it.

502
00:21:57,240 --> 00:21:59,380
And Replace all the
occurrences of lowercase

503
00:21:59,380 --> 00:22:03,780
O with uppercase X.
And then, that happens.

504
00:22:03,780 --> 00:22:06,120
So this says, go through
the whole string--

505
00:22:06,120 --> 00:22:09,800
tch-tch-tch-tch-tch--
doing all those Replace.

506
00:22:09,800 --> 00:22:11,717
OK?

507
00:22:11,717 --> 00:22:14,050
Now, another common thing
that we're going to have to do

508
00:22:14,050 --> 00:22:16,990
is we're going to have to
throw away white space.

509
00:22:16,990 --> 00:22:18,970
Sometimes, you
have a string that

510
00:22:18,970 --> 00:22:22,920
has blank characters or other
characters at the beginning

511
00:22:22,920 --> 00:22:25,250
and the end,
non-printable characters.

512
00:22:25,250 --> 00:22:26,390
And we can strip them.

513
00:22:26,390 --> 00:22:28,730
And there's three
functions that are

514
00:22:28,730 --> 00:22:33,940
built into Python strings
that do this for us.

515
00:22:33,940 --> 00:22:38,330
There is Lstrip, which
strips from the left.

516
00:22:38,330 --> 00:22:43,770
There is Rstrip, which
strips from the right--

517
00:22:43,770 --> 00:22:45,580
so throws away
these white spaces.

518
00:22:45,580 --> 00:22:49,150
So Hello, Bob is gone.

519
00:22:49,150 --> 00:22:50,940
So it gets rid of
these characters.

520
00:22:50,940 --> 00:22:51,080
Oops.

521
00:22:51,080 --> 00:22:53,080
These are the ones that
are gotten rid of there.

522
00:22:53,080 --> 00:22:56,060
I need an eraser.

523
00:22:56,060 --> 00:22:57,260
Oh, let's use white.

524
00:22:57,260 --> 00:23:00,760
And then, Strip basically gets
rid of all the white space,

525
00:23:00,760 --> 00:23:04,150
both on the left and the right
side and gets rid of that.

526
00:23:04,150 --> 00:23:07,300
So we're going to be
using these a lot.

527
00:23:07,300 --> 00:23:09,960
One of the things you tend to do
in Python is cleaning up data.

528
00:23:09,960 --> 00:23:12,376
Sometimes, if you have spaces
at the beginning or the end,

529
00:23:12,376 --> 00:23:13,950
you just want to ignore them.

530
00:23:13,950 --> 00:23:15,050
So you strip them off.

531
00:23:15,050 --> 00:23:18,020
You throw them away.

532
00:23:18,020 --> 00:23:20,030
When we're looking
for data, we sometimes

533
00:23:20,030 --> 00:23:21,990
are looking for a prefix.

534
00:23:21,990 --> 00:23:25,380
And there is a
Startswith function that

535
00:23:25,380 --> 00:23:27,400
gives you a True or a False.

536
00:23:27,400 --> 00:23:29,780
We're asking here,
does this variable line

537
00:23:29,780 --> 00:23:31,380
start with the string "please?"

538
00:23:31,380 --> 00:23:32,450
And the answer is True.

539
00:23:32,450 --> 00:23:34,886
Yes, it does start
with the string please.

540
00:23:34,886 --> 00:23:38,340
Or in the next, we ask, does
this start with the letter P?

541
00:23:38,340 --> 00:23:39,630
And the answer is False.

542
00:23:39,630 --> 00:23:42,660
It does not start
with the letter P. OK?

543
00:23:42,660 --> 00:23:44,980
So there's lots more
of these things.

544
00:23:44,980 --> 00:23:48,570

545
00:23:48,570 --> 00:23:52,090
And reading data and tearing
it apart is one of the things

546
00:23:52,090 --> 00:23:54,400
that we're going
to really focus on

547
00:23:54,400 --> 00:23:57,120
for the rest of these first
few chapters of the book.

548
00:23:57,120 --> 00:23:59,700
Because that's one thing
that Python's really good at

549
00:23:59,700 --> 00:24:02,810
is tearing data into pieces
and pulling the pieces

550
00:24:02,810 --> 00:24:04,500
that you want.

551
00:24:04,500 --> 00:24:06,910
So let's take a
look at this line.

552
00:24:06,910 --> 00:24:11,120
So this line that we've got here
is a line from an actual email

553
00:24:11,120 --> 00:24:13,310
box.

554
00:24:13,310 --> 00:24:16,210
If you looked at your
email on your hard drive,

555
00:24:16,210 --> 00:24:18,690
email boxes would have
this kind of a format.

556
00:24:18,690 --> 00:24:20,470
And there's actually many lines.

557
00:24:20,470 --> 00:24:23,596
And soon, we'll be reading
whole files full of email.

558
00:24:23,596 --> 00:24:24,970
But for now, let's
just say we've

559
00:24:24,970 --> 00:24:26,900
got this one line somehow.

560
00:24:26,900 --> 00:24:31,870
And we don't know how long
these things are going to be.

561
00:24:31,870 --> 00:24:34,610
The first thing is From, then
there's an email address.

562
00:24:34,610 --> 00:24:38,010
Then, there's some detail
about when the mail was sent.

563
00:24:38,010 --> 00:24:42,430
But what we actually want
is this part right here.

564
00:24:42,430 --> 00:24:45,450
And that's the domain
name of the mail address.

565
00:24:45,450 --> 00:24:45,950
Right?

566
00:24:45,950 --> 00:24:48,110
We want to extract this out.

567
00:24:48,110 --> 00:24:51,080
We're faced with this
line in a variable.

568
00:24:51,080 --> 00:24:52,860
And we want to extract that out.

569
00:24:52,860 --> 00:24:56,310
So this is kind of putting
all these things together.

570
00:24:56,310 --> 00:24:59,370
So let's walk through
how we do this.

571
00:24:59,370 --> 00:25:00,950
So here's this line.

572
00:25:00,950 --> 00:25:02,080
And it's a big long string.

573
00:25:02,080 --> 00:25:03,980
Mostly, we would have
read this from a file

574
00:25:03,980 --> 00:25:05,380
rather than just put
it in a constant.

575
00:25:05,380 --> 00:25:06,921
But for now, we put
it in a constant,

576
00:25:06,921 --> 00:25:09,940
because Files is
the next chapter.

577
00:25:09,940 --> 00:25:12,460
And so, what we're going to
do is we're going to say,

578
00:25:12,460 --> 00:25:13,529
you know what?

579
00:25:13,529 --> 00:25:14,820
I'm going to look at this line.

580
00:25:14,820 --> 00:25:16,611
And then, I'm going to
go find the At sign.

581
00:25:16,611 --> 00:25:18,480
And I want to know
where the At sign is.

582
00:25:18,480 --> 00:25:21,840
So I called Data
dot Find At sign,

583
00:25:21,840 --> 00:25:24,330
and put the
resultant in At Pose.

584
00:25:24,330 --> 00:25:26,236
And that gives me 21.

585
00:25:26,236 --> 00:25:29,330
It hunts until it
finds the At sign,

586
00:25:29,330 --> 00:25:31,680
and then tells me
where it found it.

587
00:25:31,680 --> 00:25:35,300
Then, what I want to
look at is, starting here

588
00:25:35,300 --> 00:25:38,640
for the rest of the string, I
want to find the first place

589
00:25:38,640 --> 00:25:40,180
afterwards.

590
00:25:40,180 --> 00:25:43,800
So what I say is this
SP pose is my variable

591
00:25:43,800 --> 00:25:45,890
for the position of the space.

592
00:25:45,890 --> 00:25:51,310
Data dot Find a blank
starting at the At.

593
00:25:51,310 --> 00:25:53,330
So this is starting at 21.

594
00:25:53,330 --> 00:25:55,170
So it says, I'll
start at 21, and I'll

595
00:25:55,170 --> 00:25:56,710
look for the next blank.

596
00:25:56,710 --> 00:25:59,770
And I find that at 31.

597
00:25:59,770 --> 00:26:03,250
So now, I know where
the At sign is.

598
00:26:03,250 --> 00:26:05,095
And I know where the space is.

599
00:26:05,095 --> 00:26:07,660
And so, what I'm
looking at is I want

600
00:26:07,660 --> 00:26:11,960
the stuff one beyond the At
sign, up-to but not including

601
00:26:11,960 --> 00:26:14,220
the space.

602
00:26:14,220 --> 00:26:18,180
So then, I can use
a slicing operation.

603
00:26:18,180 --> 00:26:23,230
I can start at the At
position, add 1 to it.

604
00:26:23,230 --> 00:26:24,490
So it advanced one.

605
00:26:24,490 --> 00:26:28,260
That's going to be the letter U.
And then, a slicing operation--

606
00:26:28,260 --> 00:26:30,850
up-to but not including space.

607
00:26:30,850 --> 00:26:34,500
Up to-- this is going to work
out nicely all of a sudden--

608
00:26:34,500 --> 00:26:37,140
but not including.

609
00:26:37,140 --> 00:26:41,310

610
00:26:41,310 --> 00:26:43,840
And then, I'm going to take
that slice-- which is really

611
00:26:43,840 --> 00:26:47,730
this little bit of data
right here-- take that slice

612
00:26:47,730 --> 00:26:49,480
and put it in the variable host.

613
00:26:49,480 --> 00:26:52,300
Then, we print that out,
and we get the piece.

614
00:26:52,300 --> 00:26:53,990
OK?

615
00:26:53,990 --> 00:26:57,000
And so, here we have some
data we want to tear apart.

616
00:26:57,000 --> 00:26:58,250
We hunt for the At.

617
00:26:58,250 --> 00:27:00,390
We find it at position 21.

618
00:27:00,390 --> 00:27:02,220
We start at 21.

619
00:27:02,220 --> 00:27:05,690
And we look for the
space after that, 31.

620
00:27:05,690 --> 00:27:10,750
And then, we pull from 22,
up-to but not including 31.

621
00:27:10,750 --> 00:27:12,584
And it wouldn't matter
where this thing was.

622
00:27:12,584 --> 00:27:14,249
Because these aren't
all the same length

623
00:27:14,249 --> 00:27:16,080
when we start looking
at them in files.

624
00:27:16,080 --> 00:27:19,000
But it would have found the At
sign and the space after the

625
00:27:19,000 --> 00:27:20,020
At sign.

626
00:27:20,020 --> 00:27:23,630
And it would have reliably
pulled out the host.

627
00:27:23,630 --> 00:27:24,360
OK?

628
00:27:24,360 --> 00:27:31,716
So this is a basic pattern
we call parsing text.

629
00:27:31,716 --> 00:27:34,120
Like, find this, find
that other thing.

630
00:27:34,120 --> 00:27:35,150
Grab this thing out.

631
00:27:35,150 --> 00:27:38,200
Then, look inside that thing
and-- phl-sl-sl-fl-fl--

632
00:27:38,200 --> 00:27:41,610
it does all these things.

633
00:27:41,610 --> 00:27:43,830
So that's strings.

634
00:27:43,830 --> 00:27:45,177
Up next, we have files.

635
00:27:45,177 --> 00:27:46,760
Files are going to
be lots of strings.

636
00:27:46,760 --> 00:27:49,280
So we're going to start putting
all these things together.

637
00:27:49,280 --> 00:27:52,900
And so, the next chapter is
a really, really important

638
00:27:52,900 --> 00:27:55,660
chapter where it starts to
really start coming together.

639
00:27:55,660 --> 00:27:58,410
So see you soon.
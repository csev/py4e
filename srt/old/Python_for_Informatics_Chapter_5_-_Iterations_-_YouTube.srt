1
00:00:00,000 --> 00:00:00,500

2
00:00:00,500 --> 00:00:03,680
Hello, and welcome to chapter
five, loops and iteration.

3
00:00:03,680 --> 00:00:06,830
As always, this lecture is
copyright Creative Commons

4
00:00:06,830 --> 00:00:09,460
attribution, including
the audio, and the video,

5
00:00:09,460 --> 00:00:12,620
and the slides,
and the book, even.

6
00:00:12,620 --> 00:00:18,770
So now we're getting to
our fourth basic pattern.

7
00:00:18,770 --> 00:00:20,710
We've talked about
sequential, where

8
00:00:20,710 --> 00:00:22,180
steps happen one after another.

9
00:00:22,180 --> 00:00:24,596
We've talked about conditional,
where steps may or may not

10
00:00:24,596 --> 00:00:25,096
happen.

11
00:00:25,096 --> 00:00:27,762
In chapter four, we talked about
the store and retrieve pattern,

12
00:00:27,762 --> 00:00:30,150
and now we're going to talk
about the looping pattern.

13
00:00:30,150 --> 00:00:33,220
And the looping pattern is the
last of our really foundational

14
00:00:33,220 --> 00:00:33,720
ones.

15
00:00:33,720 --> 00:00:35,960
And it potentially is
the most important one,

16
00:00:35,960 --> 00:00:39,920
because it's the thing that
allows us to get computers

17
00:00:39,920 --> 00:00:43,560
to do lots of things that,
say, humans might get tired of,

18
00:00:43,560 --> 00:00:45,750
but computers don't tire of.

19
00:00:45,750 --> 00:00:49,970
And so after this,
we'll start becoming

20
00:00:49,970 --> 00:00:52,710
a little more skilled in the
basic language capabilities.

21
00:00:52,710 --> 00:00:56,120
We'll talk about strings, and
then start talking about files,

22
00:00:56,120 --> 00:00:58,890
and start doing some real work
after we get done with this.

23
00:00:58,890 --> 00:01:01,700
So bear with us, it's
going to be a while,

24
00:01:01,700 --> 00:01:04,319
but we'll get there.

25
00:01:04,319 --> 00:01:07,070
So welcome to repeated steps.

26
00:01:07,070 --> 00:01:12,130
This is the example that I had
in the first lecture, chapter

27
00:01:12,130 --> 00:01:13,180
one.

28
00:01:13,180 --> 00:01:15,360
And the basic idea,
just to review,

29
00:01:15,360 --> 00:01:18,270
is that you have
this while keyword.

30
00:01:18,270 --> 00:01:21,370
The while keyword functions
like an if in that it implicitly

31
00:01:21,370 --> 00:01:23,860
has a decision
that's going to make.

32
00:01:23,860 --> 00:01:27,630
And it's either going to do
the code in the indented block

33
00:01:27,630 --> 00:01:30,060
or or skip it, basically.

34
00:01:30,060 --> 00:01:33,030
So you either do
it, or you skip it.

35
00:01:33,030 --> 00:01:34,920
The difference between
the while and the if

36
00:01:34,920 --> 00:01:38,920
is that it's going to do it many
times as long as this question

37
00:01:38,920 --> 00:01:42,500
that we have remains true.

38
00:01:42,500 --> 00:01:46,060
And so in this case, n is 5.

39
00:01:46,060 --> 00:01:48,160
While n greater than zero,
functions like an if.

40
00:01:48,160 --> 00:01:49,670
So yes, it's going to run it.

41
00:01:49,670 --> 00:01:53,000
Prints out 5, subtracts
one, so it's four.

42
00:01:53,000 --> 00:01:56,822
Goes back up and asks
the question again.

43
00:01:56,822 --> 00:01:58,030
Is n still greater than zero?

44
00:01:58,030 --> 00:02:00,880
Well, since it's four,
yes, we'll continue on.

45
00:02:00,880 --> 00:02:03,400
Out comes four, then
n gets subtracted.

46
00:02:03,400 --> 00:02:06,650
Three, two.

47
00:02:06,650 --> 00:02:09,680
And then we come
through, we print one.

48
00:02:09,680 --> 00:02:10,979
We subtract n to zero.

49
00:02:10,979 --> 00:02:13,200
We go back up.

50
00:02:13,200 --> 00:02:17,230
n is now not greater
than zero, so we come up

51
00:02:17,230 --> 00:02:19,500
and we execute outside the loop.

52
00:02:19,500 --> 00:02:20,690
We leave the loop.

53
00:02:20,690 --> 00:02:22,510
And that really means
in the Python code,

54
00:02:22,510 --> 00:02:26,020
we skip to whatever's lined
up with the while statement.

55
00:02:26,020 --> 00:02:29,240
The in same indent level
as the while statement.

56
00:02:29,240 --> 00:02:30,550
And so that's how it works.

57
00:02:30,550 --> 00:02:33,445
And I just print n at the
end here to remind ourselves

58
00:02:33,445 --> 00:02:34,980
that n ended up at zero.

59
00:02:34,980 --> 00:02:35,715
Not at one.

60
00:02:35,715 --> 00:02:40,790
The last thing we printed
out in the loop was the one,

61
00:02:40,790 --> 00:02:41,980
but n ended up at 0.

62
00:02:41,980 --> 00:02:44,830
Because this loop was
going to run as long as n

63
00:02:44,830 --> 00:02:48,450
was greater than zero, so it
had to be not greater than zero

64
00:02:48,450 --> 00:02:50,410
to get out the loop.

65
00:02:50,410 --> 00:02:54,020
So that's basically a
review of what we've done.

66
00:02:54,020 --> 00:02:58,600
Now-- oh, wait, something else.

67
00:02:58,600 --> 00:03:00,960
Iteration variables.

68
00:03:00,960 --> 00:03:04,440
So the key to this is these
loops can't run forever.

69
00:03:04,440 --> 00:03:06,000
We don't want them
to run forever.

70
00:03:06,000 --> 00:03:08,420
We want them to run as long
as we want them to run,

71
00:03:08,420 --> 00:03:11,089
they may run a very long
time, but not forever.

72
00:03:11,089 --> 00:03:12,880
There's got to be a
way to get out of them,

73
00:03:12,880 --> 00:03:14,963
otherwise we call them
infinite loops, which we'll

74
00:03:14,963 --> 00:03:16,730
talk about in the next slide.

75
00:03:16,730 --> 00:03:18,440
So the iteration
variable is generally

76
00:03:18,440 --> 00:03:22,030
some variable that is changing
each time through the loop,

77
00:03:22,030 --> 00:03:25,859
and we are changing it by
subtracting one from it.

78
00:03:25,859 --> 00:03:27,650
And so this thing is
going to keep running,

79
00:03:27,650 --> 00:03:29,300
and we can pretty
much see that, oh,

80
00:03:29,300 --> 00:03:31,070
this is going to exit, right?

81
00:03:31,070 --> 00:03:31,742
Whatever n is.

82
00:03:31,742 --> 00:03:33,700
It could be a large
number, but eventually it's

83
00:03:33,700 --> 00:03:35,510
going to get to zero.

84
00:03:35,510 --> 00:03:39,550
So the iteration variable
controls how many times

85
00:03:39,550 --> 00:03:41,690
the loop runs,
and it also allows

86
00:03:41,690 --> 00:03:43,600
us to do something
different inside the loop.

87
00:03:43,600 --> 00:03:45,349
And of course, this
is like a trivia loop,

88
00:03:45,349 --> 00:03:47,430
where we're just printing
the iteration variable.

89
00:03:47,430 --> 00:03:50,454
But it just means that this
loop is going to run five times,

90
00:03:50,454 --> 00:03:52,620
and it's going to do something
potentially different

91
00:03:52,620 --> 00:03:53,491
each time.

92
00:03:53,491 --> 00:03:55,740
If you just ran the loop
that did the same thing over,

93
00:03:55,740 --> 00:03:57,698
and over, and over again
with no data changing,

94
00:03:57,698 --> 00:04:00,120
that's dull and pointless.

95
00:04:00,120 --> 00:04:02,610
So just because you have
an iteration variable

96
00:04:02,610 --> 00:04:05,490
doesn't mean that you've
properly constructed your loop.

97
00:04:05,490 --> 00:04:09,260
It's a common problem, or
something we want to avoid,

98
00:04:09,260 --> 00:04:10,590
is an infinite loop.

99
00:04:10,590 --> 00:04:13,040
And here is a carefully
constructed loop.

100
00:04:13,040 --> 00:04:15,520
We start n at five
at the beginning.

101
00:04:15,520 --> 00:04:18,700
We have a good question at the
end, while n greater than zero,

102
00:04:18,700 --> 00:04:23,090
it's going to run this as long
as n is greater than zero.

103
00:04:23,090 --> 00:04:25,780
But the problem is, we don't
change in the little block,

104
00:04:25,780 --> 00:04:27,190
we don't change the n.

105
00:04:27,190 --> 00:04:28,690
Which means it's
going to come back,

106
00:04:28,690 --> 00:04:29,860
and n is going to be five.

107
00:04:29,860 --> 00:04:31,760
And that's going to run this,
and n's going to be five.

108
00:04:31,760 --> 00:04:34,100
And it's going to run this,
and it's going to be five.

109
00:04:34,100 --> 00:04:36,224
And so this an infinite
loop, which means this loop

110
00:04:36,224 --> 00:04:37,080
will never exit.

111
00:04:37,080 --> 00:04:39,580
It will never get out.

112
00:04:39,580 --> 00:04:41,580
It's just going to
run forever in here,

113
00:04:41,580 --> 00:04:43,350
because n's not changing.

114
00:04:43,350 --> 00:04:45,230
Neither of these
statements change n.

115
00:04:45,230 --> 00:04:46,670
So part of the
iteration variable

116
00:04:46,670 --> 00:04:48,560
is there needs to
be something that

117
00:04:48,560 --> 00:04:51,810
changes so that the loop
will ultimately make progress

118
00:04:51,810 --> 00:04:54,340
to accomplish what it is
and know when to stop.

119
00:04:54,340 --> 00:04:55,700
So this is an infinite loop.

120
00:04:55,700 --> 00:04:58,650
And, of course, lather,
rinse, repeat is commonly

121
00:04:58,650 --> 00:05:01,450
put on shampoo and conditioner.

122
00:05:01,450 --> 00:05:03,839
And so you can next time
you're in the shower

123
00:05:03,839 --> 00:05:05,630
take a look at your
shampoo and conditioner

124
00:05:05,630 --> 00:05:08,380
and find the
infinite loop that's

125
00:05:08,380 --> 00:05:14,370
on most bottles of
shampoo and conditioner.

126
00:05:14,370 --> 00:05:18,940
Now here's another
loop just to emphasize

127
00:05:18,940 --> 00:05:21,120
that it's possible to
structure these loops in a way

128
00:05:21,120 --> 00:05:22,810
that they never run.

129
00:05:22,810 --> 00:05:25,010
So this function is an if.

130
00:05:25,010 --> 00:05:27,480
The while functions as an if.

131
00:05:27,480 --> 00:05:31,720
And so when n is set to zero
and we ask the question,

132
00:05:31,720 --> 00:05:33,530
it is literally going
to make the decision

133
00:05:33,530 --> 00:05:34,738
based on n greater than zero.

134
00:05:34,738 --> 00:05:36,810
Well, it is not
greater than zero,

135
00:05:36,810 --> 00:05:39,030
so it's going to go
right by it over here.

136
00:05:39,030 --> 00:05:41,520
It's going to come here
and go right to there,

137
00:05:41,520 --> 00:05:44,710
and never run these
lines of code.

138
00:05:44,710 --> 00:05:49,690
And we call this a zero
trip loop, and that's OK.

139
00:05:49,690 --> 00:05:53,590
I mean, this is a
silly one, of course.

140
00:05:53,590 --> 00:05:57,270
It just shows that the test,
the question that's being asked

141
00:05:57,270 --> 00:06:00,760
is above the lines that make
up the body of the loop.

142
00:06:00,760 --> 00:06:03,290
And if it's false,
the loop never runs.

143
00:06:03,290 --> 00:06:07,780
So it's possible that these
loops have zero trips.

144
00:06:07,780 --> 00:06:09,110
So that's a loop.

145
00:06:09,110 --> 00:06:15,545
Now there are more than one way
to control the flow of a loop.

146
00:06:15,545 --> 00:06:17,920
The basic flow of the loop is
when it gets to the bottom,

147
00:06:17,920 --> 00:06:20,445
it goes back up to the
while and does the check.

148
00:06:20,445 --> 00:06:22,600
This is a different way of
getting out of the loop,

149
00:06:22,600 --> 00:06:24,720
or controlling the
execution of a loop.

150
00:06:24,720 --> 00:06:27,690
There is a key word, or a
part of the Python language,

151
00:06:27,690 --> 00:06:30,924
called-- what color do I got?

152
00:06:30,924 --> 00:06:33,980
Nope, Green's over here.

153
00:06:33,980 --> 00:06:35,249
Called break.

154
00:06:35,249 --> 00:06:36,790
If you looked back
at reserved words,

155
00:06:36,790 --> 00:06:38,540
break is one of
the reserved words.

156
00:06:38,540 --> 00:06:42,940
Break says, hey, if I'm
in a loop, stop the loop.

157
00:06:42,940 --> 00:06:45,410
Get out of this loop,
I'm done with this loop.

158
00:06:45,410 --> 00:06:47,570
And so here's this loop.

159
00:06:47,570 --> 00:06:49,270
Now the interesting
thing we've done

160
00:06:49,270 --> 00:06:51,561
is I just got done talking
to you about infinite loops.

161
00:06:51,561 --> 00:06:54,030
We have just constructed
an infinite loop.

162
00:06:54,030 --> 00:06:58,820
Because the question is right
there, and the answer is yes,

163
00:06:58,820 --> 00:06:59,320
true.

164
00:06:59,320 --> 00:07:01,327
And that's a way to
construct an infinite loop.

165
00:07:01,327 --> 00:07:03,910
We've done this because we have
a different way of getting out

166
00:07:03,910 --> 00:07:04,410
of the loop.

167
00:07:04,410 --> 00:07:07,080
So we've constructed loop
just on the face of it,

168
00:07:07,080 --> 00:07:10,170
just looking at that line,
looks like an infinite loop.

169
00:07:10,170 --> 00:07:13,360
So what this loop does is
it reads a line of input,

170
00:07:13,360 --> 00:07:17,260
checks to see if it's the string
that we've entered as done.

171
00:07:17,260 --> 00:07:20,661
And if it is, we're going
to skip out with this break

172
00:07:20,661 --> 00:07:21,660
and get out of the loop.

173
00:07:21,660 --> 00:07:23,250
Otherwise, we're
going to print it.

174
00:07:23,250 --> 00:07:25,370
So at a high level, what
this loop is going to do

175
00:07:25,370 --> 00:07:29,917
is prompt for strings of
characters until we enter done.

176
00:07:29,917 --> 00:07:31,250
And that's exactly what it does.

177
00:07:31,250 --> 00:07:33,375
It prompts, we say hello
there, it prints that out.

178
00:07:33,375 --> 00:07:35,320
So we say finished,
it prints that out.

179
00:07:35,320 --> 00:07:37,150
We say done, and it's done.

180
00:07:37,150 --> 00:07:40,920
So when we say done, it comes
out and finishes the loop,

181
00:07:40,920 --> 00:07:43,540
and that's the end
of the program.

182
00:07:43,540 --> 00:07:48,190
So to look at this
in some more detail,

183
00:07:48,190 --> 00:07:51,760
the first time it comes
in, does the raw input.

184
00:07:51,760 --> 00:07:53,980
Because true is true,
so it's going to run it.

185
00:07:53,980 --> 00:07:57,409
And then we entered hello there.

186
00:07:57,409 --> 00:07:59,950
It checks to see what we entered
is equal to the string done.

187
00:07:59,950 --> 00:08:03,680
It is not, so it skips
and it does the print.

188
00:08:03,680 --> 00:08:06,560
We do this one more
time, we type finished.

189
00:08:06,560 --> 00:08:09,579
And then the line is not done.

190
00:08:09,579 --> 00:08:11,620
Variable line does not
have the value done in it.

191
00:08:11,620 --> 00:08:12,740
So we print that.

192
00:08:12,740 --> 00:08:14,390
We come in one more time.

193
00:08:14,390 --> 00:08:16,460
But this time this is true.

194
00:08:16,460 --> 00:08:18,850
So it goes and
executes the break,

195
00:08:18,850 --> 00:08:21,190
and then it escapes the loop.

196
00:08:21,190 --> 00:08:26,310
And so you can think of, here
is the body of this loop,

197
00:08:26,310 --> 00:08:29,680
because that's where the
indentation starts and ends.

198
00:08:29,680 --> 00:08:34,499
The break says break me out of
the current loop that I'm in

199
00:08:34,499 --> 00:08:37,039
and get to that
next line that has

200
00:08:37,039 --> 00:08:38,250
the same indent as the while.

201
00:08:38,250 --> 00:08:42,010
So whatever it is, break says
we are done with this loop.

202
00:08:42,010 --> 00:08:45,340
When that statement executes,
we are done with the loop.

203
00:08:45,340 --> 00:08:46,720
We're finished with the loop.

204
00:08:46,720 --> 00:08:48,870
It'll run until that
executes, because we've

205
00:08:48,870 --> 00:08:53,200
got this set to be while true.

206
00:08:53,200 --> 00:08:57,120
OK, so this is a simple
way to draw this.

207
00:08:57,120 --> 00:09:02,560
Break is a jump to the statement
immediately following the loop.

208
00:09:02,560 --> 00:09:04,090
If you really want
to picture this,

209
00:09:04,090 --> 00:09:06,830
I think of this as like
a Star Trek transporter.

210
00:09:06,830 --> 00:09:11,220
Where you come in to break,
and then your molecules

211
00:09:11,220 --> 00:09:13,130
are sent to the four
corners of the universe,

212
00:09:13,130 --> 00:09:16,040
and you reassemble
outside of the loop.

213
00:09:16,040 --> 00:09:18,970
And so if we look at this
outside of my little roadmap

214
00:09:18,970 --> 00:09:22,150
version of these
things, our while loop

215
00:09:22,150 --> 00:09:24,060
is going to run for
awhile, yadda yadda.

216
00:09:24,060 --> 00:09:25,840
There can actually be
more than one break,

217
00:09:25,840 --> 00:09:27,090
as long as they only get this.

218
00:09:27,090 --> 00:09:30,730
But the moment that somehow,
some if for whatever

219
00:09:30,730 --> 00:09:34,010
hits the break, then
it gets out completely.

220
00:09:34,010 --> 00:09:36,090
And so it escapes the loop.

221
00:09:36,090 --> 00:09:41,500
And so it's like you
zoom, zoom, zoom.

222
00:09:41,500 --> 00:09:43,830
You come in here,
and then you're

223
00:09:43,830 --> 00:09:46,260
rematerialized outside the loop.

224
00:09:46,260 --> 00:09:48,410
That's what the break does.

225
00:09:48,410 --> 00:09:54,640
So break is one way to control
the execution of loops.

226
00:09:54,640 --> 00:09:56,990
Now another way to
control the execution

227
00:09:56,990 --> 00:09:58,830
of loops that doesn't
actually exit the loop

228
00:09:58,830 --> 00:10:01,010
is called continue.

229
00:10:01,010 --> 00:10:04,630
Continue basically
says, hey, I'm

230
00:10:04,630 --> 00:10:06,640
done with this
iteration of the loop.

231
00:10:06,640 --> 00:10:09,640
Now, each time through the
loop, we call that an iteration.

232
00:10:09,640 --> 00:10:13,160
Continue says I don't
want to stop the loop,

233
00:10:13,160 --> 00:10:15,790
but I want to stop the
iteration and advance

234
00:10:15,790 --> 00:10:17,442
to the next iteration.

235
00:10:17,442 --> 00:10:18,900
And so what we have
here is we have

236
00:10:18,900 --> 00:10:21,730
the same basic loop,
a while true, which

237
00:10:21,730 --> 00:10:24,590
makes this an infinite loop.

238
00:10:24,590 --> 00:10:26,250
We're going to read
a line prompting

239
00:10:26,250 --> 00:10:28,635
with a less than sign.

240
00:10:28,635 --> 00:10:31,260
And if it's done, we're going to
break, that code is down here.

241
00:10:31,260 --> 00:10:33,218
And we're going to print
it if we fall through.

242
00:10:33,218 --> 00:10:35,910
So normally, we'll be
reading and printing.

243
00:10:35,910 --> 00:10:37,610
And if the line is
done, we're going

244
00:10:37,610 --> 00:10:39,651
to break out, that's what
we just got done doing.

245
00:10:39,651 --> 00:10:41,940
But the new part is right here.

246
00:10:41,940 --> 00:10:44,120
And this is-- we'll learn
this in the next chapter.

247
00:10:44,120 --> 00:10:47,570
If line sub 0, if the first
character of the line,

248
00:10:47,570 --> 00:10:50,640
is a pound sign, we're
going to continue.

249
00:10:50,640 --> 00:10:53,370
And what continue says is it
doesn't actually get us out

250
00:10:53,370 --> 00:10:56,350
of the loop, it jumps back
up to the top of the loop.

251
00:10:56,350 --> 00:11:00,080
Which means that it
ignores, for that iteration,

252
00:11:00,080 --> 00:11:01,860
the rest of the loop.

253
00:11:01,860 --> 00:11:10,690
So if execution comes in
here and hits this line,

254
00:11:10,690 --> 00:11:13,700
it goes back up to the while.

255
00:11:13,700 --> 00:11:15,630
Which means that
whatever this is,

256
00:11:15,630 --> 00:11:17,380
it's not coming out
of this if, it's

257
00:11:17,380 --> 00:11:19,700
going back up to the white.

258
00:11:19,700 --> 00:11:22,060
So continue ends is
the current iteration

259
00:11:22,060 --> 00:11:23,620
and jumps to the
top of the loop,

260
00:11:23,620 --> 00:11:26,280
and starts the next iteration.

261
00:11:26,280 --> 00:11:29,280
And so if we look at how
the code runs, hello there.

262
00:11:29,280 --> 00:11:30,440
Prints.

263
00:11:30,440 --> 00:11:32,950
Pound sign with the first
character doesn't print,

264
00:11:32,950 --> 00:11:35,230
so there is no print
out right here.

265
00:11:35,230 --> 00:11:37,580
Print this is not done,
and we enter done,

266
00:11:37,580 --> 00:11:39,360
and then the loop ends.

267
00:11:39,360 --> 00:11:42,700
Now another way to draw
this is that continue jumps

268
00:11:42,700 --> 00:11:44,830
to the top of the loop.

269
00:11:44,830 --> 00:11:48,220
It does run the question, right?

270
00:11:48,220 --> 00:11:49,610
It does check the question.

271
00:11:49,610 --> 00:11:52,780
So here's another way
to draw that picture.

272
00:11:52,780 --> 00:11:55,556
And so here again we have a
loop, and it's happily running,

273
00:11:55,556 --> 00:11:56,930
and there can be
breaks in there,

274
00:11:56,930 --> 00:11:58,730
and there could be
continues in there.

275
00:11:58,730 --> 00:12:01,030
And as long as we don't
hit a break or continue,

276
00:12:01,030 --> 00:12:03,080
the loop just runs and
goes up to the top.

277
00:12:03,080 --> 00:12:06,990
And at some point, some
if, we hit the continue.

278
00:12:06,990 --> 00:12:10,110
And like a transporter, instead
of going out of the loop,

279
00:12:10,110 --> 00:12:11,360
we go to the top of the loop.

280
00:12:11,360 --> 00:12:15,640
But it's important that we
go and we check the question.

281
00:12:15,640 --> 00:12:17,990
So the continue is
not likely to exit

282
00:12:17,990 --> 00:12:20,350
the loop unless the
question has become false.

283
00:12:20,350 --> 00:12:23,480
So the continue is likely to
come up here, run some more,

284
00:12:23,480 --> 00:12:25,540
then hit the continue,
it comes up here.

285
00:12:25,540 --> 00:12:26,670
Oops, I did that backwards.

286
00:12:26,670 --> 00:12:29,460
Run some more, clear this out.

287
00:12:29,460 --> 00:12:32,090
So the continue
could run many times.

288
00:12:32,090 --> 00:12:35,010
So we have the loop, loop
runs a bunch of times.

289
00:12:35,010 --> 00:12:36,690
And finally we hit the continue.

290
00:12:36,690 --> 00:12:38,030
Continue goes up to the top.

291
00:12:38,030 --> 00:12:40,700
If it's still true, we'll
run the loop some more.

292
00:12:40,700 --> 00:12:42,480
Than you might hit
the continue, then you

293
00:12:42,480 --> 00:12:43,975
might go up to the
top, come down.

294
00:12:43,975 --> 00:12:45,600
Round, and round,
and round, and round.

295
00:12:45,600 --> 00:12:49,250
Hit the continue again, go
up to the top, yada yada.

296
00:12:49,250 --> 00:12:52,650
Now in this particular
loop, this break eventually

297
00:12:52,650 --> 00:12:55,230
is down here, and
that's how we get out.

298
00:12:55,230 --> 00:13:00,020
So the continue goes back
up to the top of the loop.

299
00:13:00,020 --> 00:13:03,010
So these loops that we
construct with the while keyword

300
00:13:03,010 --> 00:13:05,350
are what we call
indefinite loops.

301
00:13:05,350 --> 00:13:07,440
I mean, looking at the
ones that we've written,

302
00:13:07,440 --> 00:13:09,660
which are two
lines, or six lines,

303
00:13:09,660 --> 00:13:12,180
we can inspect
them and understand

304
00:13:12,180 --> 00:13:13,540
when they're going to stop.

305
00:13:13,540 --> 00:13:17,776
And we're going to know that
they're possible to stop them.

306
00:13:17,776 --> 00:13:21,510
A loop that won't stop
as an infinite loop.

307
00:13:21,510 --> 00:13:23,469
Sometimes these can
be rather complex.

308
00:13:23,469 --> 00:13:25,510
And you may not actually
be able to look at them,

309
00:13:25,510 --> 00:13:30,710
because they're many lines
and so we don't know.

310
00:13:30,710 --> 00:13:32,940
So you have to be real
careful when you construct

311
00:13:32,940 --> 00:13:35,160
these to make sure
that they stop

312
00:13:35,160 --> 00:13:37,220
as things get more complicated.

313
00:13:37,220 --> 00:13:42,380
Now the cousin to indefinite
loops are definite loops.

314
00:13:42,380 --> 00:13:46,280
And definite loops is something
where we have a list of things,

315
00:13:46,280 --> 00:13:48,845
or a set of things that
are a known set of things,

316
00:13:48,845 --> 00:13:50,657
a finite set of things.

317
00:13:50,657 --> 00:13:52,240
And we're going to
write a loop that's

318
00:13:52,240 --> 00:13:53,920
going to go through
that set of things

319
00:13:53,920 --> 00:13:57,430
and do something to each
thing in that set of things.

320
00:13:57,430 --> 00:14:00,510
And the key word that we
use for this is the for.

321
00:14:00,510 --> 00:14:03,680
So we use the Python
for keyword that says

322
00:14:03,680 --> 00:14:05,030
we're going to write a loop.

323
00:14:05,030 --> 00:14:08,010
But instead it just running
until some condition becomes

324
00:14:08,010 --> 00:14:10,440
true or false, or
we hit a break,

325
00:14:10,440 --> 00:14:12,850
we're actually going to
know how many times this

326
00:14:12,850 --> 00:14:13,740
is going to run.

327
00:14:13,740 --> 00:14:16,600
Now, you can actually use break
and continue in for loops.

328
00:14:16,600 --> 00:14:19,840
We call these definite
loops, because how long

329
00:14:19,840 --> 00:14:23,140
they're going to run it
is well known, basically.

330
00:14:23,140 --> 00:14:25,250
So here's a simple
definite loop.

331
00:14:25,250 --> 00:14:27,150
And it's like that
while loop that we just

332
00:14:27,150 --> 00:14:29,660
got done looking at,
where it's counting down

333
00:14:29,660 --> 00:14:31,370
and then saying blast off.

334
00:14:31,370 --> 00:14:33,520
And so the way we
construct this loop is we

335
00:14:33,520 --> 00:14:36,950
have the for keyword, it's
part of Python language.

336
00:14:36,950 --> 00:14:40,940
The in keyword, and then we
have an iteration variable.

337
00:14:40,940 --> 00:14:43,670
I've chosen i as my
iteration variable.

338
00:14:43,670 --> 00:14:45,890
And basically what
we're saying is,

339
00:14:45,890 --> 00:14:50,250
dear Python, run
this indented block--

340
00:14:50,250 --> 00:14:52,930
and there's only one line
in the indented block.

341
00:14:52,930 --> 00:14:56,930
Run it once for each of the
values in this little list.

342
00:14:56,930 --> 00:14:58,420
This is a Python list.

343
00:14:58,420 --> 00:15:00,620
Square brackets
make Python lists,

344
00:15:00,620 --> 00:15:02,240
comma separate the values.

345
00:15:02,240 --> 00:15:05,115
So it says, I would like i to
be five, then run this code.

346
00:15:05,115 --> 00:15:07,240
Then I would like i to be
four, then run this code.

347
00:15:07,240 --> 00:15:09,440
Then I would like i to be
three, then run this code.

348
00:15:09,440 --> 00:15:11,280
i should be two,
then run this code.

349
00:15:11,280 --> 00:15:13,530
And i should be one,
then run this code.

350
00:15:13,530 --> 00:15:17,830
And so this is pretty clear,
and I like this word in.

351
00:15:17,830 --> 00:15:21,134
It says, doot, doot,
doot doot doot doot,

352
00:15:21,134 --> 00:15:22,610
and then run this each time.

353
00:15:22,610 --> 00:15:25,630
And so out of that comes
five, four, three, two, one.

354
00:15:25,630 --> 00:15:28,120
And then the loop is done.

355
00:15:28,120 --> 00:15:30,170
Python is doing all
the tricky bits here.

356
00:15:30,170 --> 00:15:34,739
Python's figuring all
these things out for us

357
00:15:34,739 --> 00:15:36,530
and handling all this,
and then we're done.

358
00:15:36,530 --> 00:15:39,690
And so if you look at it, we
have an iteration variable,

359
00:15:39,690 --> 00:15:41,340
but we didn't have
to increment it,

360
00:15:41,340 --> 00:15:42,660
we didn't have to do anything.

361
00:15:42,660 --> 00:15:44,950
Python took care of a
lot of things for us.

362
00:15:44,950 --> 00:15:47,720
And so when we're looping
through known list of things,

363
00:15:47,720 --> 00:15:49,627
or later when we
read a file, we're

364
00:15:49,627 --> 00:15:51,460
going to loop through
the lines in the file.

365
00:15:51,460 --> 00:15:54,440
And so the for loop is
a really nice, powerful,

366
00:15:54,440 --> 00:15:56,170
and its syntactically cleaner.

367
00:15:56,170 --> 00:15:58,110
It's really quite nice.

368
00:15:58,110 --> 00:16:00,500
Now it's important to
realize that you don't have

369
00:16:00,500 --> 00:16:02,300
to just loop through numbers.

370
00:16:02,300 --> 00:16:04,414
I did that one with a set
of descending numbers,

371
00:16:04,414 --> 00:16:06,080
so that was equivalent
to the while loop

372
00:16:06,080 --> 00:16:07,670
that I started at beginning.

373
00:16:07,670 --> 00:16:10,920
But this is a loop where what
it's going to loop through

374
00:16:10,920 --> 00:16:14,990
is a list-- closed square
brackets are a list in Python.

375
00:16:14,990 --> 00:16:18,990
This is a list of three strings,
Joseph, Glenn, and Sally.

376
00:16:18,990 --> 00:16:21,920
They're string constants,
and then commas

377
00:16:21,920 --> 00:16:24,320
are how we make lists.

378
00:16:24,320 --> 00:16:27,205
And so friends is a
mnemonic variable.

379
00:16:27,205 --> 00:16:29,580
Python doesn't know anything
about friends in particular,

380
00:16:29,580 --> 00:16:31,910
but I've chosen this
variable name to be friends.

381
00:16:31,910 --> 00:16:35,110
And it's a list of three
people, Joseph, Glenn and Sally.

382
00:16:35,110 --> 00:16:37,880
And so I have an iteration
variable called friend,

383
00:16:37,880 --> 00:16:40,160
and I'm going to loop
through this set of friends.

384
00:16:40,160 --> 00:16:42,530
Now, Python doesn't know
anything about singular,

385
00:16:42,530 --> 00:16:44,280
Python doesn't know
anything about plural.

386
00:16:44,280 --> 00:16:45,863
I'm just choosing
these variable names

387
00:16:45,863 --> 00:16:48,450
because it makes a lot of sense.

388
00:16:48,450 --> 00:16:51,840
This is a set of friends,
because it has three of minute,

389
00:16:51,840 --> 00:16:54,040
and this is a single friend.

390
00:16:54,040 --> 00:16:56,250
What it's really
going to do is friend

391
00:16:56,250 --> 00:16:58,620
is going to take on the
successive values Joseph, Glenn

392
00:16:58,620 --> 00:17:00,630
and Sally, and this
little block of code

393
00:17:00,630 --> 00:17:04,770
is going to run once for each
of those three items in the set.

394
00:17:04,770 --> 00:17:07,349
And the variable
friend is going to take

395
00:17:07,349 --> 00:17:10,170
on the successive
values of that set.

396
00:17:10,170 --> 00:17:13,880
So out of this comes three lines
of print out, happy new year

397
00:17:13,880 --> 00:17:16,020
Joseph, happy new year
Glenn, happy new year Sally.

398
00:17:16,020 --> 00:17:18,670
Of course, this is the
i bit right over here.

399
00:17:18,670 --> 00:17:22,060
But we just made it so,
hey Python, look, however

400
00:17:22,060 --> 00:17:24,780
many friends there are, run
this code one time for each one.

401
00:17:24,780 --> 00:17:26,829
Change this variable,
friend, to be each

402
00:17:26,829 --> 00:17:28,990
of the success ones in order.

403
00:17:28,990 --> 00:17:30,470
And then we print
that we're done.

404
00:17:30,470 --> 00:17:31,730
OK.

405
00:17:31,730 --> 00:17:33,757
So the for loop, we
go and try to make

406
00:17:33,757 --> 00:17:34,840
a picture of the for loop.

407
00:17:34,840 --> 00:17:36,730
The for loop's kind
of a powerful thing.

408
00:17:36,730 --> 00:17:39,530
It does two things.

409
00:17:39,530 --> 00:17:42,700
It decides if we're
done or not, how

410
00:17:42,700 --> 00:17:45,510
do we keep going in the loop.

411
00:17:45,510 --> 00:17:47,010
And as long as we
keep going, we're

412
00:17:47,010 --> 00:17:49,440
going to advance the i value,
the iteration variable.

413
00:17:49,440 --> 00:17:51,690
It takes care of the
responsibility of changing

414
00:17:51,690 --> 00:17:54,160
the iteration variable, we do
not have to add lines of code

415
00:17:54,160 --> 00:17:57,040
in that change the
iteration variable.

416
00:17:57,040 --> 00:18:01,520
And so if we take a look,
we come in, are we done?

417
00:18:01,520 --> 00:18:02,310
We're not done.

418
00:18:02,310 --> 00:18:04,350
Set i to the right
thing, then print it.

419
00:18:04,350 --> 00:18:08,370
Out comes 5, advanced
i, advance i.

420
00:18:08,370 --> 00:18:10,900
Print it, advance it, print
it, advance it, print it.

421
00:18:10,900 --> 00:18:13,360
Oh, now we're done.

422
00:18:13,360 --> 00:18:16,510
i was not the thing that
decided when we were done.

423
00:18:16,510 --> 00:18:18,910
The for loop just
keeps track internally

424
00:18:18,910 --> 00:18:22,830
as i moves through these things
and goes, oh, I'm all done.

425
00:18:22,830 --> 00:18:24,310
I'll take care of that.

426
00:18:24,310 --> 00:18:25,260
You finished.

427
00:18:25,260 --> 00:18:26,600
So there's no if in here.

428
00:18:26,600 --> 00:18:29,140
It's not like, if
i equals 1, stop.

429
00:18:29,140 --> 00:18:29,920
No, no.

430
00:18:29,920 --> 00:18:31,810
It just says, you told
me to do five things,

431
00:18:31,810 --> 00:18:34,226
I'm going to do five things,
and then we're going to stop.

432
00:18:34,226 --> 00:18:40,930
And so again, the for loop
here has got two functions.

433
00:18:40,930 --> 00:18:42,760
Decides how long the
loop's going to run,

434
00:18:42,760 --> 00:18:44,690
and changes the
iteration variable

435
00:18:44,690 --> 00:18:47,770
based on what you've told
it to in this in clause.

436
00:18:47,770 --> 00:18:50,300

437
00:18:50,300 --> 00:18:53,580
So I think in is a
real elegant construct.

438
00:18:53,580 --> 00:18:58,300
It's just a key word, but
if you think about math,

439
00:18:58,300 --> 00:18:59,870
if you're familiar
with sets, it's

440
00:18:59,870 --> 00:19:02,150
like something inside
of a set of something.

441
00:19:02,150 --> 00:19:05,050
I think it's a real pretty
way to think about it.

442
00:19:05,050 --> 00:19:06,580
And you can think
of a little more

443
00:19:06,580 --> 00:19:08,380
abstractly, that you
say, well, here's

444
00:19:08,380 --> 00:19:11,040
a little indented block of code.

445
00:19:11,040 --> 00:19:15,487
And I want it to run some number
of times, for each of the i

446
00:19:15,487 --> 00:19:18,670
values in the set, five,
four, three, two, one.

447
00:19:18,670 --> 00:19:19,940
That's how I think of it.

448
00:19:19,940 --> 00:19:23,180
So I think this is a
real pretty syntax.

449
00:19:23,180 --> 00:19:25,500
Different languages have
different looping syntax.

450
00:19:25,500 --> 00:19:29,030
I think this is really a very
expressive, very pretty one.

451
00:19:29,030 --> 00:19:36,180

452
00:19:36,180 --> 00:19:40,470
So one way to think about this
picture is that the for loop

453
00:19:40,470 --> 00:19:43,930
causes repeated execution, and
we're driving in this circle.

454
00:19:43,930 --> 00:19:45,430
and then we stop.

455
00:19:45,430 --> 00:19:47,280
The other way to
think about this

456
00:19:47,280 --> 00:19:50,680
is to think about it a
little more abstractly.

457
00:19:50,680 --> 00:19:53,820
To say, hm, at the end of
the day, all I'm really

458
00:19:53,820 --> 00:19:57,930
telling Python is I want to
execute this block of code

459
00:19:57,930 --> 00:20:00,820
five times, and I want
the variable i to change

460
00:20:00,820 --> 00:20:01,880
to these three values.

461
00:20:01,880 --> 00:20:03,380
So in a way, you
could think of this

462
00:20:03,380 --> 00:20:06,120
as expanded is the for
loop sets it to five,

463
00:20:06,120 --> 00:20:06,990
then runs your code.

464
00:20:06,990 --> 00:20:09,300
The for loop then sets it
to four, runs your code.

465
00:20:09,300 --> 00:20:11,680
The for loop sets it to
three, runs your code.

466
00:20:11,680 --> 00:20:14,795
For loop sets it to two, runs
your code, sets it to one,

467
00:20:14,795 --> 00:20:15,840
runs your code.

468
00:20:15,840 --> 00:20:19,990
These two ways of looking
at it are the same

469
00:20:19,990 --> 00:20:22,530
from your perspective,
because you're just

470
00:20:22,530 --> 00:20:24,580
asking Python to do something.

471
00:20:24,580 --> 00:20:28,050
Whether it does it this way or
whether it does it this way,

472
00:20:28,050 --> 00:20:30,450
you hardly can tell
the difference.

473
00:20:30,450 --> 00:20:32,320
It's probably going
to do it this way.

474
00:20:32,320 --> 00:20:35,350
But logically it's
not that different.

475
00:20:35,350 --> 00:20:37,160
It's not different
from doing it this way.

476
00:20:37,160 --> 00:20:39,810
You're saying run
this block of, code

477
00:20:39,810 --> 00:20:41,510
change i in the following way.

478
00:20:41,510 --> 00:20:44,870

479
00:20:44,870 --> 00:20:46,770
Cool.

480
00:20:46,770 --> 00:20:48,600
It's like we don't
have to worry.

481
00:20:48,600 --> 00:20:51,670
I mean, we can use mentally
either model of what's

482
00:20:51,670 --> 00:20:53,549
going on inside, because
it doesn't matter,

483
00:20:53,549 --> 00:20:54,590
because they're the same.

484
00:20:54,590 --> 00:20:57,330

485
00:20:57,330 --> 00:21:00,360
OK, so these definite
loops are really cool.

486
00:21:00,360 --> 00:21:01,820
Starting in a
couple of chapters,

487
00:21:01,820 --> 00:21:04,430
we'll mostly use definite
loops to go through lists,

488
00:21:04,430 --> 00:21:08,400
or dictionaries, or
tuples, or files.

489
00:21:08,400 --> 00:21:10,020
And so it's a finite
set of things.

490
00:21:10,020 --> 00:21:11,728
It can be a large set
of things, but it's

491
00:21:11,728 --> 00:21:13,710
a finite set of things.

492
00:21:13,710 --> 00:21:14,510
OK.

493
00:21:14,510 --> 00:21:18,980
So now I want to talk
about loop idioms.

494
00:21:18,980 --> 00:21:24,180
Loop idioms are how
we construct loops.

495
00:21:24,180 --> 00:21:28,120
And the loops have some
kind of a goal in mind.

496
00:21:28,120 --> 00:21:30,000
Finding the largest,
we've played with that.

497
00:21:30,000 --> 00:21:33,340
Finding the smallest,
counting the number of things.

498
00:21:33,340 --> 00:21:35,450
Looking for lines that
start with pound signs,

499
00:21:35,450 --> 00:21:36,980
something like that.

500
00:21:36,980 --> 00:21:40,700
They have a high level view of
what they're supposed to do,

501
00:21:40,700 --> 00:21:43,800
and then we have to build
a loop to accomplish that.

502
00:21:43,800 --> 00:21:47,630
And and this goes back to how we
have to think like a computer.

503
00:21:47,630 --> 00:21:50,886
We have to say, hey computer,
do this over, and over,

504
00:21:50,886 --> 00:21:52,260
and over again,
and then I'll get

505
00:21:52,260 --> 00:21:54,380
what I want when you've done
that over, and over again.

506
00:21:54,380 --> 00:21:55,800
You have to do something
a million times.

507
00:21:55,800 --> 00:21:57,258
I'm not going to
sit here and wait.

508
00:21:57,258 --> 00:21:59,030
At the end, I'll
get what I want.

509
00:21:59,030 --> 00:22:02,850
So I call these smart loops,
or how to build intelligence

510
00:22:02,850 --> 00:22:03,580
into loops.

511
00:22:03,580 --> 00:22:06,290

512
00:22:06,290 --> 00:22:09,410
So for example, we want
the largest number.

513
00:22:09,410 --> 00:22:11,760
But we have to
construct a loop that

514
00:22:11,760 --> 00:22:15,260
will get us the largest number
thinking like a computer.

515
00:22:15,260 --> 00:22:18,940
Thinking computationally
thinking like a computer.

516
00:22:18,940 --> 00:22:21,960
So idea is that we have
some kind of a loop,

517
00:22:21,960 --> 00:22:25,950
and we're going to through
some list of things,

518
00:22:25,950 --> 00:22:27,898
and this is going to
run a bunch of times.

519
00:22:27,898 --> 00:22:29,606
But the way we're
going to do it is we're

520
00:22:29,606 --> 00:22:32,110
going to set something up
before the loop starts,

521
00:22:32,110 --> 00:22:34,990
we're going to do something
to each of the things that's

522
00:22:34,990 --> 00:22:36,344
being looked at.

523
00:22:36,344 --> 00:22:37,760
And at the end,
we're going to get

524
00:22:37,760 --> 00:22:40,500
the result we're looking for.

525
00:22:40,500 --> 00:22:43,310
And so in the
middle, it's working,

526
00:22:43,310 --> 00:22:45,560
it's in the middle working.

527
00:22:45,560 --> 00:22:47,260
And then here is the payoff.

528
00:22:47,260 --> 00:22:51,030
The payoff is at the end when we
get the information that we're

529
00:22:51,030 --> 00:22:52,360
interested in.

530
00:22:52,360 --> 00:22:57,850
So I will use in the next few
examples this simple loop.

531
00:22:57,850 --> 00:22:59,880
And right now, it
doesn't do much.

532
00:22:59,880 --> 00:23:02,570
It does a print before, and it
has this variable thing that

533
00:23:02,570 --> 00:23:06,150
goes through the successive
values of these numbers,

534
00:23:06,150 --> 00:23:07,110
and it prints it out.

535
00:23:07,110 --> 00:23:11,040
So that middle part says,
run this six times, once

536
00:23:11,040 --> 00:23:13,520
for each of those
values, and then after.

537
00:23:13,520 --> 00:23:16,160
And so we will add some
intelligence at the beginning,

538
00:23:16,160 --> 00:23:17,910
we'll add some
intelligence in the middle,

539
00:23:17,910 --> 00:23:19,870
and we'll add some
intelligence at the end.

540
00:23:19,870 --> 00:23:22,780
And then the whole thing
will accomplish what we want.

541
00:23:22,780 --> 00:23:26,150
Right now this is
not that intelligent.

542
00:23:26,150 --> 00:23:28,990
So now what I want to do is
I want to review the thing

543
00:23:28,990 --> 00:23:32,001
we did, and I want you to
remember what the largest

544
00:23:32,001 --> 00:23:33,500
number is, and I'm
going to show you

545
00:23:33,500 --> 00:23:35,750
a sequence of numbers in order.

546
00:23:35,750 --> 00:23:36,980
Ready?

547
00:23:36,980 --> 00:23:39,610
I'll do it quickly because
you've seen this before.

548
00:23:39,610 --> 00:23:41,650
So I'm only showing you
one number at a time,

549
00:23:41,650 --> 00:23:44,220
so you want to tell me
what the largest number is,

550
00:23:44,220 --> 00:23:46,460
so here we go.

551
00:23:46,460 --> 00:23:49,100
The first number is 9.

552
00:23:49,100 --> 00:23:52,210
The second number is 41.

553
00:23:52,210 --> 00:23:54,980
The third number is 12.

554
00:23:54,980 --> 00:23:57,220
The fourth number is 3.

555
00:23:57,220 --> 00:23:59,970
The fifth number is 74.

556
00:23:59,970 --> 00:24:03,900
And the six number is 15.

557
00:24:03,900 --> 00:24:05,850
So what was the largest number?

558
00:24:05,850 --> 00:24:09,060

559
00:24:09,060 --> 00:24:13,190
Did you have to go back, or
did you remember how to do it?

560
00:24:13,190 --> 00:24:16,150
Well, I will give you a clue.

561
00:24:16,150 --> 00:24:18,760
It was 74.

562
00:24:18,760 --> 00:24:21,380
That's because I know.

563
00:24:21,380 --> 00:24:22,990
Now if you did that,
and you had to do

564
00:24:22,990 --> 00:24:24,940
that for 20 or 30
numbers, you'd have

565
00:24:24,940 --> 00:24:27,270
to create a mental
algorithm in your head

566
00:24:27,270 --> 00:24:30,010
to approach it and
stay concentrated.

567
00:24:30,010 --> 00:24:31,150
Focused.

568
00:24:31,150 --> 00:24:33,900
So you would have create a
variable in your head called

569
00:24:33,900 --> 00:24:36,229
largest so far.

570
00:24:36,229 --> 00:24:38,520
I would show you the first
number, which would be nine.

571
00:24:38,520 --> 00:24:43,030
And you would go, well, nine
is larger than negative one,

572
00:24:43,030 --> 00:24:44,310
so I will keep that.

573
00:24:44,310 --> 00:24:47,510
That's the new largest I've seen
so far, that's pretty awesome.

574
00:24:47,510 --> 00:24:50,516
Because it's way better
than negative one.

575
00:24:50,516 --> 00:24:52,300
41, I thought nine was good.

576
00:24:52,300 --> 00:24:54,910
But 41, that is a lot better.

577
00:24:54,910 --> 00:24:56,670
So I'm going to keep that one.

578
00:24:56,670 --> 00:24:57,336
That's the best.

579
00:24:57,336 --> 00:24:58,810
It's the largest
we've seen so far.

580
00:24:58,810 --> 00:25:02,560
We've only seen two numbers,
but the best we've seen so far

581
00:25:02,560 --> 00:25:03,510
is 41.

582
00:25:03,510 --> 00:25:05,590
So 12.

583
00:25:05,590 --> 00:25:06,680
That's not larger.

584
00:25:06,680 --> 00:25:08,500
Who cares about that?

585
00:25:08,500 --> 00:25:11,475
It's not as big as 41, so we'll
just go right on to the next.

586
00:25:11,475 --> 00:25:12,100
On to the next.

587
00:25:12,100 --> 00:25:13,340
Three.

588
00:25:13,340 --> 00:25:16,160
That's lame when we're
looking for large numbers.

589
00:25:16,160 --> 00:25:16,660
So we skip.

590
00:25:16,660 --> 00:25:18,070
Whoa, 74.

591
00:25:18,070 --> 00:25:19,800
That's a rockingly large number.

592
00:25:19,800 --> 00:25:23,120
So that's actually the
largest we've seen so far.

593
00:25:23,120 --> 00:25:26,960
Because it's bigger than 41,
and 41 was the former champion

594
00:25:26,960 --> 00:25:28,870
largest we've seen so far.

595
00:25:28,870 --> 00:25:31,260
And there's 74, so
we keep that one.

596
00:25:31,260 --> 00:25:33,787
I don't know how many of these
things we're going to see.

597
00:25:33,787 --> 00:25:34,870
We could see lots of them.

598
00:25:34,870 --> 00:25:38,050
But the next one we see 15.

599
00:25:38,050 --> 00:25:39,640
Well, that's no good.

600
00:25:39,640 --> 00:25:43,630
We got 74 already, 74 is,
like, totally awesome.

601
00:25:43,630 --> 00:25:45,280
So now, oh, we're done.

602
00:25:45,280 --> 00:25:46,330
So hey, we're done.

603
00:25:46,330 --> 00:25:50,670
And so 74 is the champion.

604
00:25:50,670 --> 00:25:51,542
That is the largest.

605
00:25:51,542 --> 00:25:53,250
It's not even the
largest so far anymore,

606
00:25:53,250 --> 00:25:57,180
it's actually the largest.

607
00:25:57,180 --> 00:25:58,550
It's the largest.

608
00:25:58,550 --> 00:26:00,829
So again, we had this
thing at the top,

609
00:26:00,829 --> 00:26:02,120
we had this loop in the middle.

610
00:26:02,120 --> 00:26:04,250
At the bottom is where
you get the payoff.

611
00:26:04,250 --> 00:26:06,742
And the payoff is
not in the middle.

612
00:26:06,742 --> 00:26:09,200
While we're largest so far,
largest so far, largest so far.

613
00:26:09,200 --> 00:26:11,020
But at the end, it
turned out once you've

614
00:26:11,020 --> 00:26:13,280
looked at all the
variables, all the values,

615
00:26:13,280 --> 00:26:16,320
the largest so far is,
indeed, the largest.

616
00:26:16,320 --> 00:26:19,160
OK, so here's the
algorithm for this.

617
00:26:19,160 --> 00:26:20,420
I have some variables.

618
00:26:20,420 --> 00:26:22,150
And remember that
underscores are

619
00:26:22,150 --> 00:26:25,525
valid characters in variables.

620
00:26:25,525 --> 00:26:28,650
I'm being a little
over explicit in this.

621
00:26:28,650 --> 00:26:31,710
So I have a variable
called largest so far.

622
00:26:31,710 --> 00:26:37,160
And what I do is I set
it to negative one.

623
00:26:37,160 --> 00:26:39,400
Then I print before, so
we can see that largest

624
00:26:39,400 --> 00:26:42,030
so far is negative one.

625
00:26:42,030 --> 00:26:46,082
Then we have a for loop, and my
iteration variable is the_num.

626
00:26:46,082 --> 00:26:47,790
So that's going to
take on the successive

627
00:26:47,790 --> 00:26:54,390
values 9, 41, 12, 3, 74, 15, and
run this indented loop of code.

628
00:26:54,390 --> 00:26:59,440
And so the_num will be
nine first time through.

629
00:26:59,440 --> 00:27:03,440
If the_num, 9, is greater
than largest so far,

630
00:27:03,440 --> 00:27:11,470
then grab the_num and assign
it into largest so far.

631
00:27:11,470 --> 00:27:14,470
Then print at the end of
each loop largest so far

632
00:27:14,470 --> 00:27:15,920
and the_num.

633
00:27:15,920 --> 00:27:19,020
So in effect, the_num is nine.

634
00:27:19,020 --> 00:27:22,800
We compare it to negative
1, and nine is higher.

635
00:27:22,800 --> 00:27:26,280
So we make largest
so far be nine.

636
00:27:26,280 --> 00:27:32,700
Next time through
the loop, num is 41.

637
00:27:32,700 --> 00:27:35,780
So we compare largest
so far with 41,

638
00:27:35,780 --> 00:27:38,190
and we like it, so we store it.

639
00:27:38,190 --> 00:27:40,400
So we like it, we run
it, and we print out,

640
00:27:40,400 --> 00:27:43,310
41 is the largest
we've seen so far.

641
00:27:43,310 --> 00:27:44,700
Then we run again.

642
00:27:44,700 --> 00:27:47,930
We come in, the_num
points to 12.

643
00:27:47,930 --> 00:27:53,650
The_num, 12, is not greater
than 41, and so we skip.

644
00:27:53,650 --> 00:27:58,920
So the largest so far
stays 41, and we see 12.

645
00:27:58,920 --> 00:28:03,480
Similarly, the_num
advances to three.

646
00:28:03,480 --> 00:28:04,630
We skip.

647
00:28:04,630 --> 00:28:08,160
So we saw three, but the
largest so far is still 41.

648
00:28:08,160 --> 00:28:12,170
Continuing, the_num is now 74.

649
00:28:12,170 --> 00:28:13,070
It runs.

650
00:28:13,070 --> 00:28:16,940
74 is greater than 41.

651
00:28:16,940 --> 00:28:18,840
And so we run this code.

652
00:28:18,840 --> 00:28:23,300
And so we say, 74 is
stuck in largest so far.

653
00:28:23,300 --> 00:28:25,140
And indeed, then
we print it out.

654
00:28:25,140 --> 00:28:27,580
And largest so far is now 74.

655
00:28:27,580 --> 00:28:29,160
We continue on.

656
00:28:29,160 --> 00:28:30,560
We go up more time.

657
00:28:30,560 --> 00:28:35,510
the_nu, points to 15, but
15 is not larger than 74.

658
00:28:35,510 --> 00:28:40,720
And so we skip, we print out 15
and 74, and then we come out.

659
00:28:40,720 --> 00:28:45,410
And at the end, we get
the largest so far.

660
00:28:45,410 --> 00:28:49,260
The name no longer-- I mean,
largest so far at the end

661
00:28:49,260 --> 00:28:51,610
is the largest, but
the variable name.

662
00:28:51,610 --> 00:28:52,990
OK.

663
00:28:52,990 --> 00:28:55,600
Got it?

664
00:28:55,600 --> 00:28:57,180
That's one idiom.

665
00:28:57,180 --> 00:29:00,580
So let's just switch
to another idiom.

666
00:29:00,580 --> 00:29:01,292
Now counting.

667
00:29:01,292 --> 00:29:03,250
How many things are we
going to, how many times

668
00:29:03,250 --> 00:29:05,250
is loop going to execute,
how many things are we

669
00:29:05,250 --> 00:29:06,360
going to find in the loop?

670
00:29:06,360 --> 00:29:07,990
It's all the same notion.

671
00:29:07,990 --> 00:29:10,090
And the pattern
is really simple.

672
00:29:10,090 --> 00:29:11,657
We start some variable, zork.

673
00:29:11,657 --> 00:29:13,240
A better name for
this would be count,

674
00:29:13,240 --> 00:29:15,740
but I want to call it zork.

675
00:29:15,740 --> 00:29:16,960
And then we have a loop.

676
00:29:16,960 --> 00:29:19,850
And then in the loop,
we just add one to zork.

677
00:29:19,850 --> 00:29:22,444
And at the end,
zork-- that should

678
00:29:22,444 --> 00:29:24,200
be light blue right there.

679
00:29:24,200 --> 00:29:26,507
Zork should be the total count.

680
00:29:26,507 --> 00:29:29,090
Now of course, we can look at
it and say it's going to be six.

681
00:29:29,090 --> 00:29:31,924
But assume this loop is
looping through a million lines

682
00:29:31,924 --> 00:29:33,340
in a file, or
something like that.

683
00:29:33,340 --> 00:29:38,685
So it's cheating to look at
it and say, oh, it's six.

684
00:29:38,685 --> 00:29:40,310
Because we want to
actually compute it.

685
00:29:40,310 --> 00:29:41,750
So it's really simple.

686
00:29:41,750 --> 00:29:43,450
Zork starts at zero.

687
00:29:43,450 --> 00:29:45,211
It's going to run,
zork is one now,

688
00:29:45,211 --> 00:29:49,420
and two, three, four,
five, six, and then

689
00:29:49,420 --> 00:29:53,010
we've run out of stuff,
and then we print out six.

690
00:29:53,010 --> 00:29:54,330
So that's the idiom.

691
00:29:54,330 --> 00:29:57,980
Before, during, and after.

692
00:29:57,980 --> 00:30:00,110
We do something before,
we do something during.

693
00:30:00,110 --> 00:30:02,910
And in a sense,
this zork here is

694
00:30:02,910 --> 00:30:05,070
the number we've seen so far.

695
00:30:05,070 --> 00:30:07,330
And at the end, it
becomes the total number.

696
00:30:07,330 --> 00:30:10,090

697
00:30:10,090 --> 00:30:12,387
Summing in the
loop, very similar.

698
00:30:12,387 --> 00:30:14,220
Again, you have to think
of this as, there's

699
00:30:14,220 --> 00:30:16,460
a whole bunch of variables here.

700
00:30:16,460 --> 00:30:18,890
We start a variable at zero.

701
00:30:18,890 --> 00:30:21,180
Each time through the
loop, we add whatever

702
00:30:21,180 --> 00:30:22,330
it is that we're seeing.

703
00:30:22,330 --> 00:30:27,760
Instead of adding one, we're
adding 9, 41, 12, 3, 74, 15.

704
00:30:27,760 --> 00:30:34,460
And zork would be best
thought of as running total.

705
00:30:34,460 --> 00:30:35,920
So zork is the running total.

706
00:30:35,920 --> 00:30:39,600
And so if you look at the
numbers, running total's nine,

707
00:30:39,600 --> 00:30:43,470
numbering total's 50, running
total's 62, 65, 130, and 154.

708
00:30:43,470 --> 00:30:46,160
And then we skip
out, and at the end

709
00:30:46,160 --> 00:30:50,280
the running total
becomes the total.

710
00:30:50,280 --> 00:30:52,850
So that's another
of these patterns

711
00:30:52,850 --> 00:30:54,660
that we do something
at the beginning,

712
00:30:54,660 --> 00:30:59,200
we do something in the middle,
and we have something very nice

713
00:30:59,200 --> 00:31:00,950
for ourselves at the end.

714
00:31:00,950 --> 00:31:05,020

715
00:31:05,020 --> 00:31:07,330
Finding the average of
a sequence of values

716
00:31:07,330 --> 00:31:10,750
is the combination of the
two previous patterns.

717
00:31:10,750 --> 00:31:13,860
This time, I'm going to use
more mnemonic variables.

718
00:31:13,860 --> 00:31:17,480
Other variable called count,
everyone calls this count.

719
00:31:17,480 --> 00:31:20,830
Sum, now, total would maybe
be a better word for this.

720
00:31:20,830 --> 00:31:22,450
The running total.

721
00:31:22,450 --> 00:31:25,920
And then the count and
the sum start out at zero.

722
00:31:25,920 --> 00:31:27,450
And then each time
through the loop,

723
00:31:27,450 --> 00:31:30,480
count equals count plus 1,
so we're adding one to count.

724
00:31:30,480 --> 00:31:32,100
Sum equals sum plus
value, so we're

725
00:31:32,100 --> 00:31:35,150
adding one to sum-- I
mean, adding the value.

726
00:31:35,150 --> 00:31:39,280
Value, of course, being
9, 41, 12, 3, 74, 15.

727
00:31:39,280 --> 00:31:42,400
And then at the very end,
we can print out the number.

728
00:31:42,400 --> 00:31:45,450
We have six things
with a total of 154,

729
00:31:45,450 --> 00:31:47,210
and then we calculate
the average.

730
00:31:47,210 --> 00:31:49,470
Of course, these
are integer numbers.

731
00:31:49,470 --> 00:31:51,760
And so this is a
truncating division.

732
00:31:51,760 --> 00:31:58,440
So 154 over 6 equals 25,
and not 25 point something.

733
00:31:58,440 --> 00:32:02,080
If we were in Python 3000,
Python 3, it'd be better.

734
00:32:02,080 --> 00:32:05,710
So the integer averages of the
numbers we just looked at it

735
00:32:05,710 --> 00:32:08,360
is 25.

736
00:32:08,360 --> 00:32:10,390
So sometimes we're
searching, like for a needle

737
00:32:10,390 --> 00:32:11,610
in a haystack.

738
00:32:11,610 --> 00:32:13,700
Looking for something.

739
00:32:13,700 --> 00:32:15,804
And again, you have to
think of, like, your hand

740
00:32:15,804 --> 00:32:17,220
is some amount of
data, and you've

741
00:32:17,220 --> 00:32:18,630
got to hunt for something.

742
00:32:18,630 --> 00:32:19,570
And there might be
a million things,

743
00:32:19,570 --> 00:32:20,710
and you might only
want five of them.

744
00:32:20,710 --> 00:32:22,210
And you can use
look by hand, or you

745
00:32:22,210 --> 00:32:24,418
can write a loop that's got
an if statement that says

746
00:32:24,418 --> 00:32:25,430
found it.

747
00:32:25,430 --> 00:32:28,280
Maybe I found it at line
seven, or found it wherever.

748
00:32:28,280 --> 00:32:31,380
So this is filtering, or
finding, or searching,

749
00:32:31,380 --> 00:32:34,780
looking for a needle in
a haystack in a loop.

750
00:32:34,780 --> 00:32:38,920
And so the idea basically
is that we have this loop.

751
00:32:38,920 --> 00:32:42,990
It's going to go through all
the values, 9, 41, 12, 3, 74.

752
00:32:42,990 --> 00:32:46,270
But we put in the loop,
we embed an if statement.

753
00:32:46,270 --> 00:32:48,450
If the value we're looking
at is greater than 20,

754
00:32:48,450 --> 00:32:50,380
print I found it.

755
00:32:50,380 --> 00:32:55,350
So when value is nine, this
is going to do nothing.

756
00:32:55,350 --> 00:32:57,930
And just go and
make value be 41.

757
00:32:57,930 --> 00:33:00,790
And then value 41,
oh, yup, there we go.

758
00:33:00,790 --> 00:33:03,850
Print large number,
so off this comes.

759
00:33:03,850 --> 00:33:06,330
Then value becomes
12, nothing happens.

760
00:33:06,330 --> 00:33:08,480
Value becomes three,
nothing happens.

761
00:33:08,480 --> 00:33:11,620
Value becomes 74, oops, this
time it's going to happen.

762
00:33:11,620 --> 00:33:13,940
So out comes large number 74.

763
00:33:13,940 --> 00:33:16,990
Then value becomes
15, nothing happens.

764
00:33:16,990 --> 00:33:18,640
And then value is all done.

765
00:33:18,640 --> 00:33:20,700
And so it comes and finishes.

766
00:33:20,700 --> 00:33:25,260
So this is the searching,
or filtering, or catching,

767
00:33:25,260 --> 00:33:25,820
or whatever.

768
00:33:25,820 --> 00:33:29,520

769
00:33:29,520 --> 00:33:32,560
We can also, if we don't just
want to print everything out,

770
00:33:32,560 --> 00:33:34,247
we want to say, is
something in there?

771
00:33:34,247 --> 00:33:35,830
We'll look through
this million things

772
00:33:35,830 --> 00:33:38,794
and tell me if blah exists.

773
00:33:38,794 --> 00:33:40,210
And in this, we're
going introduce

774
00:33:40,210 --> 00:33:42,410
the notion of Boolean variable.

775
00:33:42,410 --> 00:33:43,692
Boolean is a true/false.

776
00:33:43,692 --> 00:33:45,400
It only has two values,
and we've already

777
00:33:45,400 --> 00:33:47,190
used it in the wild, true.

778
00:33:47,190 --> 00:33:50,410
So that capital True,
that is a constant.

779
00:33:50,410 --> 00:33:56,191
Just like seven, or
42, or 99, or Sam.

780
00:33:56,191 --> 00:33:58,440
And so we're going to make
this variable called found.

781
00:33:58,440 --> 00:34:02,480
Now found is mnemonic variable,
it's just a name I picked.

782
00:34:02,480 --> 00:34:04,230
So found equals False.

783
00:34:04,230 --> 00:34:06,970
This is going to be false until
we find what we're looking for,

784
00:34:06,970 --> 00:34:08,860
and then it's going
to switch to true.

785
00:34:08,860 --> 00:34:11,320
So it starts out
and it's false, then

786
00:34:11,320 --> 00:34:15,739
we're going to run this
bit of code three times.

787
00:34:15,739 --> 00:34:18,150
And if the value that we
are looking at is three,

788
00:34:18,150 --> 00:34:20,389
then we're going to
set found to be true,

789
00:34:20,389 --> 00:34:23,400
and we'll print found
value each time through.

790
00:34:23,400 --> 00:34:27,210
So value's going to take
on 9, 41, 12, 3, 74,

791
00:34:27,210 --> 00:34:29,770
so we get a line of
output for each one.

792
00:34:29,770 --> 00:34:32,030
And the first time
through, it's not

793
00:34:32,030 --> 00:34:33,920
yet found, because
we're looking at a nine.

794
00:34:33,920 --> 00:34:35,340
Second time, we've
not yet found,

795
00:34:35,340 --> 00:34:37,159
we looked at 41, still false.

796
00:34:37,159 --> 00:34:39,960
So it can stay false
for a long time.

797
00:34:39,960 --> 00:34:41,109
Oh, we found a true.

798
00:34:41,109 --> 00:34:43,400
And then that means that this
code's going to run once.

799
00:34:43,400 --> 00:34:46,440
And so you can think of this
found variable as sticky.

800
00:34:46,440 --> 00:34:48,909
It's going to stay false,
and then the rest of the loop

801
00:34:48,909 --> 00:34:52,392
it's going to stay true,
and at the end it is true.

802
00:34:52,392 --> 00:34:54,600
Now the way we usually do
these kinds of things is we

803
00:34:54,600 --> 00:34:56,225
don't bother with
this print statement,

804
00:34:56,225 --> 00:34:57,980
so we wouldn't see
all this stuff.

805
00:34:57,980 --> 00:35:00,477
All we see is before
false, after true.

806
00:35:00,477 --> 00:35:02,810
And after it would just tell
us that, yeah, we found it.

807
00:35:02,810 --> 00:35:06,330
There was a three somewhere
in that long list of numbers.

808
00:35:06,330 --> 00:35:09,560
I'm just adding this print
statement so we can trace it.

809
00:35:09,560 --> 00:35:12,920
But basically, this
loop from here to here

810
00:35:12,920 --> 00:35:17,075
is asking the question, is there
the number three in the list

811
00:35:17,075 --> 00:35:20,210
that we're about to go through?

812
00:35:20,210 --> 00:35:25,870
Now I'll just give you a second
and ask you a quick question.

813
00:35:25,870 --> 00:35:29,130
You can pause if you want.

814
00:35:29,130 --> 00:35:32,370
How could you improve
this loop using the break?

815
00:35:32,370 --> 00:35:34,900
Where might you put a break
to make this loop smarter?

816
00:35:34,900 --> 00:35:40,810

817
00:35:40,810 --> 00:35:44,340
It's OK if it didn't
jump out at you.

818
00:35:44,340 --> 00:35:48,410
So if you think about
it, once you hit true,

819
00:35:48,410 --> 00:35:51,480
there's really little point in
looking at the rest of them.

820
00:35:51,480 --> 00:35:53,220
There just is no point.

821
00:35:53,220 --> 00:35:59,070
So we could put a break right
here, inside this block.

822
00:35:59,070 --> 00:36:01,220
You say, look, I'm
looking for a three.

823
00:36:01,220 --> 00:36:03,220
All I care is whether
I found it or not.

824
00:36:03,220 --> 00:36:06,150
If I find it, I mark it
to true that I found it,

825
00:36:06,150 --> 00:36:08,450
and I get out of the loop.

826
00:36:08,450 --> 00:36:09,530
Why bother?

827
00:36:09,530 --> 00:36:11,210
Why do all these things?

828
00:36:11,210 --> 00:36:13,070
Just get out.

829
00:36:13,070 --> 00:36:16,110
So don't worry about it,
I'm just pointing that out

830
00:36:16,110 --> 00:36:18,510
that that's one of the places
where break could be used.

831
00:36:18,510 --> 00:36:20,520
The loop functions
either way, it just

832
00:36:20,520 --> 00:36:24,620
looks through all the
rest of them as well.

833
00:36:24,620 --> 00:36:26,210
OK.

834
00:36:26,210 --> 00:36:30,850
So here's this largest
value one I've used before.

835
00:36:30,850 --> 00:36:34,930
And away we go.

836
00:36:34,930 --> 00:36:36,757
We have largest so
far, we check to see

837
00:36:36,757 --> 00:36:38,340
if the one we're
looking at is better.

838
00:36:38,340 --> 00:36:42,010
And if it is, we keep
it, and then away we go.

839
00:36:42,010 --> 00:36:44,840
And then we find
the largest is 17.

840
00:36:44,840 --> 00:36:50,870
What if, what would you
have to change in this code

841
00:36:50,870 --> 00:36:53,990
to make this search for the
smallest of all the values?

842
00:36:53,990 --> 00:36:56,920

843
00:36:56,920 --> 00:37:00,580
Point where in the
screen, what would you

844
00:37:00,580 --> 00:37:04,548
have to change to make
this look for the smallest

845
00:37:04,548 --> 00:37:05,464
in the list of values?

846
00:37:05,464 --> 00:37:09,500

847
00:37:09,500 --> 00:37:11,910
What's making this
about being largest?

848
00:37:11,910 --> 00:37:13,950
What would you have to change?

849
00:37:13,950 --> 00:37:16,270
OK.

850
00:37:16,270 --> 00:37:17,060
Pause if you like.

851
00:37:17,060 --> 00:37:19,840

852
00:37:19,840 --> 00:37:22,170
So here is some things
that you might do

853
00:37:22,170 --> 00:37:24,220
to make it work about smallest.

854
00:37:24,220 --> 00:37:25,850
So hey, one thing
we would do, let's

855
00:37:25,850 --> 00:37:27,670
change the name of the variable.

856
00:37:27,670 --> 00:37:29,670
We had a variable
named largest so far,

857
00:37:29,670 --> 00:37:33,702
and now we'll change it to
be called smallest so far.

858
00:37:33,702 --> 00:37:35,910
Changing the variable name
doesn't change the program

859
00:37:35,910 --> 00:37:36,760
at all.

860
00:37:36,760 --> 00:37:40,230
But it makes the program easier
to read if the program works.

861
00:37:40,230 --> 00:37:42,180
So it's like smallest so far.

862
00:37:42,180 --> 00:37:44,470
But that didn't make
it about being small.

863
00:37:44,470 --> 00:37:47,330
The thing that made
about being small

864
00:37:47,330 --> 00:37:51,260
is change this greater
than to a less than.

865
00:37:51,260 --> 00:37:53,300
Because we're
thinking when we're

866
00:37:53,300 --> 00:37:55,730
doing largest so far, if
the number we're looking at

867
00:37:55,730 --> 00:37:59,020
is bigger than largest
so far, we keep it.

868
00:37:59,020 --> 00:38:00,899
If the number looking
at in the smallest

869
00:38:00,899 --> 00:38:03,440
is smaller than the smallest so
far, then we want to keep it.

870
00:38:03,440 --> 00:38:06,330
So this is like keep.

871
00:38:06,330 --> 00:38:08,420
This line here is
the keeping line.

872
00:38:08,420 --> 00:38:10,460
And this is the when
line, when to keep.

873
00:38:10,460 --> 00:38:13,830

874
00:38:13,830 --> 00:38:17,740
We'll keep it if it's smaller.

875
00:38:17,740 --> 00:38:18,910
So that's the key.

876
00:38:18,910 --> 00:38:22,400
And so, yeah, so I name it
smallest so far, whoopdy doo.

877
00:38:22,400 --> 00:38:23,720
That's good.

878
00:38:23,720 --> 00:38:26,662
But the real thing that had this
being about largeness smallness

879
00:38:26,662 --> 00:38:28,620
was whether this is less
than and greater than,

880
00:38:28,620 --> 00:38:30,840
and this was the
repeated code that got

881
00:38:30,840 --> 00:38:33,840
rechecked over and over again.

882
00:38:33,840 --> 00:38:36,850
But this still has a bug in it.

883
00:38:36,850 --> 00:38:39,100
So let's run this visually.

884
00:38:39,100 --> 00:38:42,310

885
00:38:42,310 --> 00:38:45,890
So now we've got a variable
called smallest so far.

886
00:38:45,890 --> 00:38:48,140
We are going to check to
see if a series of numbers

887
00:38:48,140 --> 00:38:50,570
that I'm about to show you
are smaller than the smallest

888
00:38:50,570 --> 00:38:53,120
so far.

889
00:38:53,120 --> 00:38:55,920
So the first number is 9.

890
00:38:55,920 --> 00:38:59,240
Is that's smaller
than negative 1?

891
00:38:59,240 --> 00:39:00,350
No, it's not.

892
00:39:00,350 --> 00:39:01,770
Negative one is smaller.

893
00:39:01,770 --> 00:39:03,870
The second number is 41.

894
00:39:03,870 --> 00:39:06,120
Is that smaller than negative 1?

895
00:39:06,120 --> 00:39:07,870
No, it is not.

896
00:39:07,870 --> 00:39:08,910
The next number's 12.

897
00:39:08,910 --> 00:39:10,686
Is that smaller than negative 1?

898
00:39:10,686 --> 00:39:11,660
No.

899
00:39:11,660 --> 00:39:14,130
Negative 1 is smaller than 12.

900
00:39:14,130 --> 00:39:15,000
Three?

901
00:39:15,000 --> 00:39:17,450
No, not smaller.

902
00:39:17,450 --> 00:39:19,024
74?

903
00:39:19,024 --> 00:39:20,850
No, not smaller.

904
00:39:20,850 --> 00:39:22,360
15?

905
00:39:22,360 --> 00:39:24,510
Not smaller.

906
00:39:24,510 --> 00:39:27,670
So we're all done, yay,
and the smallest number

907
00:39:27,670 --> 00:39:33,540
we saw in the list
is negative one?

908
00:39:33,540 --> 00:39:35,710
Negative one wasn't
even in the list.

909
00:39:35,710 --> 00:39:37,876
So that's not a
very good program.

910
00:39:37,876 --> 00:39:41,860

911
00:39:41,860 --> 00:39:44,860
So let's take a look at what
went wrong with this program.

912
00:39:44,860 --> 00:39:48,240
So we fixed it, we fixed
it as best we could.

913
00:39:48,240 --> 00:39:50,190
We made it, we changed
the words largest

914
00:39:50,190 --> 00:39:52,056
to smallest, yay, that'll fix.

915
00:39:52,056 --> 00:39:53,930
Just makes it more
readable, doesn't actually

916
00:39:53,930 --> 00:39:54,930
change the program.

917
00:39:54,930 --> 00:39:56,490
And we made this less than.

918
00:39:56,490 --> 00:39:58,530
So now what happens
is it comes in,

919
00:39:58,530 --> 00:40:01,770
if 3 is less than negative 1,
smallest so far, of course,

920
00:40:01,770 --> 00:40:03,525
is negative one.

921
00:40:03,525 --> 00:40:05,520
This just never runs.

922
00:40:05,520 --> 00:40:06,500
This never runs.

923
00:40:06,500 --> 00:40:10,610
And so as we print, smallest
so far stays negative 1.

924
00:40:10,610 --> 00:40:16,340
And oops, that should be
negative one right there.

925
00:40:16,340 --> 00:40:18,450
Sorry, forgot to fix that.

926
00:40:18,450 --> 00:40:20,670
Here, let me magically fix that.

927
00:40:20,670 --> 00:40:23,620

928
00:40:23,620 --> 00:40:27,320
So let's take a look at
what went wrong with this.

929
00:40:27,320 --> 00:40:28,510
So here we have the code.

930
00:40:28,510 --> 00:40:29,843
Smallest so far as negative one.

931
00:40:29,843 --> 00:40:31,740
We have it fixed so
that we're looking

932
00:40:31,740 --> 00:40:34,090
for smaller numbers
rather than larger numbers

933
00:40:34,090 --> 00:40:36,050
by turning this to less than.

934
00:40:36,050 --> 00:40:40,890
But the first time through,
smallest so far is negative 1,

935
00:40:40,890 --> 00:40:42,990
and the_num is three.

936
00:40:42,990 --> 00:40:47,140
Three is not less than
negative 1, so we skip through.

937
00:40:47,140 --> 00:40:50,470
And the printout of the first
line is negative one, three.

938
00:40:50,470 --> 00:40:53,380
And doesn't take long to
realize that it's just

939
00:40:53,380 --> 00:40:54,610
going to keep doing this.

940
00:40:54,610 --> 00:40:57,720
Smallest so far is going to
stay negative one no matter

941
00:40:57,720 --> 00:40:59,570
what we look at on this side.

942
00:40:59,570 --> 00:41:02,240
And then we're going
to come out the end,

943
00:41:02,240 --> 00:41:05,876
and we end up with
negative one as the answer.

944
00:41:05,876 --> 00:41:07,138
Not very good.

945
00:41:07,138 --> 00:41:09,890

946
00:41:09,890 --> 00:41:17,140
So the question is what
should we make this value be?

947
00:41:17,140 --> 00:41:19,694
Negative one, it barely
worked in the largest,

948
00:41:19,694 --> 00:41:21,610
because we were working
with positive numbers.

949
00:41:21,610 --> 00:41:22,984
And so starting
with negative one

950
00:41:22,984 --> 00:41:25,655
as the largest so far was a
reasonable assumption, as long

951
00:41:25,655 --> 00:41:27,030
as the numbers
were all positive.

952
00:41:27,030 --> 00:41:29,700

953
00:41:29,700 --> 00:41:32,946
What would be the
number to choose here?

954
00:41:32,946 --> 00:41:34,070
Think about that for a sec.

955
00:41:34,070 --> 00:41:35,610
Pause if you have to.

956
00:41:35,610 --> 00:41:37,510
Let me clear it.

957
00:41:37,510 --> 00:41:40,570
Let me make it real clear.

958
00:41:40,570 --> 00:41:42,430
What's the right
thing to put here?

959
00:41:42,430 --> 00:41:46,530

960
00:41:46,530 --> 00:41:49,300
So what, a million?

961
00:41:49,300 --> 00:41:52,910

962
00:41:52,910 --> 00:41:55,450
That might work.

963
00:41:55,450 --> 00:41:56,820
Million might work.

964
00:41:56,820 --> 00:42:05,890
But what if all these numbers
were larger than a million?

965
00:42:05,890 --> 00:42:07,110
Then that wouldn't work.

966
00:42:07,110 --> 00:42:10,430
So the problem is,
there's no real good value

967
00:42:10,430 --> 00:42:13,270
unless you could make
this be somehow infinity.

968
00:42:13,270 --> 00:42:15,950

969
00:42:15,950 --> 00:42:18,340
You could make this be infinity.

970
00:42:18,340 --> 00:42:22,050
But there's a way to
do this in Python,

971
00:42:22,050 --> 00:42:24,050
and it's a really kind
of cool technique.

972
00:42:24,050 --> 00:42:26,640
It's a way we signal ourselves.

973
00:42:26,640 --> 00:42:29,570
And that is, we're going
to use a special value.

974
00:42:29,570 --> 00:42:31,530
Not negative 1,
it's not a number.

975
00:42:31,530 --> 00:42:35,890
And the special value
we're going to use is none.

976
00:42:35,890 --> 00:42:37,550
It's a different type.

977
00:42:37,550 --> 00:42:41,139
It's not a number, it's
itself its own type.

978
00:42:41,139 --> 00:42:43,680
So we're going to do is we're
going to mark smallest as none.

979
00:42:43,680 --> 00:42:48,220
And at a high level, what
we're really saying is

980
00:42:48,220 --> 00:42:50,010
we haven't seen anything so far.

981
00:42:50,010 --> 00:42:52,950
The smallest we've
seen so far is none.

982
00:42:52,950 --> 00:42:55,140
We've not seen anything so far.

983
00:42:55,140 --> 00:42:57,856
Now we have to change our
little if inside the loop,

984
00:42:57,856 --> 00:43:00,410
this is this intelligence
in the middle.

985
00:43:00,410 --> 00:43:04,450
First, we say, if smallest
is none, is is an operator.

986
00:43:04,450 --> 00:43:06,300
Part of the Python language.

987
00:43:06,300 --> 00:43:10,200
If smallest is none,
exactly the same as none,

988
00:43:10,200 --> 00:43:12,477
then the smallest we've
seen so far is the value.

989
00:43:12,477 --> 00:43:14,310
Now, this is going to
happen the first time.

990
00:43:14,310 --> 00:43:17,320

991
00:43:17,320 --> 00:43:18,987
Because smallest
starts out none.

992
00:43:18,987 --> 00:43:21,070
And then as soon as we
said smallest to the value,

993
00:43:21,070 --> 00:43:22,528
it's going to be
that first number,

994
00:43:22,528 --> 00:43:24,010
so it's going to be nine.

995
00:43:24,010 --> 00:43:27,110
So smallest is quickly
going to become nine.

996
00:43:27,110 --> 00:43:30,740
Then we print out
the smallest is nine

997
00:43:30,740 --> 00:43:33,010
after we've seen the nine.

998
00:43:33,010 --> 00:43:37,050
Then we go up to the top and
we say, is smallest none?

999
00:43:37,050 --> 00:43:41,320
And the answer is, no it's not,
because smallest is now nine.

1000
00:43:41,320 --> 00:43:43,200
Then this else if
is going to ask,

1001
00:43:43,200 --> 00:43:46,090
is the value we're
looking at, which is 41,

1002
00:43:46,090 --> 00:43:47,680
is the value less than smallest?

1003
00:43:47,680 --> 00:43:50,410
Well, no it is not.

1004
00:43:50,410 --> 00:43:52,530
Nine is smaller than 41.

1005
00:43:52,530 --> 00:43:57,170
And so in a sense, after the
first time this statement

1006
00:43:57,170 --> 00:43:59,890
is executed, this is going
to always be false, right?

1007
00:43:59,890 --> 00:44:01,860
Because smallest
is no longer none.

1008
00:44:01,860 --> 00:44:04,820
And this is going to be the
thing that really is operating.

1009
00:44:04,820 --> 00:44:06,240
And then it's going to work.

1010
00:44:06,240 --> 00:44:10,930
And smallest will become 9, the
smallest so far is 9, but then

1011
00:44:10,930 --> 00:44:12,860
we see the 3 finally.

1012
00:44:12,860 --> 00:44:16,890
And the value 3 is less than
9, and so then we take 3,

1013
00:44:16,890 --> 00:44:18,680
and you stick it into smallest.

1014
00:44:18,680 --> 00:44:20,260
And we end up with this.

1015
00:44:20,260 --> 00:44:23,824
And then the loop runs some more
times, and when we're all done

1016
00:44:23,824 --> 00:44:25,510
we have 3.

1017
00:44:25,510 --> 00:44:29,280
So the trick here is
we put this none in,

1018
00:44:29,280 --> 00:44:31,180
and we have a
little more if code

1019
00:44:31,180 --> 00:44:34,342
to check to see if we
haven't seen anything so far.

1020
00:44:34,342 --> 00:44:36,050
You can think of this
as a way to trigger

1021
00:44:36,050 --> 00:44:38,585
on the first iteration.

1022
00:44:38,585 --> 00:44:41,320

1023
00:44:41,320 --> 00:44:43,486
Special code that's
really going to-- it

1024
00:44:43,486 --> 00:44:45,360
looks at it on each
iteration, but it's never

1025
00:44:45,360 --> 00:44:48,260
true after the first iteration.

1026
00:44:48,260 --> 00:44:49,410
So that's just a technique.

1027
00:44:49,410 --> 00:44:52,260

1028
00:44:52,260 --> 00:44:54,030
So this is an is not operator.

1029
00:44:54,030 --> 00:44:56,490
I think it's a
real elegant thing.

1030
00:44:56,490 --> 00:44:59,975
Don't start overusing it.

1031
00:44:59,975 --> 00:45:04,030
At a low level, its real
meaning is exactly the same

1032
00:45:04,030 --> 00:45:07,570
as in type and value.

1033
00:45:07,570 --> 00:45:10,510
There's a is, and
there's an is not.

1034
00:45:10,510 --> 00:45:15,530
But don't do things like
saying, if i equal-- oops.

1035
00:45:15,530 --> 00:45:18,340

1036
00:45:18,340 --> 00:45:20,090
Won't even let myself
type the bad code.

1037
00:45:20,090 --> 00:45:25,050
If i is 4, don't say that.

1038
00:45:25,050 --> 00:45:25,740
Don't say that.

1039
00:45:25,740 --> 00:45:27,740
Don't do if i is 4.

1040
00:45:27,740 --> 00:45:30,490

1041
00:45:30,490 --> 00:45:32,260
It may work in
certain situations,

1042
00:45:32,260 --> 00:45:34,510
it's really best used in
very limited situations

1043
00:45:34,510 --> 00:45:36,760
where you're checking for
some of these special values

1044
00:45:36,760 --> 00:45:39,035
like none, and false.

1045
00:45:39,035 --> 00:45:41,590

1046
00:45:41,590 --> 00:45:44,970
The problem is if you
use equality here,

1047
00:45:44,970 --> 00:45:49,090
it tries to convert
values, and it may end up

1048
00:45:49,090 --> 00:45:51,010
giving you a false yes.

1049
00:45:51,010 --> 00:45:56,180
And so is is a stronger
equality than simple equals.

1050
00:45:56,180 --> 00:46:00,470
Equals is same
numeric value, where

1051
00:46:00,470 --> 00:46:02,680
is is exactly the same thing.

1052
00:46:02,680 --> 00:46:04,740
But don't overuse is.

1053
00:46:04,740 --> 00:46:07,590
Use double equals
95% of the time,

1054
00:46:07,590 --> 00:46:10,220
and use is when you're
checking if it's

1055
00:46:10,220 --> 00:46:13,880
one of these special
constants like true or false.

1056
00:46:13,880 --> 00:46:16,570
OK?

1057
00:46:16,570 --> 00:46:18,616
So this is iterations.

1058
00:46:18,616 --> 00:46:20,865
I mean, our loops are going
to get more sophisticated,

1059
00:46:20,865 --> 00:46:22,780
and we have more
interesting things to do.

1060
00:46:22,780 --> 00:46:25,860
But we talked about
some indefinite loops,

1061
00:46:25,860 --> 00:46:28,300
definite loops,
iteration variables.

1062
00:46:28,300 --> 00:46:32,910
Some patterns like maximum,
minimum, summing, averaging.

1063
00:46:32,910 --> 00:46:35,640
We introduced the
concept of none.

1064
00:46:35,640 --> 00:46:38,349
And so this is,
we're getting there.

1065
00:46:38,349 --> 00:46:40,640
We've got a couple more
chapters before we really start

1066
00:46:40,640 --> 00:46:41,930
hitting the data analysis.

1067
00:46:41,930 --> 00:46:44,680
So see you in the next lecture.
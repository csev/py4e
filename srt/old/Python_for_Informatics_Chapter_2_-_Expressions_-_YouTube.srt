1
00:00:00,000 --> 00:00:00,370

2
00:00:00,370 --> 00:00:00,870
Hello.

3
00:00:00,870 --> 00:00:02,670
And welcome to chapter two.

4
00:00:02,670 --> 00:00:04,560
Hope you enjoyed chapter one.

5
00:00:04,560 --> 00:00:06,850
It was the one longer
lectures, trying

6
00:00:06,850 --> 00:00:08,930
to motivate you a little bit.

7
00:00:08,930 --> 00:00:12,150
And now we're going to kind
of go back to the basics.

8
00:00:12,150 --> 00:00:14,350
Chapter one covered sort
of the first four or five

9
00:00:14,350 --> 00:00:15,850
chapters of the book.

10
00:00:15,850 --> 00:00:19,940
So as always, this
video, the slides

11
00:00:19,940 --> 00:00:23,145
are copyright Creative
Commons Attribution as well as

12
00:00:23,145 --> 00:00:24,770
the audio.

13
00:00:24,770 --> 00:00:27,690
And so now we're going
to talk about sort

14
00:00:27,690 --> 00:00:29,700
of the really low
level things that

15
00:00:29,700 --> 00:00:33,700
make up the Python language.

16
00:00:33,700 --> 00:00:36,090
Constants-- some of
this is terminology

17
00:00:36,090 --> 00:00:38,650
just so I can say
the word constant

18
00:00:38,650 --> 00:00:40,660
and you won't freak out.

19
00:00:40,660 --> 00:00:43,860
Constant is as
contrasted with something

20
00:00:43,860 --> 00:00:45,300
that changes, is variable.

21
00:00:45,300 --> 00:00:47,310
We'll talk about variables
in the next slide.

22
00:00:47,310 --> 00:00:48,850
But for now, constants.

23
00:00:48,850 --> 00:00:51,520
Constants are
things that are sort

24
00:00:51,520 --> 00:00:57,430
of natural and instinctive,
things like numbers, 123, 98.6,

25
00:00:57,430 --> 00:00:59,170
or hello world.

26
00:00:59,170 --> 00:01:02,322
And so what I'm
doing here is we're

27
00:01:02,322 --> 00:01:03,530
using the Python interpreter.

28
00:01:03,530 --> 00:01:06,180
And that's how you can
tell the Chevron prompt.

29
00:01:06,180 --> 00:01:08,110
And I'm saying print 123.

30
00:01:08,110 --> 00:01:10,480
And then Python
responds with 123.

31
00:01:10,480 --> 00:01:16,440
Print 98.6, Python responds with
98.6 and print 'hello world.'

32
00:01:16,440 --> 00:01:19,500
So the constants
are the 123, 98.6,

33
00:01:19,500 --> 00:01:22,780
and 'hello world.'
So these are things,

34
00:01:22,780 --> 00:01:25,820
we can use either single
quotes or double quotes to make

35
00:01:25,820 --> 00:01:26,910
strings.

36
00:01:26,910 --> 00:01:29,629
And so programs kind of
work with numbers and work

37
00:01:29,629 --> 00:01:30,170
with strings.

38
00:01:30,170 --> 00:01:34,370
And we have these non-varying
values that we call constants.

39
00:01:34,370 --> 00:01:39,930
So the other side of the
picture is the variable.

40
00:01:39,930 --> 00:01:42,100
And the way I like to
characterize a variable

41
00:01:42,100 --> 00:01:46,100
is it's a place in the
memory of the computer.

42
00:01:46,100 --> 00:01:47,580
We give it a name
as a programmer.

43
00:01:47,580 --> 00:01:49,530
We pick the variable name.

44
00:01:49,530 --> 00:01:55,270
In this, I'm saying x
equals 12.2 and y equals 14.

45
00:01:55,270 --> 00:01:56,870
I am choosing the name.

46
00:01:56,870 --> 00:01:59,540
And I'm choosing
what to put in there.

47
00:01:59,540 --> 00:02:03,330
This is a statement called
an assignment statement.

48
00:02:03,330 --> 00:02:05,430
And the way to think of
the assignment statement

49
00:02:05,430 --> 00:02:08,360
is that it sort of
has a direction.

50
00:02:08,360 --> 00:02:12,010
We're saying, dear Python,
go find some memory.

51
00:02:12,010 --> 00:02:16,260
I will use the label x later
to refer to that memory.

52
00:02:16,260 --> 00:02:20,430
And take the number 12.2
and stick it into x.

53
00:02:20,430 --> 00:02:21,450
This is sequential code.

54
00:02:21,450 --> 00:02:22,950
Then the next thing
I want you to do

55
00:02:22,950 --> 00:02:26,080
is I'd like you to go find
some more memory, call it y.

56
00:02:26,080 --> 00:02:30,780
I will call it y later,
and stick 14 in there.

57
00:02:30,780 --> 00:02:34,310
And so that ends up sort
of with two little areas

58
00:02:34,310 --> 00:02:38,690
of memory, one labeled x.

59
00:02:38,690 --> 00:02:40,080
And here's a little
cell in which

60
00:02:40,080 --> 00:02:41,940
we'd like a draw or something.

61
00:02:41,940 --> 00:02:44,360
And one labeled y,
and we put 12.2.

62
00:02:44,360 --> 00:02:47,880
After these lines run, we
have 12.2 in one and 14

63
00:02:47,880 --> 00:02:49,570
in the other.

64
00:02:49,570 --> 00:02:54,020
Then for example, if there's
another line that's down here,

65
00:02:54,020 --> 00:02:56,920
so there's this third line
after this has happened,

66
00:02:56,920 --> 00:02:59,070
after this has
happened, x equals 100.

67
00:02:59,070 --> 00:03:02,320
Remember, this has kind
of got a direction to it.

68
00:03:02,320 --> 00:03:04,800
Oh, remember that x that I had?

69
00:03:04,800 --> 00:03:07,490
I would like now
to put 100 in that.

70
00:03:07,490 --> 00:03:08,920
So as I'm thinking
this through, I

71
00:03:08,920 --> 00:03:10,370
think of that as
sort of removing

72
00:03:10,370 --> 00:03:14,980
the 12.2 or overriding the 12.2
and putting 100 in its place.

73
00:03:14,980 --> 00:03:18,920
And so at the end here,
x is left with 100.

74
00:03:18,920 --> 00:03:21,820
And y is left with 14.

75
00:03:21,820 --> 00:03:24,380
So these variables can kind
of have one value in them.

76
00:03:24,380 --> 00:03:26,910
And we can look at them, and
we can reuse them and put

77
00:03:26,910 --> 00:03:30,900
different values in if we want.

78
00:03:30,900 --> 00:03:33,870
There's some rules for
naming your variables.

79
00:03:33,870 --> 00:03:37,350
Again, you get to pick
the variable names.

80
00:03:37,350 --> 00:03:39,550
Often, we pick variables
that makes some sense.

81
00:03:39,550 --> 00:03:41,580
We'll talk about
that in a second.

82
00:03:41,580 --> 00:03:44,910
In Python, variables can
start with an underscore.

83
00:03:44,910 --> 00:03:48,090
We tend not to, as normal
programmers, use those.

84
00:03:48,090 --> 00:03:52,330
We let libraries use those.

85
00:03:52,330 --> 00:03:57,370
It has to have letters, numbers,
and underscores and start

86
00:03:57,370 --> 00:04:00,010
with a letter or an underscore.

87
00:04:00,010 --> 00:04:06,000
Case matters, so spam
is good. eggs is good.

88
00:04:06,000 --> 00:04:08,340
spam23 is good, because
the number is not

89
00:04:08,340 --> 00:04:09,590
the first character.

90
00:04:09,590 --> 00:04:11,880
_speed, that's also
perfectly fine,

91
00:04:11,880 --> 00:04:15,830
because it starts with an
underscore or a letter.

92
00:04:15,830 --> 00:04:20,839
23spam starts with a
number, so that's bad.

93
00:04:20,839 --> 00:04:24,360
This starts with something other
than a letter or an underscore.

94
00:04:24,360 --> 00:04:27,520
And you can't use a dot
in the variable name.

95
00:04:27,520 --> 00:04:30,280
It turns out the dot
has meaning to Python

96
00:04:30,280 --> 00:04:31,540
that would confuse it.

97
00:04:31,540 --> 00:04:35,180

98
00:04:35,180 --> 00:04:37,940
And it wouldn't understand
what we really mean there.

99
00:04:37,940 --> 00:04:41,060
So that would be a syntax error.

100
00:04:41,060 --> 00:04:44,090
Because case is
sensitive, that means

101
00:04:44,090 --> 00:04:46,260
that things like
all lowercase spam

102
00:04:46,260 --> 00:04:49,730
is different than a uppercase
S and all uppercase.

103
00:04:49,730 --> 00:04:55,120
These are three distinct
variables that are unique.

104
00:04:55,120 --> 00:04:57,080
Most people don't
choose variables

105
00:04:57,080 --> 00:04:58,560
that might be so confusing.

106
00:04:58,560 --> 00:05:01,740
So to you as you write
it, and as to anybody

107
00:05:01,740 --> 00:05:04,530
that might read it, would
find three variables

108
00:05:04,530 --> 00:05:06,400
named as very confusing.

109
00:05:06,400 --> 00:05:08,100
So it's a bad idea.

110
00:05:08,100 --> 00:05:08,990
Don't do it.

111
00:05:08,990 --> 00:05:10,930
But I'm just showing
you as an example

112
00:05:10,930 --> 00:05:14,940
that case can make a
variable name distinct.

113
00:05:14,940 --> 00:05:18,190
And again, this variable
is a place in memory

114
00:05:18,190 --> 00:05:22,530
that we are going to store
and retrieve information,

115
00:05:22,530 --> 00:05:24,730
whether it be numbers
or strings or whatever.

116
00:05:24,730 --> 00:05:27,030
These are things
that we control.

117
00:05:27,030 --> 00:05:29,990
Now Python also has a
set of reserved words.

118
00:05:29,990 --> 00:05:33,070
And what it really means is you
can't use these for variables.

119
00:05:33,070 --> 00:05:36,020
These words have
very special meaning,

120
00:05:36,020 --> 00:05:40,530
and, four, is, raise, if.

121
00:05:40,530 --> 00:05:42,280
So you can't make
a variable name if.

122
00:05:42,280 --> 00:05:43,620
It'll be like, oh, no.

123
00:05:43,620 --> 00:05:44,741
That is if.

124
00:05:44,741 --> 00:05:45,490
I know what if is.

125
00:05:45,490 --> 00:05:49,300
So these are words that Python
has as its core vocabulary

126
00:05:49,300 --> 00:05:52,620
and forbids you to use
them for other purposes,

127
00:05:52,620 --> 00:05:55,600
like variable names or
later function names.

128
00:05:55,600 --> 00:05:58,870
So that's kind of the
vocabulary, constants,

129
00:05:58,870 --> 00:06:03,000
variables, and reserved words.

130
00:06:03,000 --> 00:06:06,020
Now, we take these and
we start assembling them

131
00:06:06,020 --> 00:06:09,060
into sort of sentences,
statements, Python statements

132
00:06:09,060 --> 00:06:10,590
that do something.

133
00:06:10,590 --> 00:06:13,250
So we've already talked about
an assignment statement.

134
00:06:13,250 --> 00:06:15,210
It has kind of an arrow here.

135
00:06:15,210 --> 00:06:18,230
It says, hey, Python, go
find me a place called x.

136
00:06:18,230 --> 00:06:21,370
Take the number 2 and stick
it in there for later,

137
00:06:21,370 --> 00:06:22,740
then continue on.

138
00:06:22,740 --> 00:06:25,570
Now because there's an
arrow, the right side of this

139
00:06:25,570 --> 00:06:26,980
is done first.

140
00:06:26,980 --> 00:06:32,159
And you can kind of ignore for
the moment the left-hand side.

141
00:06:32,159 --> 00:06:33,700
And it calculates
the right-hand side

142
00:06:33,700 --> 00:06:37,560
by looking at the current value
for x, which happens to be 2.

143
00:06:37,560 --> 00:06:40,590
And it adds these two things
together, and then gets 4.

144
00:06:40,590 --> 00:06:46,290
And then at the point where it
knows that this number is 4,

145
00:06:46,290 --> 00:06:48,720
it will then store
that back into x.

146
00:06:48,720 --> 00:06:52,910
And so then later we print
x, and we will get the 4.

147
00:06:52,910 --> 00:06:55,410
And so again, this is
a sequence of steps.

148
00:06:55,410 --> 00:06:59,669
And the variable x changes
as these steps continue.

149
00:06:59,669 --> 00:07:01,460
And we're saying print
x, that really means

150
00:07:01,460 --> 00:07:03,680
print the current value for x.

151
00:07:03,680 --> 00:07:07,660

152
00:07:07,660 --> 00:07:11,140
So we can do a number
of different operators

153
00:07:11,140 --> 00:07:12,610
and assignment statements.

154
00:07:12,610 --> 00:07:15,970
We calculate this
right-hand side.

155
00:07:15,970 --> 00:07:18,860
This is sort of all
calculated, whatever this is,

156
00:07:18,860 --> 00:07:20,560
based on the
current value for x.

157
00:07:20,560 --> 00:07:21,860
It does this calculation.

158
00:07:21,860 --> 00:07:24,230
And then when it knows
what the answer is,

159
00:07:24,230 --> 00:07:26,340
it assigns that
into the variable

160
00:07:26,340 --> 00:07:30,840
that's on the left-hand side
of the assignment statement.

161
00:07:30,840 --> 00:07:34,627
Again, calculate the right-hand
side completely, and then move

162
00:07:34,627 --> 00:07:35,800
it to the left-hand side.

163
00:07:35,800 --> 00:07:39,630
Some early languages actually
didn't use the equal sign

164
00:07:39,630 --> 00:07:41,290
for the assignment operator.

165
00:07:41,290 --> 00:07:43,720
This assignment
operator, in a way,

166
00:07:43,720 --> 00:07:49,380
it kind of-- some languages,
an early language, actually

167
00:07:49,380 --> 00:07:50,760
used an arrow.

168
00:07:50,760 --> 00:07:53,610
Arrows aren't really
on people's keyboards.

169
00:07:53,610 --> 00:07:56,810
Another language used colon
equals as this assignment

170
00:07:56,810 --> 00:07:57,310
operator.

171
00:07:57,310 --> 00:07:58,890
But we use equals.

172
00:07:58,890 --> 00:08:00,340
Now if you're
familiar with math,

173
00:08:00,340 --> 00:08:05,930
this can be a little confusing,
like x = 1, and then x = 2.

174
00:08:05,930 --> 00:08:07,880
That, as mathematics,
would be bad math.

175
00:08:07,880 --> 00:08:11,710
Because in a proof or a problem,
x can only have one value.

176
00:08:11,710 --> 00:08:14,300
But in programming, if
this was two statements,

177
00:08:14,300 --> 00:08:16,710
that means just x had
value, and then the value

178
00:08:16,710 --> 00:08:19,430
for x changed later.

179
00:08:19,430 --> 00:08:20,580
OK.

180
00:08:20,580 --> 00:08:22,350
So I'll just kind
of go through this.

181
00:08:22,350 --> 00:08:24,720
Because it's working
from the right-hand side

182
00:08:24,720 --> 00:08:27,090
to the left-hand side on
assignment statements,

183
00:08:27,090 --> 00:08:29,700
it is pulling out
these x values.

184
00:08:29,700 --> 00:08:31,750
So x may have 0.6.

185
00:08:31,750 --> 00:08:34,440
It pulls the values
out before sort

186
00:08:34,440 --> 00:08:36,250
of ignoring this
part right here.

187
00:08:36,250 --> 00:08:39,250
And it's just going to try
to resolve this expression.

188
00:08:39,250 --> 00:08:41,690
And it has multiplication
and parentheses and things

189
00:08:41,690 --> 00:08:42,520
like that.

190
00:08:42,520 --> 00:08:46,500
So it basically pulls the
0.6 into the calculation,

191
00:08:46,500 --> 00:08:48,030
does over 1 minus
x, which gives you

192
00:08:48,030 --> 00:08:51,860
0.4, then it multiplies
these three things together,

193
00:08:51,860 --> 00:08:53,540
giving 0.93.

194
00:08:53,540 --> 00:08:58,490
And then what it is all
done with all of that,

195
00:08:58,490 --> 00:09:03,615
it takes that 0.93, and
then puts it back into x.

196
00:09:03,615 --> 00:09:05,240
And so this is just
sort of emphasizing

197
00:09:05,240 --> 00:09:09,580
how the right-hand side is
computed to produce a value,

198
00:09:09,580 --> 00:09:13,040
then it is moved
into the variable.

199
00:09:13,040 --> 00:09:15,990
And that is why you can
have x on both sides.

200
00:09:15,990 --> 00:09:20,690
Because this is like the
old, and this is the new.

201
00:09:20,690 --> 00:09:23,520
The old x participates
in the calculation.

202
00:09:23,520 --> 00:09:27,445
And then when the calculation
is done, it becomes the new x.

203
00:09:27,445 --> 00:09:29,580
I hope that makes sense.

204
00:09:29,580 --> 00:09:33,070
So this on the right-hand side
here is a numeric expression.

205
00:09:33,070 --> 00:09:35,590
So we have a number of
different operators.

206
00:09:35,590 --> 00:09:39,160
Some of them are instinctive,
intuitive, the plus

207
00:09:39,160 --> 00:09:40,260
and the minus.

208
00:09:40,260 --> 00:09:43,320
The reason some of these are
so weird is in really old days,

209
00:09:43,320 --> 00:09:45,920
we didn't have too many
things on the keyboard.

210
00:09:45,920 --> 00:09:48,054
And a lot of programs
are very mathematical.

211
00:09:48,054 --> 00:09:50,720
And so they figured out what was
on the keyboard of the computer

212
00:09:50,720 --> 00:09:52,710
equipment of the
day, and then they

213
00:09:52,710 --> 00:09:55,080
had to fake certain things.

214
00:09:55,080 --> 00:09:58,710
So it turns out that plus and
minus were on the keyboard.

215
00:09:58,710 --> 00:10:01,500
And so plus and minus are
addition and subtraction

216
00:10:01,500 --> 00:10:02,620
respectively.

217
00:10:02,620 --> 00:10:06,570
There was no kind of times
operator for multiplication.

218
00:10:06,570 --> 00:10:08,460
And dot was used
for decimal point.

219
00:10:08,460 --> 00:10:10,470
So they used asterisks
for multiplication.

220
00:10:10,470 --> 00:10:14,530
So in computers, languages,
nearly all of them,

221
00:10:14,530 --> 00:10:17,770
they basically use a
times for multiplication.

222
00:10:17,770 --> 00:10:19,860
Slash is used for division.

223
00:10:19,860 --> 00:10:24,820
So we say like 8/2,
which is 8 divided by 2.

224
00:10:24,820 --> 00:10:28,700
Raising something to the
power, like 4 squared,

225
00:10:28,700 --> 00:10:32,260
that is double asterisk.

226
00:10:32,260 --> 00:10:38,140
And then remainder is if
you do a division that

227
00:10:38,140 --> 00:10:40,540
gives you the remainder
rather than divisor.

228
00:10:40,540 --> 00:10:44,300
So 8 over 2 is 4, remainder 0.

229
00:10:44,300 --> 00:10:48,006
So the remainder is what you get
with this particular operator.

230
00:10:48,006 --> 00:10:49,380
There's a few cool
things that we

231
00:10:49,380 --> 00:10:52,640
can do with remainder that we
won't talk about right away.

232
00:10:52,640 --> 00:10:54,670
But it's there.

233
00:10:54,670 --> 00:10:59,130
And so here's just a couple
of sample expressions.

234
00:10:59,130 --> 00:11:01,976
I

235
00:11:01,976 --> 00:11:05,000
Let's give me green, OK.

236
00:11:05,000 --> 00:11:06,760
So again, I'm using
a Python interpreter.

237
00:11:06,760 --> 00:11:08,360
So this is just the prompt.

238
00:11:08,360 --> 00:11:10,790
The chevrons are the prompt.

239
00:11:10,790 --> 00:11:13,700
Create the variable
xx, and assign it to 2.

240
00:11:13,700 --> 00:11:16,550
Retrieve the old
value in an addition.

241
00:11:16,550 --> 00:11:20,680
Then print it out and put it
back into xx, so xx has 4.

242
00:11:20,680 --> 00:11:22,630
yy, this is a multiplication.

243
00:11:22,630 --> 00:11:26,250
440 times 12 is 5,280.

244
00:11:26,250 --> 00:11:30,500
yy over 1,000, this is
little counterintuitive.

245
00:11:30,500 --> 00:11:33,350
Because yy is an
integer, it then

246
00:11:33,350 --> 00:11:35,180
does it in a truncated division.

247
00:11:35,180 --> 00:11:41,340
So 5,280 divided by 1,000 is 5.

248
00:11:41,340 --> 00:11:44,230
And so that's an
integer division.

249
00:11:44,230 --> 00:11:48,010
We'll see in a second about
floating point division.

250
00:11:48,010 --> 00:11:51,550
Now we take the variable
jj and we set it to 23.

251
00:11:51,550 --> 00:11:54,980
And now we're going to use
the modulo or remainder

252
00:11:54,980 --> 00:11:59,280
operator to say what
is the remainder when

253
00:11:59,280 --> 00:12:01,694
we divide this jj by 5.

254
00:12:01,694 --> 00:12:03,110
And so if you think
about this, we

255
00:12:03,110 --> 00:12:06,920
take old long division, 23
divided by 5, you end up

256
00:12:06,920 --> 00:12:10,620
with 4, and then remainder 3.

257
00:12:10,620 --> 00:12:13,590
The modulo operator, or the
percent, or the remainder

258
00:12:13,590 --> 00:12:16,110
operator, gives us
back this number.

259
00:12:16,110 --> 00:12:19,420
And so that's why kk is 3.

260
00:12:19,420 --> 00:12:22,630
It is the remainder
of 23 when divided

261
00:12:22,630 --> 00:12:27,140
by 5 or the remainder of
the division of 5 and 23.

262
00:12:27,140 --> 00:12:34,770
And the raising to the
power 4 cubed is 4**3.

263
00:12:34,770 --> 00:12:37,480
And so that end up being 64.

264
00:12:37,480 --> 00:12:39,950
So that's just operations.

265
00:12:39,950 --> 00:12:43,520
Now just like in
algebra and mathematics,

266
00:12:43,520 --> 00:12:49,670
we have rules about which
operations happen first.

267
00:12:49,670 --> 00:12:51,920
In general, things
like the power

268
00:12:51,920 --> 00:12:54,120
happens before the
multiplication and division,

269
00:12:54,120 --> 00:12:56,500
and then the addition
and subtraction happen.

270
00:12:56,500 --> 00:13:00,070
So there are some rules when
you're looking at an expression

271
00:13:00,070 --> 00:13:02,490
and trying to calculate
what its value is.

272
00:13:02,490 --> 00:13:05,930
If you don't have parentheses,
it follows these rules.

273
00:13:05,930 --> 00:13:11,350
And so the rule that sort
of trumps all the rules

274
00:13:11,350 --> 00:13:14,390
is that parentheses
are always respected.

275
00:13:14,390 --> 00:13:18,360
So a lot of us just write these
with parentheses in place, even

276
00:13:18,360 --> 00:13:21,100
sometimes, though,
you don't need it.

277
00:13:21,100 --> 00:13:23,030
Then after parentheses
have been handled,

278
00:13:23,030 --> 00:13:24,950
then it does exponentiation.

279
00:13:24,950 --> 00:13:28,340
Then it does multiplication,
division, and remainder.

280
00:13:28,340 --> 00:13:30,150
And then it does
addition and subtraction.

281
00:13:30,150 --> 00:13:34,110
And then, all else being equal,
it just works left to right.

282
00:13:34,110 --> 00:13:37,930
So let's look
through an example.

283
00:13:37,930 --> 00:13:46,040
So here is a calculation
that is 1 plus 2 times 3

284
00:13:46,040 --> 00:13:47,450
divided by 4 over 5.

285
00:13:47,450 --> 00:13:50,340
And the question is what
order does this happen?

286
00:13:50,340 --> 00:13:51,360
OK.

287
00:13:51,360 --> 00:13:55,170
And so let's sort of
take a look at this.

288
00:13:55,170 --> 00:13:58,510
And so we start with are
there any parentheses?

289
00:13:58,510 --> 00:13:59,540
And the answer is no.

290
00:13:59,540 --> 00:14:00,680
There are no parentheses.

291
00:14:00,680 --> 00:14:03,710
So let's go next.

292
00:14:03,710 --> 00:14:05,080
Power.

293
00:14:05,080 --> 00:14:09,700
And so the power says,
OK, let's look across

294
00:14:09,700 --> 00:14:12,030
and find those things that
are raised to a power.

295
00:14:12,030 --> 00:14:17,350
And the 2 cubed, or 2 the
third power, is the power.

296
00:14:17,350 --> 00:14:20,060
So we're going to do that one.

297
00:14:20,060 --> 00:14:22,030
And then the way
I do it when I'm

298
00:14:22,030 --> 00:14:24,150
sort of doing these
slowly is I rewrite it.

299
00:14:24,150 --> 00:14:25,960
So the 2 to the third
power becomes 8.

300
00:14:25,960 --> 00:14:28,690
So it's 1 plus 8 over 4 times 5.

301
00:14:28,690 --> 00:14:30,190
And then now we can say, power?

302
00:14:30,190 --> 00:14:31,727
That's taken care of.

303
00:14:31,727 --> 00:14:33,810
Now we're going to do
multiplication and division.

304
00:14:33,810 --> 00:14:35,570
And we go across.

305
00:14:35,570 --> 00:14:38,660
Now we have both a division
and a multiplication.

306
00:14:38,660 --> 00:14:41,140
And multiplication and division
are done at the same time.

307
00:14:41,140 --> 00:14:42,750
So that means we
do left to right,

308
00:14:42,750 --> 00:14:45,880
which means we do the first
one that we encounter first.

309
00:14:45,880 --> 00:14:52,580
So that will be 8 over 4,
because of the left to right

310
00:14:52,580 --> 00:14:53,440
rule.

311
00:14:53,440 --> 00:14:54,440
And so we find that one.

312
00:14:54,440 --> 00:14:56,900
And that's the one that
gets computed next.

313
00:14:56,900 --> 00:14:58,490
And that turns into two.

314
00:14:58,490 --> 00:15:00,850
And again, I like to rewrite
these expressions just

315
00:15:00,850 --> 00:15:03,779
to keep my brain
really, really clear.

316
00:15:03,779 --> 00:15:05,570
After a while, you just
do it in your head.

317
00:15:05,570 --> 00:15:06,452
But I rewrite them.

318
00:15:06,452 --> 00:15:08,160
When I was first
learning them, at least,

319
00:15:08,160 --> 00:15:09,250
I rewrote it all the time.

320
00:15:09,250 --> 00:15:13,110

321
00:15:13,110 --> 00:15:15,560
And so next, looking at this,
there's a multiplication.

322
00:15:15,560 --> 00:15:17,220
We're not done with
multiplication yet.

323
00:15:17,220 --> 00:15:21,040
So the 2 over 5
is the next thing.

324
00:15:21,040 --> 00:15:23,580
And then we do that calculation,
and that becomes 10.

325
00:15:23,580 --> 00:15:24,890
And again, we rewrite it.

326
00:15:24,890 --> 00:15:27,020
And now we've done
the multiplication.

327
00:15:27,020 --> 00:15:28,730
And we're going to
do addition next.

328
00:15:28,730 --> 00:15:31,820
And that's just 1 over 10.

329
00:15:31,820 --> 00:15:33,940
And that becomes 11.

330
00:15:33,940 --> 00:15:36,560
And so basically,
this big long thing

331
00:15:36,560 --> 00:15:40,700
through a series of
successive steps becomes 11.

332
00:15:40,700 --> 00:15:43,725
And indeed, when we print
it out, that's what we get.

333
00:15:43,725 --> 00:15:46,840

334
00:15:46,840 --> 00:15:49,820
So there's the rules that
are parentheses, power,

335
00:15:49,820 --> 00:15:52,470
multiplication, addition,
and then left to right.

336
00:15:52,470 --> 00:15:58,750
But smart people usually
just put parentheses in.

337
00:15:58,750 --> 00:16:00,850
So here's an example.

338
00:16:00,850 --> 00:16:01,790
Go back, go back.

339
00:16:01,790 --> 00:16:03,370
Here's an exam question.

340
00:16:03,370 --> 00:16:09,050
Now, I wouldn't write
this code this way.

341
00:16:09,050 --> 00:16:12,330
I would put a parenthese here.

342
00:16:12,330 --> 00:16:14,860
And a parenthese there.

343
00:16:14,860 --> 00:16:16,194
It's the same thing.

344
00:16:16,194 --> 00:16:18,610
Because that's exactly-- the
2 times 3 is going to happen.

345
00:16:18,610 --> 00:16:20,390
And the 4 over 5
is going to happen.

346
00:16:20,390 --> 00:16:23,150
And then the plus and minus
will happen left to right.

347
00:16:23,150 --> 00:16:25,880
But why not make it
easier on your readers

348
00:16:25,880 --> 00:16:27,240
and just put the parentheses in?

349
00:16:27,240 --> 00:16:28,323
Because they're redundant.

350
00:16:28,323 --> 00:16:30,140
They're not necessary.

351
00:16:30,140 --> 00:16:31,520
But away you go.

352
00:16:31,520 --> 00:16:34,082
Now if you don't
want it to happen

353
00:16:34,082 --> 00:16:36,540
in that order, of course, then
you have to put parentheses.

354
00:16:36,540 --> 00:16:39,180
If you want the
addition to happen

355
00:16:39,180 --> 00:16:42,040
before the multiplication, then
you have to put parentheses in,

356
00:16:42,040 --> 00:16:43,180
which you can.

357
00:16:43,180 --> 00:16:47,520
But we tend to recommended that
you use more parentheses rather

358
00:16:47,520 --> 00:16:49,810
than less parentheses.

359
00:16:49,810 --> 00:16:53,610
Now Python integer
division in Python 2,

360
00:16:53,610 --> 00:16:56,130
which we are using
Python 2 for this class--

361
00:16:56,130 --> 00:16:59,400
there's a new Python 3
that the world is slowly

362
00:16:59,400 --> 00:17:00,490
transitioning to.

363
00:17:00,490 --> 00:17:03,600
And a lot of people are
using it and teaching,

364
00:17:03,600 --> 00:17:06,630
but it's not as common
sort of in the real world

365
00:17:06,630 --> 00:17:08,349
with libraries and utilities.

366
00:17:08,349 --> 00:17:11,099
And so we'll stick with
Python 2 for a few more years

367
00:17:11,099 --> 00:17:14,876
until Python 3 really
kind of turns the corner.

368
00:17:14,876 --> 00:17:16,000
It's nice to have it there.

369
00:17:16,000 --> 00:17:17,420
But there's so much Python.

370
00:17:17,420 --> 00:17:20,690
And it's so popular,
Python 2, that it's just

371
00:17:20,690 --> 00:17:23,260
kind of hard to get
everybody up to Python 3.

372
00:17:23,260 --> 00:17:26,184
So in Python 2, integer
division truncates.

373
00:17:26,184 --> 00:17:31,376
And you saw that before,
where I did the 5,280 by 1,000

374
00:17:31,376 --> 00:17:33,769
and I got 5.

375
00:17:33,769 --> 00:17:36,310
But we can look at a couple of
examples that make this really

376
00:17:36,310 --> 00:17:37,990
very quite clear.

377
00:17:37,990 --> 00:17:41,060
So 10 divided by 2 is
5, as you would expect.

378
00:17:41,060 --> 00:17:44,650
9 divided by 2 is 4, not
exactly what you'd expect.

379
00:17:44,650 --> 00:17:49,470
You kind of expect that
to be 4.5 instead of four.

380
00:17:49,470 --> 00:17:51,860
But in Python 3, it will be 4.5.

381
00:17:51,860 --> 00:17:56,710
But for now, in Python
2, 9 over 2 is 4.

382
00:17:56,710 --> 00:18:00,940
And 99 over 100 is 0.

383
00:18:00,940 --> 00:18:02,590
Now that seems rather
counterintuitive.

384
00:18:02,590 --> 00:18:04,040
But it is a truncating division.

385
00:18:04,040 --> 00:18:05,680
It's not a rounding division.

386
00:18:05,680 --> 00:18:07,150
It is a truncated division.

387
00:18:07,150 --> 00:18:09,690
Now interestingly, if you
make either of these numbers

388
00:18:09,690 --> 00:18:14,380
have a decimal, make them what
we call floating point numbers,

389
00:18:14,380 --> 00:18:16,310
then the division is
done in floating point.

390
00:18:16,310 --> 00:18:18,860

391
00:18:18,860 --> 00:18:21,790
So 10.0 over 2.0 is 5.0.

392
00:18:21,790 --> 00:18:24,100
Now these are different.

393
00:18:24,100 --> 00:18:26,590
This is an integer number,
and this is a floating point

394
00:18:26,590 --> 00:18:27,430
number.

395
00:18:27,430 --> 00:18:28,350
It's 5.0.

396
00:18:28,350 --> 00:18:32,285
And then 99.0 100.0 is
exactly as you would expect.

397
00:18:32,285 --> 00:18:33,660
And it's a floating
point number.

398
00:18:33,660 --> 00:18:36,840

399
00:18:36,840 --> 00:18:40,080
Now you can also mix integers
and floating point numbers

400
00:18:40,080 --> 00:18:41,380
as you go.

401
00:18:41,380 --> 00:18:43,390
So here we have 99 over 100.

402
00:18:43,390 --> 00:18:47,530
Those are both integers,
integer, integer.

403
00:18:47,530 --> 00:18:50,020
And it comes out with zero,
because it's truncating.

404
00:18:50,020 --> 00:18:53,580
Now if we have an integer
and a floating point number,

405
00:18:53,580 --> 00:18:58,340
99 over other 100.0, then
that comes out as 0.99.

406
00:18:58,340 --> 00:19:00,824
The either one, if
we have 99 over 100,

407
00:19:00,824 --> 00:19:02,740
that's a floating point
and that's an integer,

408
00:19:02,740 --> 00:19:04,323
we still end up with
a floating point.

409
00:19:04,323 --> 00:19:06,490
So this is a floating
point, floating point,

410
00:19:06,490 --> 00:19:11,140
and even in complex
expressions as it evaluates,

411
00:19:11,140 --> 00:19:12,219
when it sees an integer.

412
00:19:12,219 --> 00:19:13,760
So the first thing
you would evaluate

413
00:19:13,760 --> 00:19:15,650
is this would become 6.

414
00:19:15,650 --> 00:19:20,930
So it would be 1 plus
6 over 4.0 minus 5.

415
00:19:20,930 --> 00:19:23,240
Then it would be
doing this 6 over 4.0,

416
00:19:23,240 --> 00:19:25,780
and that would be 1.5.

417
00:19:25,780 --> 00:19:29,460
1 plus 1.5 minus 5.

418
00:19:29,460 --> 00:19:32,080
And so this is an integer,
and that's a floating point.

419
00:19:32,080 --> 00:19:33,780
And the result becomes
a floating point.

420
00:19:33,780 --> 00:19:35,280
And then the rest
of the calculation

421
00:19:35,280 --> 00:19:38,790
is done floating point to the
point where the ultimate is

422
00:19:38,790 --> 00:19:41,170
a floating point negative 2.5.

423
00:19:41,170 --> 00:19:44,580
So you can throw a floating
point into a calculation.

424
00:19:44,580 --> 00:19:47,630
And as soon as the calculation
touches the floating point,

425
00:19:47,630 --> 00:19:50,482
the remainder of the calculation
is done in floating point.

426
00:19:50,482 --> 00:19:52,190
It kind of converts
it to floating point.

427
00:19:52,190 --> 00:19:54,610
But it doesn't want
to convert it back.

428
00:19:54,610 --> 00:19:57,840
Because it considers floating
point sort of the more general

429
00:19:57,840 --> 00:19:59,023
of the representations.

430
00:19:59,023 --> 00:20:01,800

431
00:20:01,800 --> 00:20:06,520
So here we are talking about
integers and floating points.

432
00:20:06,520 --> 00:20:08,990
These are a concept in
programming languages

433
00:20:08,990 --> 00:20:11,840
and in Python called type.

434
00:20:11,840 --> 00:20:15,620
Variables and
constants have a type.

435
00:20:15,620 --> 00:20:19,630
We can see that if
you say 1 versus 1.0,

436
00:20:19,630 --> 00:20:22,080
it works differently, it
functions differently.

437
00:20:22,080 --> 00:20:25,650
And so Python keeps
track of both variables

438
00:20:25,650 --> 00:20:30,030
and literal slash constants
and having them have a type.

439
00:20:30,030 --> 00:20:32,260
And we've seen this, right?

440
00:20:32,260 --> 00:20:34,230
Now, the interesting
thing is Python

441
00:20:34,230 --> 00:20:37,860
is very aware of the type
and can use the same syntax

442
00:20:37,860 --> 00:20:40,010
to accomplish different things.

443
00:20:40,010 --> 00:20:43,369
So if we look at this line
here, where we say dd = 1.4,

444
00:20:43,369 --> 00:20:45,660
well, it looks at the 1 and
it looks at the 4 and says,

445
00:20:45,660 --> 00:20:47,050
oh, those are two integers.

446
00:20:47,050 --> 00:20:49,720
I will add those together
and give you a 5.

447
00:20:49,720 --> 00:20:51,370
So it gives you an
integer and integer,

448
00:20:51,370 --> 00:20:54,010
and an integer comes back.

449
00:20:54,010 --> 00:20:56,590
And then ee = hello plus there.

450
00:20:56,590 --> 00:20:58,930
Well, these are two
strings, hello and there.

451
00:20:58,930 --> 00:21:02,330
And it says, hm, this
must be a concatenation.

452
00:21:02,330 --> 00:21:04,880

453
00:21:04,880 --> 00:21:06,810
So I'm going to
concatenate those together.

454
00:21:06,810 --> 00:21:08,000
Because those are strings.

455
00:21:08,000 --> 00:21:10,050
And I know how to
concatenate strings.

456
00:21:10,050 --> 00:21:14,040
And that's kind of like
string addition, right?

457
00:21:14,040 --> 00:21:17,170
And so we see hello
there as a result.

458
00:21:17,170 --> 00:21:20,016
Now the interesting thing is
where did this space come from?

459
00:21:20,016 --> 00:21:21,990
Let me change colors here.

460
00:21:21,990 --> 00:21:22,690
Oops.

461
00:21:22,690 --> 00:21:24,310
Where did that space come from?

462
00:21:24,310 --> 00:21:27,080
Well, the plus does
not add the space.

463
00:21:27,080 --> 00:21:28,510
There's a space right there.

464
00:21:28,510 --> 00:21:29,780
And that's the space.

465
00:21:29,780 --> 00:21:33,060
So I concatenated
hello space plus there.

466
00:21:33,060 --> 00:21:35,050
And that's how I
got hello there.

467
00:21:35,050 --> 00:21:39,590
But the key thing is is
this plus operator, clear.

468
00:21:39,590 --> 00:21:43,480
This plus operator looks
to either side and says,

469
00:21:43,480 --> 00:21:44,810
oh, they're strings.

470
00:21:44,810 --> 00:21:46,740
I think you mean concatenation.

471
00:21:46,740 --> 00:21:48,880
Here, it looks at
either side and says,

472
00:21:48,880 --> 00:21:50,240
oh, those are integers.

473
00:21:50,240 --> 00:21:51,910
I think you mean addition.

474
00:21:51,910 --> 00:21:54,340
So Python is very aware of type.

475
00:21:54,340 --> 00:21:57,640
And type informs Python
what you really mean.

476
00:21:57,640 --> 00:21:59,520
So it looks like those
are kind of the same.

477
00:21:59,520 --> 00:22:01,145
But they're quite
different operations.

478
00:22:01,145 --> 00:22:04,080

479
00:22:04,080 --> 00:22:06,480
So the type can
get you in trouble.

480
00:22:06,480 --> 00:22:09,080
Remember, Python is
looking at the type.

481
00:22:09,080 --> 00:22:12,710
So here we have a little
problem, our first trace back,

482
00:22:12,710 --> 00:22:14,850
first of many trace backs.

483
00:22:14,850 --> 00:22:19,072
So here we have ee,
which is hello there,

484
00:22:19,072 --> 00:22:20,280
which is exactly what we did.

485
00:22:20,280 --> 00:22:21,120
This is a string.

486
00:22:21,120 --> 00:22:22,340
And this is a string.

487
00:22:22,340 --> 00:22:24,800
So ee should be a string.

488
00:22:24,800 --> 00:22:27,050
And then we try to add 1 to it.

489
00:22:27,050 --> 00:22:30,639
And again, Python is saying
oh, I see a plus sign here.

490
00:22:30,639 --> 00:22:31,930
So I'm going to look over here.

491
00:22:31,930 --> 00:22:32,890
Yeah, that's a string.

492
00:22:32,890 --> 00:22:35,015
And I'm going to look over
here, that's an integer.

493
00:22:35,015 --> 00:22:36,210
It's like, ah.

494
00:22:36,210 --> 00:22:37,800
And this is a trace back.

495
00:22:37,800 --> 00:22:41,110
Now, here's a good time
to talk about trace backs.

496
00:22:41,110 --> 00:22:43,390
Trace backs, I colored them red.

497
00:22:43,390 --> 00:22:46,160
Because you might
think that Python

498
00:22:46,160 --> 00:22:48,960
dislikes you or
thinks that you're

499
00:22:48,960 --> 00:22:51,654
unworthy of its brilliance.

500
00:22:51,654 --> 00:22:53,070
And certainly the
way these things

501
00:22:53,070 --> 00:22:55,710
are worded it sounds like
you're being scolded.

502
00:22:55,710 --> 00:22:58,200
It's like, hey, type error.

503
00:22:58,200 --> 00:23:01,590
You cannot concatenate
stir an int objects.

504
00:23:01,590 --> 00:23:02,532
Right?

505
00:23:02,532 --> 00:23:03,240
I'm scolding you.

506
00:23:03,240 --> 00:23:05,770
You bad, bad programmer.

507
00:23:05,770 --> 00:23:08,000
And it does feel a
bit like your scolded.

508
00:23:08,000 --> 00:23:10,970
But if you go back
to lecture one,

509
00:23:10,970 --> 00:23:13,920
this is also the moment
where really we shouldn't

510
00:23:13,920 --> 00:23:16,010
think of this as like scolding.

511
00:23:16,010 --> 00:23:18,560
We should think of this as
Python sort of asking for help.

512
00:23:18,560 --> 00:23:21,670
It's like, well, you
gave me this line.

513
00:23:21,670 --> 00:23:25,374
And I, Python, have no idea.

514
00:23:25,374 --> 00:23:27,040
In all your greatness,
could you give me

515
00:23:27,040 --> 00:23:30,860
some possible clue as to what
you really mean for me to do?

516
00:23:30,860 --> 00:23:32,260
Because I'm so lost.

517
00:23:32,260 --> 00:23:34,680
And given that I'm
Python, and I am lost,

518
00:23:34,680 --> 00:23:37,820
and you are the only
purpose for my existence,

519
00:23:37,820 --> 00:23:41,390
I must stop until you
give me better guidance.

520
00:23:41,390 --> 00:23:44,400
So don't look at trace
backs as scolding.

521
00:23:44,400 --> 00:23:45,895
They sound like scolding.

522
00:23:45,895 --> 00:23:49,520
I'll stop coloring
them red after a while.

523
00:23:49,520 --> 00:23:54,290
So if Python is so obsessed
with the type of things,

524
00:23:54,290 --> 00:23:57,040
you should able to ask Python
what the type of something is.

525
00:23:57,040 --> 00:23:59,750
So there's a built-in
function called type.

526
00:23:59,750 --> 00:24:02,975
This is part of the Python
language, type parenthese.

527
00:24:02,975 --> 00:24:04,770
And you can put a
variable in here.

528
00:24:04,770 --> 00:24:06,460
What's the type of
the variable ee?

529
00:24:06,460 --> 00:24:08,420
And it says, oh, yeah,
I know what that is.

530
00:24:08,420 --> 00:24:10,019
That would be a string.

531
00:24:10,019 --> 00:24:12,310
And then you could also put
a constant in here and say,

532
00:24:12,310 --> 00:24:15,620
what's the type of 'hello?'
And that's a string, too.

533
00:24:15,620 --> 00:24:17,270
And what's the type
of the number one?

534
00:24:17,270 --> 00:24:19,020
Well, that would be an integer.

535
00:24:19,020 --> 00:24:20,560
So it's picky about the type.

536
00:24:20,560 --> 00:24:24,990
But it'll also share with you
what it believes the type is.

537
00:24:24,990 --> 00:24:28,120
And there's several
types of numbers.

538
00:24:28,120 --> 00:24:30,404
As I've already mentioned,
there are integers,

539
00:24:30,404 --> 00:24:31,570
which are the whole numbers.

540
00:24:31,570 --> 00:24:33,834
They can be positive
and negative and zero.

541
00:24:33,834 --> 00:24:36,250
And then there are the decimal
numbers, the floating point

542
00:24:36,250 --> 00:24:42,040
numbers, like 98.6 or
negative 2.5 or 14.0.

543
00:24:42,040 --> 00:24:43,690
Python knows these as well.

544
00:24:43,690 --> 00:24:45,290
Because it does
division different

545
00:24:45,290 --> 00:24:47,230
if it's presented
with two integers,

546
00:24:47,230 --> 00:24:49,690
or an integer and a float,
or a float and a float.

547
00:24:49,690 --> 00:24:54,070

548
00:24:54,070 --> 00:24:56,490
And so here we have x is 1.

549
00:24:56,490 --> 00:24:57,620
And we say, what is it?

550
00:24:57,620 --> 00:24:58,520
It's an integer.

551
00:24:58,520 --> 00:25:00,396
And we say it's 98.6.

552
00:25:00,396 --> 00:25:01,520
And say, well, what's that?

553
00:25:01,520 --> 00:25:02,770
It's a float.

554
00:25:02,770 --> 00:25:05,130
And you could ask for both
variables and constants.

555
00:25:05,130 --> 00:25:06,400
So what's the type of 1?

556
00:25:06,400 --> 00:25:07,336
It's an integer.

557
00:25:07,336 --> 00:25:08,460
And what's the type of 1.0?

558
00:25:08,460 --> 00:25:11,670
And it's a float.

559
00:25:11,670 --> 00:25:12,980
It can also convert types.

560
00:25:12,980 --> 00:25:15,170
It has a bunch of type
conversion functions

561
00:25:15,170 --> 00:25:16,320
built into it.

562
00:25:16,320 --> 00:25:18,570
So there's an
implicit conversion

563
00:25:18,570 --> 00:25:21,820
going on when you're
sort of saying divide

564
00:25:21,820 --> 00:25:23,150
an integer by a floating point.

565
00:25:23,150 --> 00:25:25,610
It says, OK, I
looked to the sides.

566
00:25:25,610 --> 00:25:28,920
And I will make the
conversion for you.

567
00:25:28,920 --> 00:25:30,410
But you can also be explicit.

568
00:25:30,410 --> 00:25:33,430
So in this case we're
going to say, take this 99

569
00:25:33,430 --> 00:25:36,530
and convert it to a floating
point version of itself, which

570
00:25:36,530 --> 00:25:39,210
is 99.0, and then
do the division.

571
00:25:39,210 --> 00:25:42,850
So Python looks out here and
goes, oh, that's a float.

572
00:25:42,850 --> 00:25:44,910
And that's an integer
if I look over here.

573
00:25:44,910 --> 00:25:47,530
And then that means that
the result is a float.

574
00:25:47,530 --> 00:25:49,370
And the division
is done as a float.

575
00:25:49,370 --> 00:25:57,084
So we are force converting the
99 integer into a 99.0 float.

576
00:25:57,084 --> 00:25:59,500
And we can even do this and
just stick it in the variable.

577
00:25:59,500 --> 00:26:01,330
So we can put 42 in i.

578
00:26:01,330 --> 00:26:02,820
And that is an integer.

579
00:26:02,820 --> 00:26:07,430
Then we can say, hey, convert
float that i into a float

580
00:26:07,430 --> 00:26:09,740
and stick it into
the variable f.

581
00:26:09,740 --> 00:26:12,070
And so we can print it.

582
00:26:12,070 --> 00:26:15,060
And now it's 42.0 instead of 42.

583
00:26:15,060 --> 00:26:16,450
They're not the same.

584
00:26:16,450 --> 00:26:17,760
They're both kind of 42.

585
00:26:17,760 --> 00:26:21,785
But one is a floating point 42,
and the other is an integer 42.

586
00:26:21,785 --> 00:26:24,054
And we can ask, and
that is a float.

587
00:26:24,054 --> 00:26:25,470
And you can also
do the same thing

588
00:26:25,470 --> 00:26:27,500
in the middle of a
calculation where you

589
00:26:27,500 --> 00:26:30,530
have 1 plus 2 times float of 3.

590
00:26:30,530 --> 00:26:32,420
This float is done quickly.

591
00:26:32,420 --> 00:26:38,360
So the first thing that happens,
this is 1 plus 2 times 3.0

592
00:26:38,360 --> 00:26:41,680
point 0 over 4 minus 5.

593
00:26:41,680 --> 00:26:44,290
So the first thing that happens
is these floats are done.

594
00:26:44,290 --> 00:26:46,123
Because they're
parentheses, so they matter.

595
00:26:46,123 --> 00:26:47,950
So this is a built-in
function called

596
00:26:47,950 --> 00:26:50,510
float that takes,
as its argument,

597
00:26:50,510 --> 00:26:53,560
a non-floating point
number and gives you back

598
00:26:53,560 --> 00:26:55,390
a floating point number.

599
00:26:55,390 --> 00:26:57,440
We'll talk more about
functions in chapter four.

600
00:26:57,440 --> 00:27:01,240

601
00:27:01,240 --> 00:27:04,190
You can also convert
between strings and numbers.

602
00:27:04,190 --> 00:27:10,210
And if you recall, we did the
example where we take a string.

603
00:27:10,210 --> 00:27:12,570
In this case, I'm being
a little confusing

604
00:27:12,570 --> 00:27:16,700
because I'm making a string
with the characters 1, 2, 3.

605
00:27:16,700 --> 00:27:19,330
Now, this is not
the same as 123.

606
00:27:19,330 --> 00:27:23,360
This is a three character
string with 1, 2, 3 in it.

607
00:27:23,360 --> 00:27:25,660
And I can ask what kind
of thing is in there.

608
00:27:25,660 --> 00:27:27,480
And it says, oh, there's
a string in there.

609
00:27:27,480 --> 00:27:28,780
I know about that.

610
00:27:28,780 --> 00:27:30,500
And then I can try
to add 1 to it.

611
00:27:30,500 --> 00:27:33,760
And it seems intuitive
that quote 1, 2, 3 plus 1

612
00:27:33,760 --> 00:27:36,740
would be somehow 124.

613
00:27:36,740 --> 00:27:38,320
But it's not.

614
00:27:38,320 --> 00:27:40,575
Python takes a look
at the plus and says,

615
00:27:40,575 --> 00:27:41,950
oh, there's a
string on that side

616
00:27:41,950 --> 00:27:43,460
and an integer on that side.

617
00:27:43,460 --> 00:27:46,340
I am going to freak out and
tell you about you cannot

618
00:27:46,340 --> 00:27:49,910
concatenate a string
and an integer.

619
00:27:49,910 --> 00:27:51,940
But there is an
int function that

620
00:27:51,940 --> 00:27:54,380
converts various
things, including

621
00:27:54,380 --> 00:27:55,500
strings, to an integer.

622
00:27:55,500 --> 00:28:00,280
So we can give as its parameter,
it's input, the string value.

623
00:28:00,280 --> 00:28:02,420
Then it converts
it to an integer.

624
00:28:02,420 --> 00:28:05,450
And then it will put the
result in the variable ival.

625
00:28:05,450 --> 00:28:06,990
We can ask what the
type of that is.

626
00:28:06,990 --> 00:28:09,820
It's an integer.

627
00:28:09,820 --> 00:28:13,250
And now we can use it in an
expression, print ival plus 1.

628
00:28:13,250 --> 00:28:16,300
And so now, Python looks to
both sides, sees an integer,

629
00:28:16,300 --> 00:28:19,270
sees an integer, and gets 124.

630
00:28:19,270 --> 00:28:21,120
Voila.

631
00:28:21,120 --> 00:28:24,730
Now if I make a new variable
and I stick hello Bob in it

632
00:28:24,730 --> 00:28:28,650
and I say, hey, let's convert
hello Bob to an integer,

633
00:28:28,650 --> 00:28:31,350
as you might
expect, it blows up.

634
00:28:31,350 --> 00:28:36,010
And it says invalid
literal for int.

635
00:28:36,010 --> 00:28:40,010
These trace backs,
again, once you kind of

636
00:28:40,010 --> 00:28:43,660
get used to the harsh wording
of them, because they're not

637
00:28:43,660 --> 00:28:46,020
saying, sorry comma.

638
00:28:46,020 --> 00:28:48,020
They're trying to tell
you what's going on.

639
00:28:48,020 --> 00:28:52,440
So cannot concatenate string
and integer and invalid literal

640
00:28:52,440 --> 00:28:52,940
for int.

641
00:28:52,940 --> 00:28:56,310
It's trying to be as helpful as
it possibly can be to give you

642
00:28:56,310 --> 00:28:57,760
a clue as to what to fix.

643
00:28:57,760 --> 00:29:02,040
So again, not scolding.

644
00:29:02,040 --> 00:29:02,950
OK.

645
00:29:02,950 --> 00:29:05,720
So that's variables, and
types, and type conversion.

646
00:29:05,720 --> 00:29:09,350
Now we'll talk a little
bit about user input.

647
00:29:09,350 --> 00:29:12,830
And there's a
function that's built

648
00:29:12,830 --> 00:29:15,350
into Python called raw input.

649
00:29:15,350 --> 00:29:20,090
And what happens when
raw input runs is it

650
00:29:20,090 --> 00:29:23,030
has, as one of its
parameters, a prompt,

651
00:29:23,030 --> 00:29:25,290
which is something that
shows up on the screen.

652
00:29:25,290 --> 00:29:26,990
Who are you?

653
00:29:26,990 --> 00:29:29,685
And then it waits.

654
00:29:29,685 --> 00:29:31,970
It sits and waits.

655
00:29:31,970 --> 00:29:34,500
It says, what next?

656
00:29:34,500 --> 00:29:37,400
And then you type a string.

657
00:29:37,400 --> 00:29:38,730
And then you hit the Enter key.

658
00:29:38,730 --> 00:29:41,640

659
00:29:41,640 --> 00:29:48,480
And then whatever you typed
here goes into a variable.

660
00:29:48,480 --> 00:29:51,010
And it is a string.

661
00:29:51,010 --> 00:29:53,800
And then you can use it.

662
00:29:53,800 --> 00:29:56,670
So I'm going to print
the string welcome comma.

663
00:29:56,670 --> 00:29:58,720
So that means I'm
printing two things now.

664
00:29:58,720 --> 00:30:00,779
The comma adds a
space between welcome.

665
00:30:00,779 --> 00:30:01,320
And then nam.

666
00:30:01,320 --> 00:30:03,440
And so welcome is a literal.

667
00:30:03,440 --> 00:30:07,260
And then Chuck is coming
from this nam variable.

668
00:30:07,260 --> 00:30:09,410
So this is a two-line program.

669
00:30:09,410 --> 00:30:13,100
I think this is one of
your assignments actually.

670
00:30:13,100 --> 00:30:15,960
Well, it's one of the
exercises in the book

671
00:30:15,960 --> 00:30:18,330
to prompt for a user's
name and then welcome them.

672
00:30:18,330 --> 00:30:21,410

673
00:30:21,410 --> 00:30:25,000
So raw input is a function
that issues a prompt,

674
00:30:25,000 --> 00:30:27,300
waits, and then takes
whatever string is entered,

675
00:30:27,300 --> 00:30:29,805
and then returns it, and then
puts it into that variable.

676
00:30:29,805 --> 00:30:33,450

677
00:30:33,450 --> 00:30:36,040
So now we're going
to create kind

678
00:30:36,040 --> 00:30:38,200
of the first useful program.

679
00:30:38,200 --> 00:30:41,170
It's not a powerful program.

680
00:30:41,170 --> 00:30:48,279
It is an interesting problem of
the fact that for some reason

681
00:30:48,279 --> 00:30:49,820
there's a difference
in the numbering

682
00:30:49,820 --> 00:30:51,930
scheme of United
States elevators

683
00:30:51,930 --> 00:30:54,210
and European elevators.

684
00:30:54,210 --> 00:30:58,120
European elevators, the
floor that you walk out on

685
00:30:58,120 --> 00:30:59,770
is the 0 floor.

686
00:30:59,770 --> 00:31:01,620
The floor above
that is the 1 floor.

687
00:31:01,620 --> 00:31:06,280
And the floor below that, the
basement, is the minus 1 floor.

688
00:31:06,280 --> 00:31:08,360
And so you walk in
and you can either

689
00:31:08,360 --> 00:31:11,610
go up the elevator
or down the elevator.

690
00:31:11,610 --> 00:31:15,030
Of course, in the United States,
the floor that you walk in

691
00:31:15,030 --> 00:31:16,290
is the 1.

692
00:31:16,290 --> 00:31:18,110
And then there's the
2 floor above that.

693
00:31:18,110 --> 00:31:20,120
And then there's the basement.

694
00:31:20,120 --> 00:31:24,620
So this is the imagination that
the Americans have as to how

695
00:31:24,620 --> 00:31:26,160
to number floors.

696
00:31:26,160 --> 00:31:29,290
The Europeans go 0, 1, minus 1.

697
00:31:29,290 --> 00:31:32,620
So children who
go to hotels learn

698
00:31:32,620 --> 00:31:35,279
instantly the notion
of zero and the notion

699
00:31:35,279 --> 00:31:37,320
of positive and negative
numbers and the symmetry

700
00:31:37,320 --> 00:31:39,310
between positive and
negative numbers.

701
00:31:39,310 --> 00:31:41,260
I mean, I just wish the
United States hotels

702
00:31:41,260 --> 00:31:47,530
would switch to this I
to teach young people 0

703
00:31:47,530 --> 00:31:50,340
immediately and
negative numbers.

704
00:31:50,340 --> 00:31:52,770
So we somehow think that
numbers in the United States

705
00:31:52,770 --> 00:31:55,946
start at 1, and then there
are no negative numbers.

706
00:31:55,946 --> 00:31:56,820
There's the basement.

707
00:31:56,820 --> 00:31:59,716

708
00:31:59,716 --> 00:32:03,650
I wonder why that
is, but whatever.

709
00:32:03,650 --> 00:32:08,220
For people to travel a lot,
they may be confused by this.

710
00:32:08,220 --> 00:32:12,010
They need a way to convert
back and forth between the US

711
00:32:12,010 --> 00:32:15,480
and European numbering system.

712
00:32:15,480 --> 00:32:18,140
So this is a simple
program that demonstrates

713
00:32:18,140 --> 00:32:22,140
a real classic pattern of
input processing and output.

714
00:32:22,140 --> 00:32:23,670
It's just three lines.

715
00:32:23,670 --> 00:32:27,950
But it has the essential
things that all programs that

716
00:32:27,950 --> 00:32:31,310
are useful-- they
generally read some data,

717
00:32:31,310 --> 00:32:34,320
do some work with the
data, and then produce

718
00:32:34,320 --> 00:32:36,040
some kind of results.

719
00:32:36,040 --> 00:32:42,780
And so the first line is a raw
input that effectively puts out

720
00:32:42,780 --> 00:32:44,600
a prompt.

721
00:32:44,600 --> 00:32:45,550
And the wait.

722
00:32:45,550 --> 00:32:47,950
It says, please enter
your Europe floor.

723
00:32:47,950 --> 00:32:49,180
It sits there.

724
00:32:49,180 --> 00:32:50,940
We type a 0.

725
00:32:50,940 --> 00:32:53,070
Then 0 goes into int.

726
00:32:53,070 --> 00:32:55,280
But it is a string.

727
00:32:55,280 --> 00:32:56,510
It is not a number.

728
00:32:56,510 --> 00:32:57,700
It is a string.

729
00:32:57,700 --> 00:32:59,820
So we can't add to it.

730
00:32:59,820 --> 00:33:04,140
But we can take and convert
it to an integer with the int

731
00:33:04,140 --> 00:33:06,340
function, int of imp.

732
00:33:06,340 --> 00:33:08,360
That's a string being
converted to an integer.

733
00:33:08,360 --> 00:33:11,040
So now it's a real numeric 0.

734
00:33:11,040 --> 00:33:12,425
We can add 1 to that.

735
00:33:12,425 --> 00:33:14,250
And we sum that together.

736
00:33:14,250 --> 00:33:18,030
And we put it into
the variable usf.

737
00:33:18,030 --> 00:33:20,230
And then we print
US Floor comma,

738
00:33:20,230 --> 00:33:22,940
and then whatever the
variable for usf is.

739
00:33:22,940 --> 00:33:25,350
And out come US Floor 1.

740
00:33:25,350 --> 00:33:28,720
So you're written a very
simple elevator floor

741
00:33:28,720 --> 00:33:33,306
conversion from a European
floor to a United States floor.

742
00:33:33,306 --> 00:33:34,680
Don't ask about
negative numbers.

743
00:33:34,680 --> 00:33:35,888
It's not really good at that.

744
00:33:35,888 --> 00:33:38,880
But from 0 and positive
numbers, it works great.

745
00:33:38,880 --> 00:33:42,680

746
00:33:42,680 --> 00:33:47,020
So another thing to think about
in any programming language

747
00:33:47,020 --> 00:33:49,610
is comments.

748
00:33:49,610 --> 00:33:52,030
Comments are like commentary.

749
00:33:52,030 --> 00:33:57,180
And basically, it's a way
for us to add notations

750
00:33:57,180 --> 00:34:00,050
for ourselves or for
other humans interspersed

751
00:34:00,050 --> 00:34:01,460
in the code.

752
00:34:01,460 --> 00:34:06,029
And so in Python, anything
after a pound sign is ignored.

753
00:34:06,029 --> 00:34:08,320
You can have a pound sign at
the beginning of the line,

754
00:34:08,320 --> 00:34:10,179
and then the whole
line is ignored.

755
00:34:10,179 --> 00:34:12,630
There are two or three
reasons why you could do this.

756
00:34:12,630 --> 00:34:15,389
One is sort of like
paragraph headings, where

757
00:34:15,389 --> 00:34:17,170
you can say what's
going to happen

758
00:34:17,170 --> 00:34:21,140
in English or your language.

759
00:34:21,140 --> 00:34:22,639
And you can write
documentation that

760
00:34:22,639 --> 00:34:25,659
says, this code was written
by Charles Severance December,

761
00:34:25,659 --> 00:34:27,500
2010.

762
00:34:27,500 --> 00:34:29,590
And you could also just
hide a line of code

763
00:34:29,590 --> 00:34:32,460
to test and turn it on
and off without actually

764
00:34:32,460 --> 00:34:34,030
deleting the line of code.

765
00:34:34,030 --> 00:34:36,900
It's a real common
thing in debugging.

766
00:34:36,900 --> 00:34:41,902
So for example,
here is the program

767
00:34:41,902 --> 00:34:43,110
that we've been playing with.

768
00:34:43,110 --> 00:34:44,895
This is our word
counting program

769
00:34:44,895 --> 00:34:47,080
that we've been talking
about from the beginning.

770
00:34:47,080 --> 00:34:51,620
And here is the example of
four comments, one, two, three,

771
00:34:51,620 --> 00:34:54,797
four, four comments
that basically tell us

772
00:34:54,797 --> 00:34:56,380
what these paragraphs
are going to do.

773
00:34:56,380 --> 00:34:59,280
Now, they don't have any effect
on the program whatsoever.

774
00:34:59,280 --> 00:35:02,330
But this one says get the
name of the file and open it.

775
00:35:02,330 --> 00:35:04,130
Kind of helpful, right?

776
00:35:04,130 --> 00:35:06,630
Count the word frequency, that's
what this little bit does.

777
00:35:06,630 --> 00:35:08,070
Find the most
common word, that's

778
00:35:08,070 --> 00:35:09,490
what this little bit does.

779
00:35:09,490 --> 00:35:11,580
And all done, print this out.

780
00:35:11,580 --> 00:35:14,830
So it really can be
very helpful just

781
00:35:14,830 --> 00:35:16,620
to add a little
tiny bit of stuff.

782
00:35:16,620 --> 00:35:18,410
You don't want to
over use comments.

783
00:35:18,410 --> 00:35:23,500
You don't want to say like, x =
12, take 12 and put it into x.

784
00:35:23,500 --> 00:35:24,980
Sometimes people
teach you and try

785
00:35:24,980 --> 00:35:28,217
to say, oh, you need one
comment every three lines.

786
00:35:28,217 --> 00:35:29,800
I don't believe in
any of those rules.

787
00:35:29,800 --> 00:35:32,690
I basically say if it's
useful to describe it, then

788
00:35:32,690 --> 00:35:35,030
describe it.

789
00:35:35,030 --> 00:35:36,580
So that's comments.

790
00:35:36,580 --> 00:35:41,140
So some operators
apply the strings.

791
00:35:41,140 --> 00:35:43,410
We've already talked about plus.

792
00:35:43,410 --> 00:35:45,610
It's kind of silly,
although useful in places.

793
00:35:45,610 --> 00:35:47,160
You could actually
multiply string,

794
00:35:47,160 --> 00:35:50,040
where the asterisk
looks and says

795
00:35:50,040 --> 00:35:51,900
I got a string and an integer.

796
00:35:51,900 --> 00:35:55,320
And it prints out the
string five times.

797
00:35:55,320 --> 00:35:57,640
Not a lot of use for that.

798
00:35:57,640 --> 00:36:01,480
Now, let's talk a little bit
about choosing variable names.

799
00:36:01,480 --> 00:36:04,270
This is something that
is really confusing.

800
00:36:04,270 --> 00:36:07,280
So I said, like, x
= 1, x = x plus 1.

801
00:36:07,280 --> 00:36:08,280
What does x mean?

802
00:36:08,280 --> 00:36:12,190
And the answer is it
doesn't mean anything.

803
00:36:12,190 --> 00:36:13,450
I chose it.

804
00:36:13,450 --> 00:36:14,930
I wanted to make a variable.

805
00:36:14,930 --> 00:36:16,780
And so I picked x.

806
00:36:16,780 --> 00:36:18,730
We pick x a lot
probably because we

807
00:36:18,730 --> 00:36:23,290
learned in algebra in sixth
grade that x was a variable.

808
00:36:23,290 --> 00:36:24,510
And it's short.

809
00:36:24,510 --> 00:36:26,130
And so why not call it x?

810
00:36:26,130 --> 00:36:29,800

811
00:36:29,800 --> 00:36:31,660
But as your programs
get larger, this

812
00:36:31,660 --> 00:36:33,784
gets kind of frustrating
to have all your variables

813
00:36:33,784 --> 00:36:35,490
like x and y and z.

814
00:36:35,490 --> 00:36:39,130
And so the notion of
mnemonic, it means memory aid.

815
00:36:39,130 --> 00:36:41,830
We choose our
variable names wisely,

816
00:36:41,830 --> 00:36:44,180
so they remind us of
what the variable is

817
00:36:44,180 --> 00:36:46,430
going to do internally.

818
00:36:46,430 --> 00:36:51,540
And so as I go
through this lecture,

819
00:36:51,540 --> 00:36:55,740
in the beginning if I choose
a variable that's too clever,

820
00:36:55,740 --> 00:36:59,030
you're going to think that
it's part of the language.

821
00:36:59,030 --> 00:37:00,650
And so I sort of
switch back and forth

822
00:37:00,650 --> 00:37:02,530
between well chosen
variable names

823
00:37:02,530 --> 00:37:04,110
and stupid variable
names to kind

824
00:37:04,110 --> 00:37:07,410
re-emphasize the notion
that I can choose.

825
00:37:07,410 --> 00:37:09,400
Mnemonic is a good practice.

826
00:37:09,400 --> 00:37:10,100
OK.

827
00:37:10,100 --> 00:37:11,450
So here we go.

828
00:37:11,450 --> 00:37:13,970
Let's take a look
at the bit of code.

829
00:37:13,970 --> 00:37:17,410

830
00:37:17,410 --> 00:37:21,120
So the question is what
is this code doing?

831
00:37:21,120 --> 00:37:23,300
What will it even print out?

832
00:37:23,300 --> 00:37:24,720
Is it syntactically correct?

833
00:37:24,720 --> 00:37:27,400

834
00:37:27,400 --> 00:37:32,880
Now you can probably cut
and paste this into Python

835
00:37:32,880 --> 00:37:37,510
and figure out that it
is syntactically correct.

836
00:37:37,510 --> 00:37:38,895
There are three variables.

837
00:37:38,895 --> 00:37:42,880

838
00:37:42,880 --> 00:37:48,070
This one here and
this one here match.

839
00:37:48,070 --> 00:37:50,840
This one here and
that one there match.

840
00:37:50,840 --> 00:37:52,980
And these two match.

841
00:37:52,980 --> 00:37:56,250
So it's taking these two numbers
and multiplying together,

842
00:37:56,250 --> 00:37:59,090
and then printing out the
product of the two numbers

843
00:37:59,090 --> 00:38:03,900
if you're real careful and
look at every character.

844
00:38:03,900 --> 00:38:07,210
Now this would be called
non-mnemonic variables.

845
00:38:07,210 --> 00:38:09,220
They're really messy.

846
00:38:09,220 --> 00:38:11,260
Now Python, it's happy.

847
00:38:11,260 --> 00:38:13,680
Because all it wants
is to say, oh, here's

848
00:38:13,680 --> 00:38:16,040
the name that I, the
programmer, decided I wanted

849
00:38:16,040 --> 00:38:17,310
to call this piece of memory.

850
00:38:17,310 --> 00:38:20,190
And I'll refer to it down here.

851
00:38:20,190 --> 00:38:21,870
OK.

852
00:38:21,870 --> 00:38:23,350
And so Python's happy.

853
00:38:23,350 --> 00:38:25,650
Now, if you hand this
to another human being,

854
00:38:25,650 --> 00:38:27,290
they're going to
be really unhappy.

855
00:38:27,290 --> 00:38:30,270
Because they're going to
be like what are you doing?

856
00:38:30,270 --> 00:38:33,850
So one better way
to write it would

857
00:38:33,850 --> 00:38:35,640
be to make the
variables very simple.

858
00:38:35,640 --> 00:38:39,700
And then cognitively, we humans
can figure out which is which.

859
00:38:39,700 --> 00:38:42,605
Because again, it's still
only about matching.

860
00:38:42,605 --> 00:38:45,524
The a has to match the a.

861
00:38:45,524 --> 00:38:46,700
The b matches the b.

862
00:38:46,700 --> 00:38:48,419
And the cs match.

863
00:38:48,419 --> 00:38:49,960
It's actually the
exact same program.

864
00:38:49,960 --> 00:38:57,730
a = 35, b= 12.5, c equals
a times b, and print c.

865
00:38:57,730 --> 00:39:00,990
Python sees these
as the same program.

866
00:39:00,990 --> 00:39:03,150
It doesn't care
what we name them.

867
00:39:03,150 --> 00:39:06,660
Now a human will be much
appreciative if you say here,

868
00:39:06,660 --> 00:39:08,780
you can either have
this one or this one.

869
00:39:08,780 --> 00:39:10,905
This one will make
them a lot happier.

870
00:39:10,905 --> 00:39:13,460

871
00:39:13,460 --> 00:39:14,500
OK?

872
00:39:14,500 --> 00:39:17,560
So that is certainly
cognitively easier.

873
00:39:17,560 --> 00:39:19,810
But it's not really
giving you any sense

874
00:39:19,810 --> 00:39:23,330
of what's going on here.

875
00:39:23,330 --> 00:39:27,330
So an even better way to
write this exact same program

876
00:39:27,330 --> 00:39:29,660
to do the exact
same thing would be

877
00:39:29,660 --> 00:39:32,440
to choose variables
named hours, rate,

878
00:39:32,440 --> 00:39:35,810
and pay if indeed that
is what you're doing.

879
00:39:35,810 --> 00:39:39,452
Now you can look at this and
you go, oh, well shoot, 35

880
00:39:39,452 --> 00:39:40,410
is the number of hours.

881
00:39:40,410 --> 00:39:42,130
And 12 and 1/2 is the rate.

882
00:39:42,130 --> 00:39:44,531
And the pay is the number
of hours times the rate.

883
00:39:44,531 --> 00:39:46,280
And then we're going
to print out the pay.

884
00:39:46,280 --> 00:39:48,130
That makes a lot of sense.

885
00:39:48,130 --> 00:39:54,270
So this is really an awesome
and wonderful characterization.

886
00:39:54,270 --> 00:39:56,130
And if that's what
you're doing and if those

887
00:39:56,130 --> 00:39:58,280
are hours, rate, pay,
it's a great thing

888
00:39:58,280 --> 00:40:00,040
to name your variables.

889
00:40:00,040 --> 00:40:04,444
But this is where beginning
students get confused.

890
00:40:04,444 --> 00:40:06,110
And so sometimes I'll
write it this way,

891
00:40:06,110 --> 00:40:07,859
and sometimes I'll
write it this way.

892
00:40:07,859 --> 00:40:09,400
Because you'll look
at this until you

893
00:40:09,400 --> 00:40:12,150
get a little more sophisticated
a little more skilled,

894
00:40:12,150 --> 00:40:17,530
and you say, like, does Python
know something about payroll?

895
00:40:17,530 --> 00:40:19,400
Is hours a reserved word?

896
00:40:19,400 --> 00:40:22,350
Is rate a reserved word
and pay a reserved word?

897
00:40:22,350 --> 00:40:24,290
Are these things that
Python knows about?

898
00:40:24,290 --> 00:40:26,350
And the answer is no.

899
00:40:26,350 --> 00:40:30,270
Python sees these three programs
as exactly the same name.

900
00:40:30,270 --> 00:40:33,260
It's just this person really
made a very bad choice

901
00:40:33,260 --> 00:40:34,450
of variable name.

902
00:40:34,450 --> 00:40:37,710
This person made a less bad
choice of a variable name.

903
00:40:37,710 --> 00:40:39,620
And this person made a
really awesome choice

904
00:40:39,620 --> 00:40:40,810
of variable name.

905
00:40:40,810 --> 00:40:45,090
So the difference between
these two things is style.

906
00:40:45,090 --> 00:40:47,220
They are the exact same program.

907
00:40:47,220 --> 00:40:50,610
And Python is equivalently
happy with these.

908
00:40:50,610 --> 00:40:53,630
But humans are most happy
when the variables are

909
00:40:53,630 --> 00:40:56,180
easy to remember and
they are somewhat

910
00:40:56,180 --> 00:40:59,870
descriptive of what they're
expected contents will be.

911
00:40:59,870 --> 00:41:02,980
That's mnemonic to
help you remember

912
00:41:02,980 --> 00:41:05,700
what you were meaning to do
when you write the program.

913
00:41:05,700 --> 00:41:08,742
This is still a bit cryptic
having these really short

914
00:41:08,742 --> 00:41:09,950
one character variable names.

915
00:41:09,950 --> 00:41:12,070
It's still a bit cryptic.

916
00:41:12,070 --> 00:41:15,960
So you have a couple
of assignments

917
00:41:15,960 --> 00:41:17,120
at the end of the chapter.

918
00:41:17,120 --> 00:41:20,280
One of the assignments
is to write a program

919
00:41:20,280 --> 00:41:26,450
to prompt the user for hours and
rate per hour and compute pay.

920
00:41:26,450 --> 00:41:29,500
So I won't do this
here, but just

921
00:41:29,500 --> 00:41:33,091
a couple of sort of odd things.

922
00:41:33,091 --> 00:41:34,595
You're going to be
using raw input.

923
00:41:34,595 --> 00:41:37,130

924
00:41:37,130 --> 00:41:40,630
But remember that
hands a string in.

925
00:41:40,630 --> 00:41:44,862
So you're going to have to use
float to function to convert it

926
00:41:44,862 --> 00:41:46,820
to a floating point
number, so you can actually

927
00:41:46,820 --> 00:41:48,350
do a calculation.

928
00:41:48,350 --> 00:41:51,220
And then you're going to have
to use multiplication and print,

929
00:41:51,220 --> 00:41:55,190
so multiplication
and then print.

930
00:41:55,190 --> 00:41:59,130
So it's some combination of raw
input, float, multiplication,

931
00:41:59,130 --> 00:42:05,630
and print constructed to make
your program do exactly this.

932
00:42:05,630 --> 00:42:08,370
So this is the end
of a chapter two.

933
00:42:08,370 --> 00:42:11,530
We talked about types,
reserved words, variables,

934
00:42:11,530 --> 00:42:14,279
the mnemonic how you choose
variable names-- we'll

935
00:42:14,279 --> 00:42:16,820
hit this a couple more times,
because choosing variable names

936
00:42:16,820 --> 00:42:19,780
is always problematic--
operators, operator

937
00:42:19,780 --> 00:42:22,410
precedence, which just means
like does multiplication happen

938
00:42:22,410 --> 00:42:24,600
before plus, parentheses.

939
00:42:24,600 --> 00:42:27,690
Integer division is a little
weird, because it truncates.

940
00:42:27,690 --> 00:42:35,190

941
00:42:35,190 --> 00:42:38,790
9 over 10 = 0.

942
00:42:38,790 --> 00:42:41,070
That's the integer
division truncating.

943
00:42:41,070 --> 00:42:44,965
Conversion, this is
like the int float.

944
00:42:44,965 --> 00:42:47,900

945
00:42:47,900 --> 00:42:50,020
And then user input,
which is raw input.

946
00:42:50,020 --> 00:42:52,110
And then comments,
which are ways

947
00:42:52,110 --> 00:42:55,720
for you to add human readable
text to your program.

948
00:42:55,720 --> 00:42:56,620
OK.

949
00:42:56,620 --> 00:42:58,470
See you next lecture.
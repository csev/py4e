1
00:00:00,000 --> 00:00:00,499

2
00:00:00,499 --> 00:00:04,500
Hello and welcome to
chapter eight, Python Lists.

3
00:00:04,500 --> 00:00:08,330
So now we're sort of going to
start taking care of business.

4
00:00:08,330 --> 00:00:11,820
We are [? going ?] to make lists
and dictionaries and tuples

5
00:00:11,820 --> 00:00:13,540
and really start
manipulating this data

6
00:00:13,540 --> 00:00:17,280
and doing real data analysis--
laying the ground work

7
00:00:17,280 --> 00:00:18,250
real data analysis.

8
00:00:18,250 --> 00:00:21,980
As always, these lectures,
audio, video, slides,

9
00:00:21,980 --> 00:00:25,730
and even book are copyright
Creative Commons attribution.

10
00:00:25,730 --> 00:00:29,320
So lists, dictionaries
and tuples,

11
00:00:29,320 --> 00:00:31,570
the next real three big
topics we're going talk about,

12
00:00:31,570 --> 00:00:33,610
are collections.

13
00:00:33,610 --> 00:00:37,300
And we've been doing
lists already, right?

14
00:00:37,300 --> 00:00:40,730
We've been doing lists when
we were doing for loops.

15
00:00:40,730 --> 00:00:43,990
A list in Python is something
that has square braces.

16
00:00:43,990 --> 00:00:46,560
This is a constant list.

17
00:00:46,560 --> 00:00:48,940
Now when I first talked
to you about variables,

18
00:00:48,940 --> 00:00:50,560
I sort of oversimplified things.

19
00:00:50,560 --> 00:00:53,880
I said if you put
x equals 2 and then

20
00:00:53,880 --> 00:00:57,530
put x equals 4, the 2 and
the 4 override each other.

21
00:00:57,530 --> 00:01:00,776
A collection is where you
can put a bunch of things

22
00:01:00,776 --> 00:01:01,650
in the same variable.

23
00:01:01,650 --> 00:01:05,560
Now I have to have a way
to find those things,

24
00:01:05,560 --> 00:01:11,890
but it allows us to put more
than one thing in a variable.

25
00:01:11,890 --> 00:01:14,541
And so here we have friends,
that has three strings, Joseph,

26
00:01:14,541 --> 00:01:16,040
Glenn and Sally and
we have carryon,

27
00:01:16,040 --> 00:01:18,290
it has socks, shirt and perfume.

28
00:01:18,290 --> 00:01:20,110
So that's the basic idea.

29
00:01:20,110 --> 00:01:21,730
So what's not a collection?

30
00:01:21,730 --> 00:01:23,380
Well, simple variables.

31
00:01:23,380 --> 00:01:25,150
Simple variables
are not collections.

32
00:01:25,150 --> 00:01:27,950
Just like this example,
I say, x equals

33
00:01:27,950 --> 00:01:31,250
2 x equals 4 and print
x and the 4 is in there

34
00:01:31,250 --> 00:01:33,430
and the 2 is somehow gone.

35
00:01:33,430 --> 00:01:36,710
It was there for a moment
and then it's gone.

36
00:01:36,710 --> 00:01:39,300
And so that's a normal variable,
they're not collections,

37
00:01:39,300 --> 00:01:41,860
you can't put more
than one thing in it.

38
00:01:41,860 --> 00:01:43,990
But when you put more
than one thing in it,

39
00:01:43,990 --> 00:01:45,500
then you have to
have a way to find

40
00:01:45,500 --> 00:01:46,800
the things that are in there.

41
00:01:46,800 --> 00:01:49,280
We'll get to that.

42
00:01:49,280 --> 00:01:51,200
So we've been using
list constants

43
00:01:51,200 --> 00:01:53,110
for the last couple
of chapters just

44
00:01:53,110 --> 00:01:55,400
because we have to use
list constants, you know?

45
00:01:55,400 --> 00:01:57,630
So we used it in the
For loop chapter,

46
00:01:57,630 --> 00:02:00,540
we did list of numbers.

47
00:02:00,540 --> 00:02:03,490
We have done lists
of strings, t that's

48
00:02:03,490 --> 00:02:06,470
strings red, yellow and blue.

49
00:02:06,470 --> 00:02:11,520
And you don't have
to necessarily have

50
00:02:11,520 --> 00:02:13,680
to have things all
of the same type.

51
00:02:13,680 --> 00:02:18,120
This is three item list
that has a string red,

52
00:02:18,120 --> 00:02:21,340
the number integer
24 and 98.6 which

53
00:02:21,340 --> 00:02:23,010
is a floating point number.

54
00:02:23,010 --> 00:02:25,820
Here's an interesting
thing just as a side note,

55
00:02:25,820 --> 00:02:28,630
this shows that floating
point numbers are not always

56
00:02:28,630 --> 00:02:32,050
perfectly represented
inside of the computer,

57
00:02:32,050 --> 00:02:34,680
it's sort of an artifact
of how they work.

58
00:02:34,680 --> 00:02:37,790
And this is an example of
98.6 is really 98 point

59
00:02:37,790 --> 00:02:38,990
na-na-na-na-na.

60
00:02:38,990 --> 00:02:41,290
So when you see something
like that, don't freak out.

61
00:02:41,290 --> 00:02:44,750
Floating point numbers are the
ones that show this behavior.

62
00:02:44,750 --> 00:02:46,639
So interestingly,
you can always--

63
00:02:46,639 --> 00:02:48,180
although we won't
put a lot of energy

64
00:02:48,180 --> 00:02:51,540
into this-- you can also
have an element of a list,

65
00:02:51,540 --> 00:02:53,020
be a list itself.

66
00:02:53,020 --> 00:02:57,460
So this is a outer list that's
got three elements: 1, 7

67
00:02:57,460 --> 00:03:00,120
and then a list that's 5 and 6.

68
00:03:00,120 --> 00:03:02,570
So if you look at
the length of this,

69
00:03:02,570 --> 00:03:04,470
there is three things in it.

70
00:03:04,470 --> 00:03:08,110
Not four, three, because the
outer list has one, two, three,

71
00:03:08,110 --> 00:03:09,910
things in it.

72
00:03:09,910 --> 00:03:13,350
An empty list is
bracket, bracket, OK?

73
00:03:13,350 --> 00:03:16,780
Like I said, we have been
going through lists all along,

74
00:03:16,780 --> 00:03:20,910
we have iteration variables
For i in, this is a list,

75
00:03:20,910 --> 00:03:23,880
we've been using it all along.

76
00:03:23,880 --> 00:03:25,740
Similarly, we've
been using lists,

77
00:03:25,740 --> 00:03:29,015
indefinite loops are a great way
to go through lists for friend

78
00:03:29,015 --> 00:03:33,090
in friends, there we have goes
through three times, outcome

79
00:03:33,090 --> 00:03:35,940
three lines with the
variable friend advancing

80
00:03:35,940 --> 00:03:38,520
through the three
successive items in the list

81
00:03:38,520 --> 00:03:40,400
and away we go.

82
00:03:40,400 --> 00:03:44,870
So again, lists are not
completely foreign to us.

83
00:03:44,870 --> 00:03:51,700
Now just like in
a string, we can

84
00:03:51,700 --> 00:03:54,270
use the index operator, the
square bracket operator,

85
00:03:54,270 --> 00:04:00,350
and we can look up items in
the list-- Sub 1, friend sub 1.

86
00:04:00,350 --> 00:04:06,120
Not surprisingly, using
the European elevator rule,

87
00:04:06,120 --> 00:04:08,700
the first item in
a list is sub 0.

88
00:04:08,700 --> 00:04:11,780
The second item is sub 1,
and the third one is sub 2.

89
00:04:11,780 --> 00:04:13,370
So here when I
print friend sub 1,

90
00:04:13,370 --> 00:04:17,190
I get Glenn, which is
the second element.

91
00:04:17,190 --> 00:04:20,230
Just like strings-- so once you
kind of know it for strings,

92
00:04:20,230 --> 00:04:22,620
lists and the rest of these
things make a lot more sense.

93
00:04:22,620 --> 00:04:24,710
Just remember that
we're in Europe,

94
00:04:24,710 --> 00:04:27,720
and things start with 0.

95
00:04:27,720 --> 00:04:31,210
Some things in these data
items that we work with

96
00:04:31,210 --> 00:04:33,460
are not mutable, so
for example, strings:

97
00:04:33,460 --> 00:04:35,500
When we ask for a lowercase
version of a string,

98
00:04:35,500 --> 00:04:37,490
we're given a copy
of that string

99
00:04:37,490 --> 00:04:40,180
and that's because
strings are not mutable.

100
00:04:40,180 --> 00:04:44,880
And we can see this by doing
something like saying, fruits

101
00:04:44,880 --> 00:04:46,700
sub 0 equals lowercase b.

102
00:04:46,700 --> 00:04:49,000
Now you'd think
that, that would just

103
00:04:49,000 --> 00:04:53,050
change this to be a lowercase
b but it doesn't, OK?

104
00:04:53,050 --> 00:04:56,550
It says string object
does not support

105
00:04:56,550 --> 00:04:58,570
item assignment, which
means that you're not

106
00:04:58,570 --> 00:05:00,440
allowed to reassign.

107
00:05:00,440 --> 00:05:03,160
You can make a new string
and put different things

108
00:05:03,160 --> 00:05:05,360
in that string but once
the strings are made,

109
00:05:05,360 --> 00:05:09,170
they're not changeable and
that's why we call fruit.lower,

110
00:05:09,170 --> 00:05:12,170
we get a copy of
it in lowercase.

111
00:05:12,170 --> 00:05:14,730
And so x is a copy of
the original string

112
00:05:14,730 --> 00:05:17,200
but the original string,
once we assign it into fruit,

113
00:05:17,200 --> 00:05:20,360
is unchanged-- can't be changed.

114
00:05:20,360 --> 00:05:21,949
This on the other
hand, can be changed

115
00:05:21,949 --> 00:05:23,490
and we can change
them in the middle.

116
00:05:23,490 --> 00:05:25,640
This is one of the things
we like about them.

117
00:05:25,640 --> 00:05:29,340
So here we have a list:
2, 14, 26, 41 and 63.

118
00:05:29,340 --> 00:05:31,510
Then we say lotto
sub 2, of course

119
00:05:31,510 --> 00:05:33,680
that is going to
be the third item,

120
00:05:33,680 --> 00:05:35,645
lotto sub 2 is equal to 28.

121
00:05:35,645 --> 00:05:38,370
Then we print it and we
see the new number there.

122
00:05:38,370 --> 00:05:41,200
So all this is saying, is that
we can change them, right?

123
00:05:41,200 --> 00:05:44,660
Strings no, and lists yes.

124
00:05:44,660 --> 00:05:49,340
You can change lists but
you can't change strings.

125
00:05:49,340 --> 00:05:52,910
So the lend function, we've
used it for several things--

126
00:05:52,910 --> 00:05:57,310
we can say lend is
used for strings

127
00:05:57,310 --> 00:05:58,720
and it's used for lists as well.

128
00:05:58,720 --> 00:06:02,122
So the same function knows
when its parameter is a string

129
00:06:02,122 --> 00:06:03,580
and when its
parameter is a string,

130
00:06:03,580 --> 00:06:06,050
it gives us the number of
characters in the string

131
00:06:06,050 --> 00:06:09,540
and when it is a list, it
gives us the number of elements

132
00:06:09,540 --> 00:06:10,640
in the list.

133
00:06:10,640 --> 00:06:12,590
And just because one
of them is a string,

134
00:06:12,590 --> 00:06:15,960
it's still one element from
the point of view of this list

135
00:06:15,960 --> 00:06:21,040
so it has one, two, three, four,
four items in the list, OK?

136
00:06:21,040 --> 00:06:24,880

137
00:06:24,880 --> 00:06:27,640
So the range function
is a special function,

138
00:06:27,640 --> 00:06:31,470
it's probably about time to
talk about the range function.

139
00:06:31,470 --> 00:06:33,240
The range function
is a function that

140
00:06:33,240 --> 00:06:37,190
generates a list, that produces
a list and gives it back to us.

141
00:06:37,190 --> 00:06:38,870
And so you give
the range function

142
00:06:38,870 --> 00:06:41,690
a parameter, how
many items you want,

143
00:06:41,690 --> 00:06:44,500
and the range function
creates and gives us

144
00:06:44,500 --> 00:06:50,590
back a list that is four numbers
starting at 0, which is 0 up to

145
00:06:50,590 --> 00:06:52,860
but not including, 3.

146
00:06:52,860 --> 00:06:53,990
Sound familiar?

147
00:06:53,990 --> 00:06:56,120
Yeah.

148
00:06:56,120 --> 00:06:58,420
0 up to but not including 4.

149
00:06:58,420 --> 00:07:00,650
And so the same
thing is true here.

150
00:07:00,650 --> 00:07:04,620
So we can combine the
lend and the range

151
00:07:04,620 --> 00:07:10,660
to say OK, we'll lend
friends, that's three items

152
00:07:10,660 --> 00:07:14,950
and range lend
friends is 0, 1, 2.

153
00:07:14,950 --> 00:07:20,560
And it also corresponds
exactly to these items.

154
00:07:20,560 --> 00:07:23,380
So we can actually
use this to construct

155
00:07:23,380 --> 00:07:27,780
loops to go through a list.

156
00:07:27,780 --> 00:07:30,950
We already have a
basic For loop, right?

157
00:07:30,950 --> 00:07:37,150
We basically have a For
loop for each friend

158
00:07:37,150 --> 00:07:41,230
and friends and outcomes, Happy
New Year Glenn and Joseph.

159
00:07:41,230 --> 00:07:44,910
If we also want to know
what position we're at

160
00:07:44,910 --> 00:07:47,150
as the loop progresses,
we can rewrite

161
00:07:47,150 --> 00:07:49,980
the exact same loop
a different way

162
00:07:49,980 --> 00:07:54,400
and make i be our iteration
variable and say i in range

163
00:07:54,400 --> 00:07:59,940
lend friends, that turns this
into 0, 1, 2, and then i goes

164
00:07:59,940 --> 00:08:02,730
0, 1, 2, and then
we can in the loop,

165
00:08:02,730 --> 00:08:04,450
look up the
particular friend that

166
00:08:04,450 --> 00:08:06,730
is the particular one
we're interested in,

167
00:08:06,730 --> 00:08:10,650
using the index
operator, friends sub i

168
00:08:10,650 --> 00:08:12,330
and then print Happy New Year.

169
00:08:12,330 --> 00:08:17,890
So these two loops
are equivalent.

170
00:08:17,890 --> 00:08:22,280

171
00:08:22,280 --> 00:08:24,130
This loop and this loop.

172
00:08:24,130 --> 00:08:28,620
This loop is preferred unless
you happen to need this value

173
00:08:28,620 --> 00:08:31,402
i, which tells you where you're
at, in case maybe you're going

174
00:08:31,402 --> 00:08:33,860
to change something, you're
going to look through something

175
00:08:33,860 --> 00:08:34,780
and then change it.

176
00:08:34,780 --> 00:08:39,080
So for what I've written here,
they're exactly equivalent.

177
00:08:39,080 --> 00:08:42,559
Prefer the simpler one unless
you need the more complex one,

178
00:08:42,559 --> 00:08:46,190
they both produce the
same kind of output.

179
00:08:46,190 --> 00:08:49,480
We can concatenate lists much
like we concatenate strings

180
00:08:49,480 --> 00:08:50,260
with a plus.

181
00:08:50,260 --> 00:08:54,730

182
00:08:54,730 --> 00:08:58,730
And you can think of the Python
operators looking to its right

183
00:08:58,730 --> 00:09:01,950
and to its left and saying,
oh, those are both lists,

184
00:09:01,950 --> 00:09:04,650
I know what to do with lists,
I'm going to put those together

185
00:09:04,650 --> 00:09:08,220
and so that produces a two,
three long lists become a six

186
00:09:08,220 --> 00:09:11,120
long list, with the first one
followed by the second one,

187
00:09:11,120 --> 00:09:12,100
concatenated.

188
00:09:12,100 --> 00:09:15,740
It didn't hurt the original,
a, c is a new list basically.

189
00:09:15,740 --> 00:09:19,060

190
00:09:19,060 --> 00:09:21,150
We can also slice lists.

191
00:09:21,150 --> 00:09:22,590
Feels a lot like strings, right?

192
00:09:22,590 --> 00:09:25,460
Everything's kind of like
strings, For loop like strings,

193
00:09:25,460 --> 00:09:28,590
concatenation like strings and
now slicing like strings and it

194
00:09:28,590 --> 00:09:32,320
is exactly the same.

195
00:09:32,320 --> 00:09:37,080
So 1, up to but not including--
just remember, up to

196
00:09:37,080 --> 00:09:38,830
but not including,
the second parameter

197
00:09:38,830 --> 00:09:41,080
is up to but not including--
so that starts at the sub

198
00:09:41,080 --> 00:09:43,600
1 which is the second one.

199
00:09:43,600 --> 00:09:47,415
Up to but not including
3, the third one so this

200
00:09:47,415 --> 00:09:49,690
is 1, 2, and 3.

201
00:09:49,690 --> 00:09:52,500
So that's 41, comma 2.

202
00:09:52,500 --> 00:09:54,760
Starting at the first one,
up to but not including

203
00:09:54,760 --> 00:09:55,410
the third one.

204
00:09:55,410 --> 00:09:58,670

205
00:09:58,670 --> 00:10:01,480
We can similarly
eliminate the first one

206
00:10:01,480 --> 00:10:03,990
so that's up to but not
including fourth one,

207
00:10:03,990 --> 00:10:08,580
is starting at 0 1, 2,
3, but not including 4,

208
00:10:08,580 --> 00:10:11,160
so that's this one.

209
00:10:11,160 --> 00:10:15,010
If we go 3 to the end,
and again remember

210
00:10:15,010 --> 00:10:17,500
the they're starting at
0, so three to the end

211
00:10:17,500 --> 00:10:22,420
is 0, 1, 2, 3, to the end, the
number three doesn't matter.

212
00:10:22,420 --> 00:10:27,050
So that's 374.15
and the whole thing,

213
00:10:27,050 --> 00:10:29,650
that's the whole thing so
these two things are the same.

214
00:10:29,650 --> 00:10:33,260
So slicing works like
strings, starting and up to,

215
00:10:33,260 --> 00:10:36,410
but not including is
the second parameter.

216
00:10:36,410 --> 00:10:40,420
There are some methods and you
can read about these online

217
00:10:40,420 --> 00:10:43,030
in the Python documentation.

218
00:10:43,030 --> 00:10:44,940
We can use the
built in function,

219
00:10:44,940 --> 00:10:49,540
doesn't have a lot of use
when we're running programs

220
00:10:49,540 --> 00:10:51,000
but it's kind of
useful, I like it

221
00:10:51,000 --> 00:10:54,430
when I'm typing interactively
like, what can this thing do?

222
00:10:54,430 --> 00:10:58,000
So I make a list, a
list is a unique type

223
00:10:58,000 --> 00:11:00,340
and I say with dir, I say,
what can we do with it?

224
00:11:00,340 --> 00:11:03,260
Well, we can append, we can
count, extend, index, insert,

225
00:11:03,260 --> 00:11:04,920
pop, remove, reverse and sort.

226
00:11:04,920 --> 00:11:08,300
And then you can sort of
read up on all these things.

227
00:11:08,300 --> 00:11:11,630
I'll show you just a couple.

228
00:11:11,630 --> 00:11:14,890
We can build a list
with the append.

229
00:11:14,890 --> 00:11:16,980
So this syntax
here, stuff equals

230
00:11:16,980 --> 00:11:19,530
list-- that's called
a constructor, which

231
00:11:19,530 --> 00:11:22,470
says give me an empty list.

232
00:11:22,470 --> 00:11:26,300
You could also say bracket,
bracket, for an empty list.

233
00:11:26,300 --> 00:11:28,100
Whatever, you've got
to make an empty list

234
00:11:28,100 --> 00:11:30,120
and then you call the append.

235
00:11:30,120 --> 00:11:33,290
Remember that lists are mutable,
so it's OK to change it.

236
00:11:33,290 --> 00:11:35,560
So we're saying, OK, we
start with an empty list

237
00:11:35,560 --> 00:11:38,180
and now append to the end
of that the word book,

238
00:11:38,180 --> 00:11:39,715
and then append to that, 99.

239
00:11:39,715 --> 00:11:43,170

240
00:11:43,170 --> 00:11:43,937
Wait a sec.

241
00:11:43,937 --> 00:11:44,645
That's a mistake.

242
00:11:44,645 --> 00:11:50,670

243
00:11:50,670 --> 00:11:55,200
So I have to fix this mistake,
so watch me fix the mistake.

244
00:11:55,200 --> 00:11:57,850
Poof!

245
00:11:57,850 --> 00:12:00,670
Now my thing is magically
fixed, isn't that amazing?

246
00:12:00,670 --> 00:12:04,020
I have magic powers when
it comes to slide fixing,

247
00:12:04,020 --> 00:12:07,457
I just snap my fingers
and the slides are fixed.

248
00:12:07,457 --> 00:12:08,040
So here we go.

249
00:12:08,040 --> 00:12:10,240
We append a 99 and
we print it out

250
00:12:10,240 --> 00:12:13,680
and it's got book and 99,
emphasizing the fact that they

251
00:12:13,680 --> 00:12:16,780
don't have to be the exact
same kind of thing in a list.

252
00:12:16,780 --> 00:12:20,380
Then later, we append cookie
and then it's book 99 cookie.

253
00:12:20,380 --> 00:12:20,880
OK?

254
00:12:20,880 --> 00:12:23,256
So this append, we won't
do it in line like this

255
00:12:23,256 --> 00:12:24,880
so often, we'll tend
to do it in a loop

256
00:12:24,880 --> 00:12:26,664
as we're building up
a list, but that's

257
00:12:26,664 --> 00:12:28,080
a way you start
with an empty list

258
00:12:28,080 --> 00:12:33,360
and then
programmatically grow it.

259
00:12:33,360 --> 00:12:35,630
We can ask-- much like
we do in a string-- we

260
00:12:35,630 --> 00:12:39,610
can ask if an item is in a
list, so here's a list called

261
00:12:39,610 --> 00:12:42,900
some with these numbers in it,
it's got five numbers in it.

262
00:12:42,900 --> 00:12:44,210
Is 9 in some?

263
00:12:44,210 --> 00:12:45,505
True, yes it is.

264
00:12:45,505 --> 00:12:47,720
Is 15 in some?

265
00:12:47,720 --> 00:12:48,790
False.

266
00:12:48,790 --> 00:12:56,690
Is 20 not in, that is legal
syntax, is 20 not in some?

267
00:12:56,690 --> 00:12:58,310
Yes, it's not there, OK?

268
00:12:58,310 --> 00:13:02,940
They don't modify the list,
they're just asking questions.

269
00:13:02,940 --> 00:13:05,320
These are logical
operations often used

270
00:13:05,320 --> 00:13:08,930
in If statements or
while, some kind of logic

271
00:13:08,930 --> 00:13:12,630
that you might be building, OK?

272
00:13:12,630 --> 00:13:15,010
So lists have order.

273
00:13:15,010 --> 00:13:17,720
So when we were pending them,
the first thing went it first,

274
00:13:17,720 --> 00:13:20,840
the second thing went in
second, et cetera, et cetera.

275
00:13:20,840 --> 00:13:23,460
And we can also tell
the list to sort itself.

276
00:13:23,460 --> 00:13:25,670
So one of the things that
we can do with a list,

277
00:13:25,670 --> 00:13:27,430
now we're starting to
see some power here,

278
00:13:27,430 --> 00:13:28,800
is say, sort yourself.

279
00:13:28,800 --> 00:13:32,020
This is a list of strings,
it can sort numbers,

280
00:13:32,020 --> 00:13:33,580
it can sort lots of things.

281
00:13:33,580 --> 00:13:37,240
Friends.sort That says,
hey, there dear friends,

282
00:13:37,240 --> 00:13:38,490
sort yourself.

283
00:13:38,490 --> 00:13:39,735
This makes a change.

284
00:13:39,735 --> 00:13:42,530

285
00:13:42,530 --> 00:13:45,140
It alters the list and
puts it in this case,

286
00:13:45,140 --> 00:13:49,280
in alphabetical order:
Glenn, Joseph and Sally.

287
00:13:49,280 --> 00:13:52,310
It's been modified
and so friend sub

288
00:13:52,310 --> 00:13:55,850
1 is now Joseph because
that's the second one, OK?

289
00:13:55,850 --> 00:14:00,030
So the sort method
says, sort yourself now

290
00:14:00,030 --> 00:14:03,660
sort yourself and it sorts
and then it stays sorted.

291
00:14:03,660 --> 00:14:06,810

292
00:14:06,810 --> 00:14:11,510
So again, you're going
to be kind of ticked

293
00:14:11,510 --> 00:14:13,730
about this particular
slide because there's

294
00:14:13,730 --> 00:14:16,790
a whole bunch of built in
functions that help with lists

295
00:14:16,790 --> 00:14:23,070
and there's max, there's min,
there's lend, various things.

296
00:14:23,070 --> 00:14:24,820
All those loops that
I told you how to do,

297
00:14:24,820 --> 00:14:27,060
I was just showing you
that stuff because I

298
00:14:27,060 --> 00:14:29,390
thought it was important.

299
00:14:29,390 --> 00:14:32,620
This is the simplest way to go
through and find the largest,

300
00:14:32,620 --> 00:14:35,370
smallest n, sum, et cetera.

301
00:14:35,370 --> 00:14:38,140
So here's a list of numbers.

302
00:14:38,140 --> 00:14:40,749
We can say how many are
there, that's the count.

303
00:14:40,749 --> 00:14:42,040
We can say, what's the largest?

304
00:14:42,040 --> 00:14:43,477
It's 74.

305
00:14:43,477 --> 00:14:44,310
What's the smallest?

306
00:14:44,310 --> 00:14:46,260
That'd be 3.

307
00:14:46,260 --> 00:14:48,380
What is the sum, the
running total of them all,

308
00:14:48,380 --> 00:14:50,790
154, if you remember
from a few lectures ago

309
00:14:50,790 --> 00:14:52,290
these are the same numbers.

310
00:14:52,290 --> 00:14:53,900
And what is the average?

311
00:14:53,900 --> 00:14:58,120
Which is sum of them over
the length of them, OK?

312
00:14:58,120 --> 00:15:00,100
So this makes a lot
more sense and if you

313
00:15:00,100 --> 00:15:01,770
had a list of numbers
like this, you

314
00:15:01,770 --> 00:15:04,610
would simply say what's the max,
you wouldn't write a max loop,

315
00:15:04,610 --> 00:15:09,580
I just did that to
demonstrate how loops work.

316
00:15:09,580 --> 00:15:13,990
So here is a way that you
can sort of change those kind

317
00:15:13,990 --> 00:15:16,580
of programs that we wrote.

318
00:15:16,580 --> 00:15:19,790
So there's two ways to
write a summing program.

319
00:15:19,790 --> 00:15:23,040
Let's just say instead of
the data being in a list,

320
00:15:23,040 --> 00:15:25,610
we're going to write
a While loop that's

321
00:15:25,610 --> 00:15:28,850
going to read a set of
numbers until we say done,

322
00:15:28,850 --> 00:15:31,540
and then compute the average
of those numbers, OK?

323
00:15:31,540 --> 00:15:35,020
So let's say this is our
problem: Read a list of numbers

324
00:15:35,020 --> 00:15:38,200
and wait until the word done
comes in and then average them.

325
00:15:38,200 --> 00:15:40,460
So here's a little
program that does that.

326
00:15:40,460 --> 00:15:43,250
We create total equal
0 count equal 0,

327
00:15:43,250 --> 00:15:46,080
making an infinite
loop with while true,

328
00:15:46,080 --> 00:15:48,920
and then we ask
to enter a number,

329
00:15:48,920 --> 00:15:51,780
we get a string back from
this-- remember raw input always

330
00:15:51,780 --> 00:15:55,290
gives us strings back--
and then if it's done,

331
00:15:55,290 --> 00:15:56,810
we're going to break.

332
00:15:56,810 --> 00:15:58,890
This is the version
of an If that does not

333
00:15:58,890 --> 00:16:02,020
require an indent, we just put
the break up there and so that

334
00:16:02,020 --> 00:16:04,150
gets us out of the loop
when the time is right

335
00:16:04,150 --> 00:16:05,990
so when the time
is right over here,

336
00:16:05,990 --> 00:16:09,830
and then we convert
the value to float,

337
00:16:09,830 --> 00:16:12,590
we use float to convert the
input to a floating point

338
00:16:12,590 --> 00:16:14,920
number and then we do
our accumulation pattern,

339
00:16:14,920 --> 00:16:18,017
total equals total plus value,
count equals count plus 1.

340
00:16:18,017 --> 00:16:19,600
So this is going to
run, these numbers

341
00:16:19,600 --> 00:16:21,244
are going to go up
and up and up and up

342
00:16:21,244 --> 00:16:22,910
and then we're going
to break out of it,

343
00:16:22,910 --> 00:16:25,906
calculate the average and
then print the average.

344
00:16:25,906 --> 00:16:27,780
Because that's a floating
point number so now

345
00:16:27,780 --> 00:16:29,870
the average is a
floating point number.

346
00:16:29,870 --> 00:16:31,430
So that's one way
to do it, right?

347
00:16:31,430 --> 00:16:34,790
That would be one way
to write a program that

348
00:16:34,790 --> 00:16:37,990
does an average, is
keep a running average

349
00:16:37,990 --> 00:16:40,080
as you're reading the numbers.

350
00:16:40,080 --> 00:16:43,180
But there's another
way to do it that would

351
00:16:43,180 --> 00:16:45,890
work exactly the
same way, and this is

352
00:16:45,890 --> 00:16:48,040
when you can start using lists.

353
00:16:48,040 --> 00:16:53,300
So come in, you say I'm going
to make a list of numbers

354
00:16:53,300 --> 00:16:56,830
just a mnemonic name number
list is an empty list.

355
00:16:56,830 --> 00:16:59,140
Then I create
another infinite loop

356
00:16:59,140 --> 00:17:02,060
that's going to read
for enter a number,

357
00:17:02,060 --> 00:17:06,750
and if it's done break that
kind of gets us out of it.

358
00:17:06,750 --> 00:17:12,390
Convert the input
value to a float

359
00:17:12,390 --> 00:17:14,450
and then append it to the list.

360
00:17:14,450 --> 00:17:17,560
So now the list is going to
grow each time we read a number,

361
00:17:17,560 --> 00:17:18,800
the list is going to grow.

362
00:17:18,800 --> 00:17:22,040
However many times we add
the numbers, how many things

363
00:17:22,040 --> 00:17:23,520
are going to be in the list.

364
00:17:23,520 --> 00:17:26,770
So in this case when we're
at this and we type done,

365
00:17:26,770 --> 00:17:28,319
there'll be three
numbers in the list

366
00:17:28,319 --> 00:17:30,152
because we will have
run append three times,

367
00:17:30,152 --> 00:17:32,690
we'll have appended
3, 9, and 5 we'll

368
00:17:32,690 --> 00:17:37,140
have them sitting in a list, and
we will have exited the loop.

369
00:17:37,140 --> 00:17:40,340
So now you say oh, add up
all the numbers in that list

370
00:17:40,340 --> 00:17:42,690
and then divide it by
the length of the list

371
00:17:42,690 --> 00:17:44,050
and print the average.

372
00:17:44,050 --> 00:17:46,190
So these two programs
are basically

373
00:17:46,190 --> 00:17:49,150
equivalent-- the only time that
they might not be equivalent

374
00:17:49,150 --> 00:17:54,180
was if there was
ten million numbers,

375
00:17:54,180 --> 00:17:59,167
this would use up 40 megabytes
of your memory, which

376
00:17:59,167 --> 00:18:01,250
is actually not a lot of
memory on some computers,

377
00:18:01,250 --> 00:18:05,200
but if memory mattered this
does store all those numbers--

378
00:18:05,200 --> 00:18:07,690
this one actually just
runs the calculation

379
00:18:07,690 --> 00:18:10,220
so if there's a really
large number of numbers,

380
00:18:10,220 --> 00:18:12,820
this would make a difference
because the list is growing

381
00:18:12,820 --> 00:18:15,690
and keeping them all,
summing them all at the end,

382
00:18:15,690 --> 00:18:18,560
this is actually storing
very little data.

383
00:18:18,560 --> 00:18:21,770
But for reasonably sized
numbers like thousands or even

384
00:18:21,770 --> 00:18:23,560
hundreds of
thousands of numbers,

385
00:18:23,560 --> 00:18:26,970
these two approaches
are kind of equivalent

386
00:18:26,970 --> 00:18:29,170
and then sometimes
you actually want

387
00:18:29,170 --> 00:18:31,640
to accumulate something a
little more complex than this,

388
00:18:31,640 --> 00:18:33,960
you want to sort them,
or look for the maximum

389
00:18:33,960 --> 00:18:35,970
and look for something
else, who knows what.

390
00:18:35,970 --> 00:18:39,180
But the notion of make a list
and then append something

391
00:18:39,180 --> 00:18:41,270
to the list each time
through the iteration

392
00:18:41,270 --> 00:18:43,580
and then do something
with a list at the end,

393
00:18:43,580 --> 00:18:45,450
is a rather powerful pattern.

394
00:18:45,450 --> 00:18:47,910
So this is also a
powerful pattern,

395
00:18:47,910 --> 00:18:49,520
this is accumulator
pattern we just

396
00:18:49,520 --> 00:18:51,930
have variables
accumulating in the loop,

397
00:18:51,930 --> 00:18:55,420
this one is one where we
accumulate the data in the loop

398
00:18:55,420 --> 00:18:58,470
and then do the
computations all at the end.

399
00:18:58,470 --> 00:19:03,140
Certain situations will make use
of these different techniques.

400
00:19:03,140 --> 00:19:03,836
OK so.

401
00:19:03,836 --> 00:19:06,620

402
00:19:06,620 --> 00:19:08,980
Connecting strings and lists.

403
00:19:08,980 --> 00:19:12,450
So there's a method, a
capability of strings,

404
00:19:12,450 --> 00:19:16,230
that is really powerful when
it comes to tearing data apart.

405
00:19:16,230 --> 00:19:18,870

406
00:19:18,870 --> 00:19:21,440
It's called the split.

407
00:19:21,440 --> 00:19:25,250
So here is a string
with three words

408
00:19:25,250 --> 00:19:30,810
and has blanks in between
here and abc.split

409
00:19:30,810 --> 00:19:35,370
says parse this string,
look for the blanks,

410
00:19:35,370 --> 00:19:37,580
break the string into
pieces, and give me

411
00:19:37,580 --> 00:19:43,790
back a list with one item for
each of the words in the list

412
00:19:43,790 --> 00:19:47,220
as defined by the spaces, OK?

413
00:19:47,220 --> 00:19:51,630
So it breaks it
into three pieces

414
00:19:51,630 --> 00:19:55,830
and gives us that back in the
list, it's very powerful, OK?

415
00:19:55,830 --> 00:19:58,330
So we're going to split
it and we get back a list.

416
00:19:58,330 --> 00:20:01,990
There are three words
and the first word,

417
00:20:01,990 --> 00:20:04,190
stuff sub 0 is With.

418
00:20:04,190 --> 00:20:06,310
So there's a lot of
parsing going on here.

419
00:20:06,310 --> 00:20:08,920
We could do this with For
loops and a lot of other things

420
00:20:08,920 --> 00:20:11,280
but there would be a lot
of work in the split.

421
00:20:11,280 --> 00:20:13,570
Given that this is a
really common task,

422
00:20:13,570 --> 00:20:17,950
it's really great that this has
been put into Python for us,

423
00:20:17,950 --> 00:20:19,340
OK?

424
00:20:19,340 --> 00:20:21,030
So split breaks a
string into parts

425
00:20:21,030 --> 00:20:24,720
and produce a list of strings,
we think of these as words

426
00:20:24,720 --> 00:20:26,400
and we can access
a particular word

427
00:20:26,400 --> 00:20:28,120
or we can loop
through all the words.

428
00:20:28,120 --> 00:20:29,830
So here we have
stuff again and now

429
00:20:29,830 --> 00:20:34,300
we have a For loop that's going
to go through each of the three

430
00:20:34,300 --> 00:20:36,410
words and then it's
going to run three times.

431
00:20:36,410 --> 00:20:38,470
Now chances are good we're going
to do something different other

432
00:20:38,470 --> 00:20:39,850
than just print
them out, but you

433
00:20:39,850 --> 00:20:43,442
see how you quickly can take
us split followed by a For

434
00:20:43,442 --> 00:20:45,650
and then write a loop that's
going to go through each

435
00:20:45,650 --> 00:20:48,390
of the words without working
too hard to find the spaces,

436
00:20:48,390 --> 00:20:53,460
you let Python do all the hard
work of finding the spaces, OK?

437
00:20:53,460 --> 00:20:58,170
So let's take a look
at a couple of samples,

438
00:20:58,170 --> 00:21:01,540
just a couple things to teach
you a little more about split.

439
00:21:01,540 --> 00:21:08,490
Split looks at many spaces as
equal to one space so if you

440
00:21:08,490 --> 00:21:11,330
split a lot of spaces,
it's still just

441
00:21:11,330 --> 00:21:15,770
throws away all those spaces
and gives us four words.

442
00:21:15,770 --> 00:21:20,140
One, two, three, four and
throws away all the spaces

443
00:21:20,140 --> 00:21:23,130
because it assumes that's what
we want done, so that's nice.

444
00:21:23,130 --> 00:21:28,710
You can also have split
on some other characters.

445
00:21:28,710 --> 00:21:30,670
Sometimes you'll be
getting data and they'll

446
00:21:30,670 --> 00:21:32,920
have used a
semicolon, or a comma,

447
00:21:32,920 --> 00:21:36,810
or a colon, or a tab character,
who knows what they've used,

448
00:21:36,810 --> 00:21:39,440
and your job is to
dig that data out.

449
00:21:39,440 --> 00:21:42,890
So you can split based
on a different character.

450
00:21:42,890 --> 00:21:45,580
Here, if we're
splitting normally,

451
00:21:45,580 --> 00:21:48,740
this is a normal split, it's
not going to see the semicolons,

452
00:21:48,740 --> 00:21:50,420
it's looking for
a space and so all

453
00:21:50,420 --> 00:21:55,250
we get back is one item in
the string with a semicolon.

454
00:21:55,250 --> 00:22:00,220
But if we switch and we pass
semicolon in as a parameter

455
00:22:00,220 --> 00:22:04,140
to split, then it will know to
split it based on semicolons

456
00:22:04,140 --> 00:22:07,580
and gives us first,
second and third back.

457
00:22:07,580 --> 00:22:08,090
OK?

458
00:22:08,090 --> 00:22:10,030
And then it gives
us three words.

459
00:22:10,030 --> 00:22:13,030
So you can split
either on spaces

460
00:22:13,030 --> 00:22:20,340
or you can split on a character
other than a space, OK?

461
00:22:20,340 --> 00:22:23,630
So let's take a look at
how we might turn this

462
00:22:23,630 --> 00:22:25,270
into some of our
common assignments

463
00:22:25,270 --> 00:22:26,910
that we have this
chapter, we're going

464
00:22:26,910 --> 00:22:29,210
to read some of
the mailbox data.

465
00:22:29,210 --> 00:22:33,280

466
00:22:33,280 --> 00:22:36,820
So here we go with
a little program.

467
00:22:36,820 --> 00:22:39,540
First three lines,
we write these a lot.

468
00:22:39,540 --> 00:22:42,460
Open the file, write
a For loop to loop

469
00:22:42,460 --> 00:22:45,120
through each line in
the file, then we're

470
00:22:45,120 --> 00:22:48,120
going to strip off the white
space at the end the line.

471
00:22:48,120 --> 00:22:50,970
One, two, three, do
those all the time.

472
00:22:50,970 --> 00:22:54,645
And we're looking for lines,
if you look at the whole file,

473
00:22:54,645 --> 00:22:56,020
we're looking at
lines that start

474
00:22:56,020 --> 00:22:58,160
with from followed by a space.

475
00:22:58,160 --> 00:23:00,450
So if the line does
not start with from

476
00:23:00,450 --> 00:23:03,720
followed by a space, that's a
space right there, continue.

477
00:23:03,720 --> 00:23:08,480
So that's a way to skip all the
lines the don't look like this.

478
00:23:08,480 --> 00:23:10,310
There are thousands
of lines in this file

479
00:23:10,310 --> 00:23:13,260
and just a few that
look like this, OK?

480
00:23:13,260 --> 00:23:16,680
And so we're going
to look and we're

481
00:23:16,680 --> 00:23:21,750
going to try to find what
day of the week this thing

482
00:23:21,750 --> 00:23:24,010
happened on.

483
00:23:24,010 --> 00:23:26,300
So we're throwing
away all the lines

484
00:23:26,300 --> 00:23:27,720
with this little bit of code.

485
00:23:27,720 --> 00:23:30,260
Then what we do is we
take the line, which

486
00:23:30,260 --> 00:23:34,080
is all of this text,
and then we split it.

487
00:23:34,080 --> 00:23:38,330
And we know that the day
of the week is word sub 2.

488
00:23:38,330 --> 00:23:41,610
So this is word sub
0, this is word sub 1,

489
00:23:41,610 --> 00:23:43,080
and this is word sub 2.

490
00:23:43,080 --> 00:23:46,490
So this is word sub
0, sub 1, and sub 2.

491
00:23:46,490 --> 00:23:50,550
And so all we have to do
is print out the sub 2

492
00:23:50,550 --> 00:23:53,730
and we throw away all the
lines except the from lines,

493
00:23:53,730 --> 00:23:59,150
we split them and take the
third word or word sub 2,

494
00:23:59,150 --> 00:24:00,640
and we can quickly
create something

495
00:24:00,640 --> 00:24:06,030
that's extracting the
data week out of these.

496
00:24:06,030 --> 00:24:07,360
OK?

497
00:24:07,360 --> 00:24:12,040
So it's quick because
split does the tricky work.

498
00:24:12,040 --> 00:24:14,790
If you go back to
the strings chapter,

499
00:24:14,790 --> 00:24:18,030
you saw that we did a lot of
work to get this to happen.

500
00:24:18,030 --> 00:24:21,090
So here's even another
tricky pattern.

501
00:24:21,090 --> 00:24:25,640
So let's say we want to do what
we did at the end of chapter

502
00:24:25,640 --> 00:24:29,660
six, the string chapter, let's
say we wanted to get back

503
00:24:29,660 --> 00:24:33,360
this little bit of data, OK?

504
00:24:33,360 --> 00:24:36,190
So we can look at
this and say, OK,

505
00:24:36,190 --> 00:24:41,500
let's split this-- and this will
be 0, 1, and 2, and 3, and 4,

506
00:24:41,500 --> 00:24:42,460
5, and 6.

507
00:24:42,460 --> 00:24:44,700
We're splitting it
based on spaces then

508
00:24:44,700 --> 00:24:51,230
that email address is
words sub 1, right?

509
00:24:51,230 --> 00:24:54,330
So that email address
is this little bit

510
00:24:54,330 --> 00:24:57,490
of stuff because it's in
between spaces, right?

511
00:24:57,490 --> 00:25:03,540
So that's what we pull out, the
email address is words sub 1,

512
00:25:03,540 --> 00:25:04,700
and we've got that.

513
00:25:04,700 --> 00:25:07,500
So that's sitting in this
email address variable.

514
00:25:07,500 --> 00:25:10,540
Then all we want, we don't
really want the whole thing,

515
00:25:10,540 --> 00:25:12,770
we just want the
part after the @,

516
00:25:12,770 --> 00:25:17,510
and we could do a
look up of the @,

517
00:25:17,510 --> 00:25:29,070
but you can also do
a second split, OK?

518
00:25:29,070 --> 00:25:30,830
So we're taking
this variable here,

519
00:25:30,830 --> 00:25:33,950
email, which is merely this
little part right here,

520
00:25:33,950 --> 00:25:37,020
and we are splitting it
again except this time

521
00:25:37,020 --> 00:25:38,620
we're splitting it
based on an @ which

522
00:25:38,620 --> 00:25:40,890
means it's going to
bust it right here

523
00:25:40,890 --> 00:25:44,010
and find us two pieces.

524
00:25:44,010 --> 00:25:50,290
So pieces now is a list where
the sub 0 item is the person's

525
00:25:50,290 --> 00:25:55,120
name and the sub 1 item is the
host that their mail address is

526
00:25:55,120 --> 00:25:57,710
held from, OK?

527
00:25:57,710 --> 00:26:00,250
And so then, all
we need to know is

528
00:26:00,250 --> 00:26:08,000
pieces sub 1 and pieces sub
1 is this guy right here.

529
00:26:08,000 --> 00:26:10,780
So that's pieces sub 1
and so we pulled it out.

530
00:26:10,780 --> 00:26:13,300
So if you go back to
how we did it before,

531
00:26:13,300 --> 00:26:15,510
we were doing searching
and we were searching some

532
00:26:15,510 --> 00:26:17,870
and then we're
taking slices-- this

533
00:26:17,870 --> 00:26:19,410
is a little more elegant, OK?

534
00:26:19,410 --> 00:26:21,550
Because really, we split
it and then we split it,

535
00:26:21,550 --> 00:26:23,300
and we knew what piece
we were looking at.

536
00:26:23,300 --> 00:26:26,040
So this is what I call
the double split pattern,

537
00:26:26,040 --> 00:26:28,470
where you split a
string into a list,

538
00:26:28,470 --> 00:26:29,970
then you take the
thing out and then

539
00:26:29,970 --> 00:26:33,060
you split it again, depending
on what data you're looking for.

540
00:26:33,060 --> 00:26:36,780
This is just a technique,
it's not the only technique.

541
00:26:36,780 --> 00:26:41,970
OK so that's lists, we
talked about the concept

542
00:26:41,970 --> 00:26:44,530
of a collection where lists
have multiple things in it,

543
00:26:44,530 --> 00:26:48,020
indefinite loops, again
we've seen these things,

544
00:26:48,020 --> 00:26:51,070
it looks a lot like
strings except the elements

545
00:26:51,070 --> 00:26:53,110
are more powerful and
they're more mutable.

546
00:26:53,110 --> 00:26:54,820
We still use the
bracket operator

547
00:26:54,820 --> 00:26:58,680
and we re-did the
max, min and sum

548
00:26:58,680 --> 00:27:02,350
except we did it in one line,
rather than a whole loop.

549
00:27:02,350 --> 00:27:04,280
And something we're
going to play with a lot,

550
00:27:04,280 --> 00:27:08,020
is using split to parse strings,
the single split and then

551
00:27:08,020 --> 00:27:11,090
the double split is a natural
extension of the single split.

552
00:27:11,090 --> 00:27:13,500
So, see you in the next
lecture, looking forward

553
00:27:13,500 --> 00:27:15,710
to talking about dictionaries.